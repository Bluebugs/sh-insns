{
  "instructions": [
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov\tRm,Rn",
      "abstract": "Rm -> Rn",
      "code": "0110nnnnmmmm0011",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOV (int m, int n)\n{\n  R[n] = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov\t#imm,Rn",
      "abstract": "imm -> sign extension -> Rn",
      "code": "1110nnnniiiiiiii",
      "T": "-",
      "description": "Stores immediate data, sign-extended to longword, in general register Rn.<br /><br /><br />",
      "operation": "void MOVI (int i, int n)\n{\n  if ((i &amp; 0x80) == 0)\n    R[n] = (0x000000FF &amp; i);\n  else\n    R[n] = (0xFFFFFF00 | i);\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movi20\t#imm20,Rn",
      "abstract": "imm -> sign extension -> Rn",
      "code": "0000nnnniiii0000 iiiiiiiiiiiiiiii",
      "T": "-",
      "description": "Stores immediate data that has been sign-extended to longword in general<br />register Rn.<br /><br /><br /><br />",
      "operation": "void MOVI20 (int i, int n)\n{\n  if (i &amp; 0x00080000) == 0)\n    R[n] = (0x000FFFFF &amp; (long)i);\n  else\n    R[n] = (0xFFF00000 | (long)i);\n\n  PC += 4;\n}\n\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movi20s\t#imm20,Rn",
      "abstract": "imm << 8 -> sign extension -> Rn",
      "code": "0000nnnniiii0001 iiiiiiiiiiiiiiii",
      "T": "-",
      "description": "Shifts immediate data 8 bits to the left and performs sign extension to<br />longword, then stores the resulting data in general register Rn. Using an OR or<br />ADD instruction as the next instruction enables a 28-bit absolute address to be<br />generated.<br /><br /><br /><br />",
      "operation": "void MOVI20S (int i, int n)\n{\n  if (i &amp; 0x00080000) == 0)\n    R[n] = (0x000FFFFF &amp; (long)i);\n  else\n    R[n] = (0xFFF00000 | (long)i);\n\n  R[n] &lt;<= 8;\n  pc += 4;\n}"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mova\t@(disp,PC),R0",
      "abstract": "(disp*4) + (PC & 0xFFFFFFFC) + 4 -> R0",
      "code": "11000111dddddddd",
      "T": "-",
      "description": "Stores the effective address of the source operand into general<br />register R0.  The 8-bit displacement is zero-extended and quadrupled.<br />Consequently, the relative interval from the operand is PC + 1020 bytes.  The PC<br />is the address four bytes after this instruction, but the lowest two bits of the<br />PC are fixed at 00.<br /><br /><br />NoteSH1*, SH2*, SH3*:<br />If this instruction is placed immediately after a delayed branch instruction,<br />the PC must point to an address specified by (the starting address of the branch<br />destination) + 2.<br /><br />SH4*:<br />If this instruction is executed in a delay slot, a slot illegal instruction<br />exception will be generated.<br /><br /><br />",
      "operation": "void MOVA (int d)\n{\n  unsigned int disp;\n  disp = (unsigned int)(0x000000FF &amp; d);\n  R[0] = (PC &amp; 0xFFFFFFFC) + 4 + (disp &lt;&lt; 2);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\t@(disp,PC),Rn",
      "abstract": "(disp*2 + PC + 4) -> sign extension -> Rn",
      "code": "1001nnnndddddddd",
      "T": "-",
      "description": "Stores immediate data, sign-extended to longword, in general register Rn.<br />The data is stored from memory address (PC + 4 + displacement * 2).<br />The 8-bit displacement is multiplied by two after zero-extension, and so the<br />relative distance from the table is in the range up to PC + 4 + 510 bytes. The<br />PC value is the address of this instruction.<br /><br /><br />NoteIf the following instruction is a branch instruction, it is identified as a slot<br />illegal instruction.<br /><br /><br />",
      "operation": "void MOVWI (int d, int n)\n{\n  unsigned int disp = (0x000000FF &amp; d);\n  R[n] = Read_16 (PC + 4 + (disp &lt;&lt; 1));\n  if ((R[n] &amp; 0x8000) == 0)\n    R[n] &amp;= 0x0000FFFF;\n  else\n    R[n] |= 0xFFFF0000;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\t@(disp,PC),Rn",
      "abstract": "(disp*4 + (PC & 0xFFFFFFFC) + 4) -> sign extension -> Rn",
      "code": "1101nnnndddddddd",
      "T": "-",
      "description": "Stores immediate data, sign-extended to longword, in general register Rn.<br />The data is stored from memory address (PC + 4 + displacement * 4).<br />The 8-bit displacement is multiplied by four after zero-extension, and so the<br />relative distance from the operand is in the range up to PC + 4 + 1020 bytes.<br />The PC value is the address of this instruction. A value with the lower 2 bits<br />adjusted to 00 is used in address calculation.<br /><br /><br />NoteIf the following instruction is a branch instruction, it is identified as a slot<br />illegal instruction.<br /><br /><br />",
      "operation": "void MOVLI (int d, int n)\n{\n  unsigned int disp = (0x000000FF &amp; d);\n  R[n] = Read_32 ((PC &amp; 0xFFFFFFFC) + 4 + (disp &lt;&lt; 2));\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\t@Rm,Rn",
      "abstract": "(Rm) -> sign extension -> Rn",
      "code": "0110nnnnmmmm0000",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVBL (int m, int n)\n{\n  R[n] = Read_8 (R[m]);\n  if ((R[n] &amp; 0x80) == 0)\n    R[n] &amp;= 0x000000FF;\n  else\n    R[n] |= 0xFFFFFF00;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\t@Rm,Rn",
      "abstract": "(Rm) -> sign extension -> Rn",
      "code": "0110nnnnmmmm0001",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVWL (int m, int n)\n{\n  R[n] = Read_16 (R[m]);\n  if ((R[n] &amp; 0x8000) == 0)\n    R[n] &amp;= 0x0000FFFF;\n  else\n    R[n] |= 0xFFFF0000;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\t@Rm,Rn",
      "abstract": "(Rm) -> Rn",
      "code": "0110nnnnmmmm0010",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVLL (int m, int n)\n{\n  R[n] = Read_32 (R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\tRm,@Rn",
      "abstract": "Rm -> (Rn)",
      "code": "0010nnnnmmmm0000",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVBS (int m, int n)\n{\n  Write_8 (R[n], R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\tRm,@Rn",
      "abstract": "Rm -> (Rn)",
      "code": "0010nnnnmmmm0001",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVWS (int m, int n)\n{\n  Write_16 (R[n], R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\tRm,@Rn",
      "abstract": "Rm -> (Rn)",
      "code": "0010nnnnmmmm0010",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVLS (int m, int n)\n{\n  Write_32 (R[n], R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\t@Rm+,Rn",
      "abstract": "(Rm) -> sign extension -> Rn, Rm+1 -> Rm",
      "code": "0110nnnnmmmm0100",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVBP (int m, int n)\n{\n  R[n] = Read_8 (R[m]);\n  if ((R[n] &amp; 0x80) == 0)\n    R[n] &amp;= 0x000000FF;\n  else\n    R[n] |= 0xFFFFFF00;\n\n  if (n != m)\n    R[m] += 1;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\t@Rm+,Rn",
      "abstract": "(Rm) -> sign extension -> Rn, Rm+2 -> Rm",
      "code": "0110nnnnmmmm0101",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVWP (int m, int n)\n{\n  R[n] = Read_16 (R[m]);\n  if ((R[n] &amp; 0x8000) == 0)\n    R[n] &amp;= 0x0000FFFF;\n  else\n    R[n] |= 0xFFFF0000;\n\n  if (n != m)\n    R[m] += 2;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\t@Rm+,Rn",
      "abstract": "(Rm) -> Rn, Rm+4 -> Rm",
      "code": "0110nnnnmmmm0110",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVLP (int m, int n)\n{\n  R[n] = Read_32 (R[m]);\n\n  if (n != m)\n    R[m] += 4;\n\n  PC += 2;\n}\n\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\tRm,@-Rn",
      "abstract": "Rn-1 -> Rn, Rm -> (Rn)",
      "code": "0010nnnnmmmm0100",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVBM (int m, int n)\n{\n  Write_8 (R[n] - 1, R[m]);\n  R[n] -= 1;\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\tRm,@-Rn",
      "abstract": "Rn-2 -> Rn, Rm -> (Rn)",
      "code": "0010nnnnmmmm0101",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVWM (int m, int n)\n{\n  Write_16 (R[n] - 2, R[m]);\n  R[n] -= 2;\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\tRm,@-Rn",
      "abstract": "Rn-4 -> Rn, Rm -> (Rn)",
      "code": "0010nnnnmmmm0110",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVLM (int m, int n)\n{\n  Write_32 (R[n] - 4, R[m]);\n  R[n] -= 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\t@-Rm,R0",
      "abstract": "Rm-1 -> Rm, (Rm) -> sign extension -> R0",
      "code": "0100mmmm11001011",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVRSBM (int m)\n{\n  R[m] -= 1;\n  R[0] = Read_16 (R[m]);\n\n  if ((R[0] &amp; 0x80) == 0)\n    R[0] &amp;= 0x000000FF;\n  else\n    R[0] |= 0xFFFFFF00;\n\n  PC+=2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\t@-Rm,R0",
      "abstract": "Rm-2 -> Rm, (Rm) -> sign extension -> R0",
      "code": "0100mmmm11011011",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVRSWM (int m)\n{\n  R[m]-= 2;\n  R[0] = Read_16 (R[m]);\n\n  if ((R[0] &amp; 0x8000) == 0)\n    R[0] &amp;= 0x0000FFFF;\n  else\n    R[0] |= 0xFFFF0000;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\t@-Rm,R0",
      "abstract": "Rm-4 -> Rm, (Rm) -> R0",
      "code": "0100mmmm11101011",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVRSLM (int m)\n{\n  R[m] -= 4;\n  R[0] = Read_32 (R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\tR0,@Rn+",
      "abstract": "R0 -> (Rn), Rn+1 -> Rn",
      "code": "0100nnnn10001011",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVRSBP (int n)\n{\n  Write_8 (R[n], R[0]);\n  R[n] += 1;\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\tR0,@Rn+",
      "abstract": "R0 -> (Rn), Rn+2 -> Rn",
      "code": "0100nnnn10011011",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVRSWP (int n)\n{\n  Write_16 (R[n], R[0]);\n  R[n] += 2;\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\tR0,@Rn+",
      "abstract": "R0 -> (Rn), Rn+4 -> Rn",
      "code": "0100nnnn10101011",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVRSLP (int n)\n{\n  Write_32 (R[n], R[0]);\n  R[n] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\t@(disp,Rm),R0",
      "abstract": "(disp + Rm) -> sign extension -> R0",
      "code": "10000100mmmmdddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The 4-bit displacement is only zero-extended, so a range up to +15 bytes<br />can be specified. If a memory operand cannot be reached, the @(R0,Rn) mode can<br />be used instead.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVBL4 (int m, int d)\n{\n  long disp = (0x0000000F &amp; (long)d);\n  R[0] = Read_8 (R[m] + disp);\n\n  if ((R[0] &amp; 0x80) == 0)\n    R[0] &amp;= 0x000000FF;\n  else\n    R[0] |= 0xFFFFFF00;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\t@(disp12,Rm),Rn",
      "abstract": "(disp + Rm) -> sign extension -> Rn",
      "code": "0011nnnnmmmm0001 0100dddddddddddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.  This<br />instruction is ideal for data access in a structure or the stack.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVBL12 (int d, int m, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  R[n] = Read_8 (R[m] + disp);\n\n  if ((R[n] &amp; 0x80) == 0)\n    R[n] &amp;= 0x000000FF;\n  else\n    R[n] |= 0xFFFFFF00;\n\n  PC += 4;\n}\n\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movu.b\t@(disp12,Rm),Rn",
      "abstract": "(disp + Rm) -> zero extension -> Rn",
      "code": "0011nnnnmmmm0001 1000dddddddddddd",
      "T": "-",
      "description": "Transfers a source operand to a destination, performing unsigned data transfer.<br />This instruction is ideal for data access in a structure or the stack.<br />The loaded data is zero-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVBUL12 (int d, int m, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  R[n] = Read_8 (R[m] + disp);\n  R[n] &amp;= 0x000000FF;\n  PC += 4;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\t@(disp,Rm),R0",
      "abstract": "(disp*2 + Rm) -> sign extension -> R0",
      "code": "10000101mmmmdddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The 4-bit displacement is multiplied by two after zero-extension, enabling a<br />range up to +30 bytes to be specified.  If a memory operand cannot be reached,<br />the @(R0,Rn) mode can be used instead.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVWL4 (int m, int d)\n{\n  long disp = (0x0000000F &amp; (long)d);\n  R[0] = Read_16 (R[m] + (disp &lt;&lt; 1));\n\n  if ((R[0] &amp; 0x8000) == 0)\n    R[0] &amp;= 0x0000FFFF;\n  else\n    R[0] |= 0xFFFF0000;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\t@(disp12,Rm),Rn",
      "abstract": "(disp*2 + Rm) -> sign extension -> Rn",
      "code": "0011nnnnmmmm0001 0101dddddddddddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.  This<br />instruction is ideal for data access in a structure or the stack.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVWL12 (int d, int m, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  R[n] = Read_16 (R[m] + (disp &lt;&lt; 1));\n\n  if ((R[n] &amp; 0x8000) == 0)\n    R[n] &amp;= 0x0000FFFF;\n  else\n    R[n] |= 0xFFFF0000;\n\n  PC += 4;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movu.w\t@(disp12,Rm),Rn",
      "abstract": "(disp*2 + Rm) -> zero extension -> Rn",
      "code": "0011nnnnmmmm0001 1001dddddddddddd",
      "T": "-",
      "description": "Transfers a source operand to a destination, performing unsigned data transfer.<br />This instruction is ideal for data access in a structure or the stack.<br />The loaded data is zero-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVWUL12 (int d, int m, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  R[n] = Read_16 (R[m] + (disp &lt;&lt; 1));\n  R[n] &amp;= 0x0000FFFF;\n  PC += 4;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\t@(disp,Rm),Rn",
      "abstract": "(disp*4 + Rm) -> Rn",
      "code": "0101nnnnmmmmdddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The 4-bit displacement is multiplied by four after zero-extension, enabling a<br />range up to +60 bytes to be specified.  If a memory operand cannot be reached,<br />the @(R0,Rn) mode can be used instead.<br /><br /><br />",
      "operation": "void MOVLL4 (int m, int d, int n)\n{\n  long disp = (0x0000000F &amp; (long)d);\n  R[n] = Read_32 (R[m] + (disp &lt;&lt; 2));\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\t@(disp12,Rm),Rn",
      "abstract": "(disp*4 + Rm) -> Rn",
      "code": "0011nnnnmmmm0001 0110dddddddddddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.  This<br />instruction is ideal for data access in a structure or the stack.<br /><br /><br />",
      "operation": "void MOVLL12 (int d, int m, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  R[n] = Read_32 (R[m] + (disp &lt;&lt; 2));\n  PC += 4;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\tR0,@(disp,Rn)",
      "abstract": "R0 -> (disp + Rn)",
      "code": "10000000nnnndddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The 4-bit displacement is only zero-extended, so a range up to +15 bytes<br />can be specified. If a memory operand cannot be reached, the @(R0,Rn) mode can<br />be used instead.<br /><br /><br />",
      "operation": "void MOVBS4 (int d, int n)\n{\n  long disp = (0x0000000F &amp; (long)d);\n  Write_8 (R[n] + disp, R[0]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\tRm,@(disp12,Rn)",
      "abstract": "Rm -> (disp + Rn)",
      "code": "0011nnnnmmmm0001 0000dddddddddddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.  This<br />instruction is ideal for data access in a structure or the stack.<br /><br /><br />",
      "operation": "void MOVBS12 (int d, int m, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  Write_8 (R[n] + disp, R[m]);\n  PC += 4;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\tR0,@(disp,Rn)",
      "abstract": "R0 -> (disp*2 + Rn)",
      "code": "10000001nnnndddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The 4-bit displacement is multiplied by two after zero-extension, enabling a<br />range up to +30 bytes to be specified.  If a memory operand cannot be reached,<br />the @(R0,Rn) mode can be used instead.<br /><br /><br />",
      "operation": "void MOVWS4 (int d, int n)\n{\n  long disp = (0x0000000F &amp; (long)d);\n  Write_16 (R[n] + (disp &lt;&lt; 1), R[0]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\tRm,@(disp12,Rn)",
      "abstract": "Rm -> (disp*2 + Rn)",
      "code": "0011nnnnmmmm0001 0001dddddddddddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.  This<br />instruction is ideal for data access in a structure or the stack.<br /><br /><br />",
      "operation": "void MOVWS12 (int d, int m, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  Write_16 (R[n] + (disp &lt;&lt; 1), R[m]);\n  PC += 4;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\tRm,@(disp,Rn)",
      "abstract": "Rm -> (disp*4 + Rn)",
      "code": "0001nnnnmmmmdddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The 4-bit displacement is multiplied by four after zero-extension, enabling a<br />range up to +60 bytes to be specified.  If a memory operand cannot be reached,<br />the @(R0,Rn) mode can be used instead.<br /><br /><br />",
      "operation": "void MOVLS4 (int m, int d, int n)\n{\n  long disp = (0x0000000F &amp; (long)d);\n  Write_32 (R[n] + (disp &lt;&lt; 2), R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\tRm,@(disp12,Rn)",
      "abstract": "Rm -> (disp*4 + Rn)",
      "code": "0011nnnnmmmm0001 0010dddddddddddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.  This<br />instruction is ideal for data access in a structure or the stack.<br /><br /><br />",
      "operation": "void MOVLS12 (int d, int m, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  Write_32 (R[n] + (disp &lt;&lt; 2), R[m]);\n  PC += 4;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\t@(R0,Rm),Rn",
      "abstract": "(R0 + Rm) -> sign extension -> Rn",
      "code": "0000nnnnmmmm1100",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVBL0 (int m, int n)\n{\n  R[n] = Read_8 (R[m] + R[0]);\n\n  if ((R[n] &amp; 0x80) == 0)\n    R[n] &amp;= 0x000000FF;\n  else R[n] |= 0xFFFFFF00;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\t@(R0,Rm),Rn",
      "abstract": "(R0 + Rm) -> sign extension -> Rn",
      "code": "0000nnnnmmmm1101",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVWL0 (int m, int n)\n{\n  R[n] = Read_16 (R[m] + R[0]);\n\n  if ((R[n] &amp; 0x8000) == 0)\n    R[n] &amp;= 0x0000FFFF;\n  else\n    R[n] |= 0xFFFF0000;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\t@(R0,Rm),Rn",
      "abstract": "(R0 + Rm) -> Rn",
      "code": "0000nnnnmmmm1110",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVLL0 (int m, int n)\n{\n  R[n] = Read_32 (R[m] + R[0]);\n  PC += 2;\n}\n\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\tRm,@(R0,Rn)",
      "abstract": "Rm -> (R0 + Rn)",
      "code": "0000nnnnmmmm0100",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVBS0 (int m, int n)\n{\n  Write_8 (R[n] + R[0], R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\tRm,@(R0,Rn)",
      "abstract": "Rm -> (R0 + Rn)",
      "code": "0000nnnnmmmm0101",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVWS0 (int m, int n)\n{\n  Write_16 (R[n] + R[0], R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\tRm,@(R0,Rn)",
      "abstract": "Rm -> (R0 + Rn)",
      "code": "0000nnnnmmmm0110",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br /><br /><br />",
      "operation": "void MOVLS0 (int m, int n)\n{\n  Write_32 (R[n] + R[0], R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\t@(disp,GBR),R0",
      "abstract": "(disp + GBR) -> sign extension -> R0",
      "code": "11000100dddddddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The 8-bit displacement is only zero-extended, so a range up to +255 bytes can be<br />specified.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVBLG (int d)\n{\n  unsigned int disp = (0x000000FF &amp; d);\n  R[0] = Read_8 (GBR + disp);\n\n  if ((R[0] &amp; 0x80) == 0)\n    R[0] &amp;= 0x000000FF;\n  else\n    R[0] |= 0xFFFFFF00;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\t@(disp,GBR),R0",
      "abstract": "(disp*2 + GBR) -> sign extension -> R0",
      "code": "11000101dddddddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The 8-bit displacement is multiplied by two after zero-extension, enabling a<br />range up to +510 bytes to be specified.<br />The loaded data is sign-extended to 32 bit before being stored in the<br />destination register.<br /><br /><br />",
      "operation": "void MOVWLG (int d)\n{\n  unsigned int disp = (0x000000FF &amp; d);\n  R[0] = Read_16 (GBR + (disp &lt;&lt; 1));\n\n  if ((R[0] &amp; 0x8000) == 0)\n    R[0] &amp;= 0x0000FFFF;\n  else\n    R[0] |= 0xFFFF0000;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\t@(disp,GBR),R0",
      "abstract": "(disp*4 + GBR) -> R0",
      "code": "11000110dddddddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The 8-bit displacement is multiplied by four after zero-extension, enabling a<br />range up to +1020 bytes to be specified.<br /><br /><br />",
      "operation": "void MOVLLG (int d)\n{\n  unsigned int disp = (0x000000FF &amp; d);\n  R[0] = Read_32 (GBR + (disp &lt;&lt; 2));\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.b\tR0,@(disp,GBR)",
      "abstract": "R0 -> (disp + GBR)",
      "code": "11000000dddddddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The 8-bit displacement is only zero-extended, so a range up to +255 bytes can be<br />specified.<br /><br /><br />",
      "operation": "void MOVBSG (int d)\n{\n  unsigned int disp = (0x000000FF &amp; d);\n  Write_8 (GBR + disp, R[0]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.w\tR0,@(disp,GBR)",
      "abstract": "R0 -> (disp*2 + GBR)",
      "code": "11000001dddddddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The 8-bit displacement is multiplied by two after zero-extension, enabling a<br />range up to +510 bytes to be specified.<br /><br /><br />",
      "operation": "void MOVWSG (int d)\n{\n  unsigned int disp = (0x000000FF &amp; d);\n  Write_16 (GBR + (disp &lt;&lt; 1), R[0]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mov.l\tR0,@(disp,GBR)",
      "abstract": "R0 -> (disp*4 + GBR)",
      "code": "11000010dddddddd",
      "T": "-",
      "description": "Transfers the source operand to the destination.<br />The 8-bit displacement is multiplied by four after zero-extension, enabling a<br />range up to +1020 bytes to be specified.<br /><br /><br />",
      "operation": "void MOVLSG (int d)\n{\n  unsigned int disp = (0x000000FF &amp; (long)d);\n  Write_32 (GBR + (disp &lt;&lt; 2), R[0]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movco.l\tR0,@Rn",
      "abstract": "LDST -> T\nIf (T == 1): R0 -> Rn\n0 -> LDST",
      "code": "0000nnnn01110011",
      "T": "-",
      "description": "MOVCO is used in combination with MOVLI to realize an atomic read-modify-write<br />operation in a single processor.<br />This instruction copies the value of the LDST flag to the T bit. When the T bit<br />is set to 1, the value of R0 is stored at the address in Rm. If the T bit is<br />cleared to 0, the value is not stored at the address in Rm. Finally, the LDST<br />flag is cleared to 0. Since the LDST flag is cleared by an instruction or<br />exception, storage by the MOVCO instruction only proceeds when no interrupt or<br />exception has occurred between the execution of the MOVLI and MOVCO instructions.<br /><br /><br />",
      "operation": "void MOVCO (int n)\n{\n  T = LDST;\n  if (T == 1)\n    Write_32 (R[n], R[0]);\n\n  LDST = 0;\n  PC += 2\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movli.l\t@Rm,R0",
      "abstract": "1 -> LDST\n(Rm) -> R0\nWhen interrupt/exception occured: 0 -> LDST",
      "code": "0000mmmm01100011",
      "T": "-",
      "description": "MOVLI is used in combination with MOVCO to realize an atomic read-modify-write<br />operation in a single processor.<br />This instruction sets the LDST flag to 1 and reads the four bytes of data<br />indicated by Rm into R0. If, however, an interrupt or exception occurs, LDST is<br />cleared to 0. Storage by the MOVCO instruction only proceeds when the<br />instruction is executed after the LDST bit has been set by the MOVLI instruction<br />and not cleared by an interrupt or other exception.  When LDST has been cleared<br />to 0, the MOVCO instruction clears the T bit and does not proceed with storage.<br /><br /><br />",
      "operation": "void MOVLINK (int m)\n{\n  LDST = 1;\n  R[0] = Read_32 (R[m]);\n  PC += 2\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 2,
      "SH4A.latency": 2,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movua.l\t@Rm,R0",
      "abstract": "(Rm) -> R0\nLoad non-boundary alignment data",
      "code": "0100mmmm10101001",
      "T": "-",
      "description": "Loads the longword of data from the effective address indicated<br />by the contents of Rm in memory to R0. The address is not restricted to longword<br />boundaries address (4n).  This instruction allows loading from<br />non-longword-boundary addresses (4n + 1, 4n + 2, and 4n + 3). Data address error<br />exceptions do not occur when access is to non-longword-boundary addresses<br />(4n + 1, 4n + 2, and 4n + 3).<br /><br /><br />",
      "operation": "void MOVUAL (int m)\n{\n  Read_Unaligned_32 (R0, R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 2,
      "SH4A.latency": 2,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movua.l\t@Rm+,R0",
      "abstract": "(Rm) -> R0, Rm + 4 -> Rm\nLoad non-boundary alignment data",
      "code": "0100mmmm11101001",
      "T": "-",
      "description": "Loads the longword of data from the effective address indicated<br />by the contents of Rm in memory to R0. The address is not restricted to longword<br />boundaries address (4n).  This instruction allows loading from<br />non-longword-boundary addresses (4n + 1, 4n + 2, and 4n + 3). Data address error<br />exceptions do not occur when access is to non-longword-boundary addresses<br />(4n + 1, 4n + 2, and 4n + 3).<br /><br /><br />",
      "operation": "void MOVUALP (int m)\n{\n  Read_Unaligned_32 (R0,R[m]);\n\n  if (m != 0)\n    R[m] += 4;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movml.l\tRm,@-R15",
      "abstract": "R15-4 -> R15, Rm -> (R15)\nR15-4 -> R15, Rm-1 -> (R15)\n...\n...\nR15 - 4 -> R15, R0 -> (R15)\nNote: When Rm = R15, read Rm as PR",
      "code": "0100mmmm11110001",
      "T": "-",
      "description": "Transfers a source operand to a destination. This instruction performs transfer<br />between a number of general registers (R0 to Rn/Rm) not exceeding the specified<br />register number and memory with the contents of R15 as its address.<br /><br />If R15 is specified, PR is transferred instead of R15. That is, when<br />nnnn(mmmm) = 1111 is specified, R0 to R14 and PR are the general registers<br />subject to transfer.<br /><br /><br />",
      "operation": "void MOVLMML (int m)\n{\n  for (int i = m; i &gt;= 0; i--)\n  {\n    if (i == 15)\n      Write_32 (R[15] - 4, PR);\n    else\n      Write_32 (R[15] - 4, R[i]);\n\n    R[15] -= 4;\n  }\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movml.l\t@R15+,Rn",
      "abstract": "(R15) -> R0, R15+4 -> R15\n(R15) -> R1, R15+4 -> R15\n...\n...\n(R15) -> Rn\nNote: When Rn = R15, read Rn as PR",
      "code": "0100nnnn11110101",
      "T": "-",
      "description": "Transfers a source operand to a destination. This instruction performs transfer<br />between a number of general registers (R0 to Rn/Rm) not exceeding the specified<br />register number and memory with the contents of R15 as its address.<br /><br />If R15 is specified, PR is transferred instead of R15. That is, when<br />nnnn(mmmm) = 1111 is specified, R0 to R14 and PR are the general registers<br />subject to transfer.<br /><br /><br />",
      "operation": "void MOVLPML (int n)\n{\n  for (int i = 0; i <= n; i++)\n  {\n    if (i == 15)\n     PR = Read_32 (R[15]);\n    else\n     R[i] = Read_32 (R[15]);\n\n    R[15]+=4;\n  }\n\n  PC += 2;\n}"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movmu.l\tRm,@-R15",
      "abstract": "R15-4 -> R15, PR -> (R15)\nR15-4 -> R15, R14 -> (R15)\n...\n...\nR15-4 -> R15, Rm -> (R15)\nNote: When Rm = R15, read Rm as PR",
      "code": "0100mmmm11110000",
      "T": "-",
      "description": "Transfers a source operand to a destination. This instruction performs transfer<br />between a number of general registers (Rn/Rm to R14, PR) not lower than the<br />specified register number and memory with the contents of R15 as its address.<br /><br />If R15 is specified, PR is transferred instead of R15.<br /><br /><br />",
      "operation": "void MOVLMMU (int m)\n{\n  Write_32 (R[15] - 4, PR);\n  R[15] -= 4;\n\n  for (int i = 14; i &gt;= m; i--)\n  {\n    Write_32 (R[15] - 4, R[i]);\n    R[15] -= 4;\n  }\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movmu.l\t@R15+,Rn",
      "abstract": "(R15) -> Rn, R15+4 -> R15\n(R15) -> Rn+1, R15+4 -> R15\n...\n...\n(R15) -> R14, R15+4 -> R15\n(R15) -> PR\nNote: When Rn = R15, read Rn as PR",
      "code": "0100nnnn11110100",
      "T": "-",
      "description": "Transfers a source operand to a destination. This instruction performs transfer<br />between a number of general registers (Rn/Rm to R14, PR) not lower than the<br />specified register number and memory with the contents of R15 as its address.<br /><br />If R15 is specified, PR is transferred instead of R15.<br /><br /><br />",
      "operation": "void MOVLPMU (int n)\n{\n  for (int i = n; i <= 14; i++)\n  {\n    R[i] = Read_32 (R[15]);\n    R[15] += 4;\n  }\n\n  PR = Read_32 (R[15]);\n  R[15] += 4;\n  PC += 2;\n}"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movrt\tRn",
      "abstract": "~T -> Rn",
      "code": "0000nnnn00111001",
      "T": "-",
      "description": "Reverses the T bit and then stores the resulting value in general register Rn.<br />The value of Rn is 0 when T = 1 and 1 when T = 0.<br /><br /><br />",
      "operation": "void MOVRT (int n)\n{\n  if (T == 1)\n    R[n] = 0x00000000;\n  else\n    R[n] = 0x00000001;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movt\tRn",
      "abstract": "T -> Rn",
      "code": "0000nnnn00101001",
      "T": "-",
      "description": "Stores the T bit in general register Rn.<br />The value of Rn is 1 when T = 1 and 0 when T = 0.<br /><br /><br />",
      "operation": "void MOVT (int n)\n{\n  if (T == 1)\n    R[n] = 0x00000001;\n  else\n    R[n] = 0x00000000;\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "nott",
      "abstract": "~T -> T",
      "code": "0000000001101000",
      "T": "-",
      "description": "Inverts the T bit, then stores the resulting value in the T bit.<br /><br /><br />",
      "operation": "void NOTT (void)\n{\n  if (T == 1)\n    T = 0;\n  else\n    T = 1;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "swap.b\tRm,Rn",
      "abstract": "Rm -> swap lower 2 bytes -> Rn",
      "code": "0110nnnnmmmm1000",
      "T": "-",
      "description": "Swaps the upper and lower parts of the contents of general register Rm and<br />stores the result in Rn.<br />The 8 bits from bit 15 to bit 8 of Rm are swapped with the 8 bits from bit 7 to<br />bit 0. The upper 16 bits of Rm are transferred directly to the upper 16 bits of<br />Rn.<br /><br /><br />",
      "operation": "void SWAPB (int m, int n)\n{\n  unsigned long temp0, temp1;\n  temp0 = R[m] &amp; 0xFFFF0000;\n  temp1 = (R[m] &amp; 0x000000FF) &lt;&lt; 8;\n  R[n] = (R[m] &amp; 0x0000FF00) &gt;&gt; 8;\n  R[n] = R[n] | temp1 | temp0;\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "swap.w\tRm,Rn",
      "abstract": "Rm -> swap upper/lower words -> Rn",
      "code": "0110nnnnmmmm1001",
      "T": "-",
      "description": "Swaps the upper and lower parts of the contents of general register Rm and<br />stores the result in Rn.<br />The 16 bits from bit 31 to bit 16 of Rm are swapped with the 16 bits from bit<br />15 to bit 0.<br /><br /><br />",
      "operation": "void SWAPW (int m, int n)\n{\n  unsigned long temp;\n  temp = (R[m] &gt;&gt; 16) &amp; 0x0000FFFF;\n  R[n] = R[m] &lt;&lt; 16;\n  R[n] |= temp;\n  PC += 2;\n}\n"
    },
    {
      "group": "Data Transfer Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "xtrct\tRm,Rn",
      "abstract": "Rm:Rn middle 32 bits -> Rn",
      "code": "0010nnnnmmmm1101",
      "T": "-",
      "description": "Extracts the middle 32 bits from the 64-bit contents of linked general registers<br />Rm and Rn, and stores the result in Rn.<br /><br /><br /><br />",
      "operation": "void XTRCT (int m, int n)\n{\n  unsigned long high = (R[m] &lt;&lt; 16) &amp; 0xFFFF0000;\n  unsigned long low = (R[n] &gt;&gt; 16) &amp; 0x0000FFFF;\n  R[n] = high | low;\n  PC += 2;\n}\n"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "band.b     #imm3,@disp12,Rn",
      "abstract": "(imm of (disp+Rn)) & T -> T",
      "code": "0011nnnn0iii1001 0100dddddddddddd",
      "T": "result",
      "description": "ANDs a specified bit in memory at the address indicated by (disp + Rn) with the<br />T bit, and stores the result in the T bit. The bit number is specified by 3-bit<br />immediate data. With this instruction, data is read from memory as a byte unit.<br /><br /><br />",
      "operation": "void BANDM (int d, int i, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  long imm = (0x00000007 &amp; (long)i);\n  long temp = Read_8 (R[n] + disp);\n  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;\n\n  if ((T == 0) || (assignbit == 0))\n    T = 0;\n  else\n    T = 1;\n\n  PC += 4;\n}\n"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bandnot.b  #imm3,@(disp12,Rn)",
      "abstract": "~(imm of (disp+Rn)) & T -> T",
      "code": "0011nnnn0iii1001 1100dddddddddddd",
      "T": "result",
      "description": "ANDs the value obtained by inverting a specified bit of memory at the address<br />indicated by (disp + Rn) with the T bit, and stores the result in the T bit.<br />The bit number is specified by 3-bit immediate data. With this instruction, data<br />is read from memory as a byte unit.<br /><br /><br />",
      "operation": "void BANDNOTM (int d, int i, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  long imm = (0x00000007 &amp; (long)i);\n  long temp = Read_8 (R[n] + disp);\n  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;\n\n  if ((T == 1) &amp;&amp; (assignbit == 0))\n    T = 1;\n  else\n    T = 0;\n\n  PC += 4;\n}\n"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bclr.b     #imm3,@(disp12,Rn)",
      "abstract": "0 -> (imm of (disp+Rn))",
      "code": "0011nnnn0iii1001 0000dddddddddddd",
      "T": "-",
      "description": "Clears a specified bit of memory at the address indicated by (disp + Rn).<br />The bit number is specified by 3-bit immediate data. After data is read from<br />memory as a byte unit, clearing of the specified bit is executed and the<br />resulting data is then written to memory as a byte unit.<br /><br /><br />",
      "operation": "void BCLRM (int d, int i, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  long imm = (0x00000007 &amp; (long)i);\n  long temp = Read_8 (R[n] + disp);\n  temp &amp;= (~(0x00000001 &lt;< imm));\n  Write_8 (R[n] + disp, temp);\n  PC += 4;\n}"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bclr       #imm3,Rn",
      "abstract": "0 -> imm of Rn",
      "code": "10000110nnnn0iii",
      "T": "-",
      "description": "Clears a specified bit of the LSB 8 bits of a general register Rn.<br />The bit number is specified by 3-bit immediate data.<br /><br /><br />",
      "operation": "void CLR (int i, int n)\n{\n  long imm, temp;\n  imm = (0x00000007 &amp; (long)i);\n  R[n] &amp;= (~(0x00000001 &lt;&lt; imm));\n  PC += 2;\n}\n"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bld.b      #imm3,@(disp12,Rn)",
      "abstract": "(imm of (disp+Rn)) -> T",
      "code": "0011nnnn0iii1001 0011dddddddddddd",
      "T": "result",
      "description": "Stores a specified bit of memory at the address indicated by (disp + Rn) in the<br />T bit. The bit number is specified by 3-bit immediate data. Data is read from<br />memory as a byte unit.<br /><br /><br />",
      "operation": "void BLDM (int d, int i, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  long imm = (0x00000007 &amp; (long)i);\n  long temp = Read_8 (R[n] + disp);\n  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;\n\n  if (assignbit == 0)\n    T = 0;\n  else\n    T = 1;\n\n  PC += 4;\n}\n"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bld        #imm3,Rn",
      "abstract": "imm of Rn -> T",
      "code": "10000111nnnn1iii",
      "T": "result",
      "description": "Stores a specified bit of the LSB 8 bits of a general register Rn in the T bit.<br />The bit number is specified by 3-bit immediate data.<br /><br /><br />",
      "operation": "void BLD (int i, int n)\n{\n  long imm, assignbit;\n  imm = (0x00000007 &amp; (long)i);\n  assignbit = (0x00000001 &lt;&lt; imm) &amp; R[n];\n\n  if (assignbit == 0)\n    T = 0;\n  else\n    T = 1;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bldnot.b   #imm3,@(disp12,Rn)",
      "abstract": "~(imm of (disp+Rn)) -> T",
      "code": "0011nnnn0iii1001 1011dddddddddddd",
      "T": "result",
      "description": "Inverts a specified bit of memory at the address indicated by (disp + Rn), and<br />stores the resulting value in the T bit. The bit number is specified by 3-bit<br />immediate data. Data is read from memory as a byte unit.<br /><br /><br />",
      "operation": "void BLDNOTM (int d, int i, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  long imm = (0x00000007 &amp; (long)i);\n  long temp = Read_8 (R[n] + disp);\n  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;\n\n  if (assignbit == 0)\n    T = 1;\n  else\n    T = 0;\n\n  PC += 4;\n}\n"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bor.b      #imm3,@(disp12,Rn)",
      "abstract": "(imm of (disp+Rn)) | T -> T",
      "code": "0011nnnn0iii1001 0101dddddddddddd",
      "T": "result",
      "description": "ORs a specified bit in memory at the address indicated by (disp + Rn) with the<br />T bit, and stores the result in the T bit. The bit number is specified by 3-bit<br />immediate data. Data is read from memory as a byte unit.<br /><br /><br />",
      "operation": "void BORM (int d, int i, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  long imm = (0x00000007 &amp; (long)i);\n  long temp = Read_8 (R[n] + disp);\n  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;\n\n  if ((T == 0) &amp;&amp; (assignbit == 0))\n    T = 0;\n  else\n    T = 1;\n\n  PC += 4;\n}\n"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bornot.b   #imm3,@(disp12,Rn)",
      "abstract": "~(imm of (disp+Rn)) | T -> T",
      "code": "0011nnnn0iii1001 1101dddddddddddd",
      "T": "result",
      "description": "ORs the value obtained by inverting a specified bit of memory at the address<br />indicated by (disp + Rn) with the T bit, and stores the result in the T bit.<br />The bit number is specified by 3-bit immediate data. With this instruction,<br />data is read from memory as a byte unit.<br /><br /><br />",
      "operation": "void BORNOTM (int d, int i, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  long imm = (0x00000007 &amp; (long)i);\n  long temp = Read_8 (R[n] + disp);\n  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;\n\n  if ((T == 1) || (assignbit == 0))\n    T = 1;\n  else\n    T = 0;\n\n  PC += 4;\n}\n"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bset.b     #imm3,@(disp12,Rn)",
      "abstract": "1 -> (imm of (disp+Rn))",
      "code": "0011nnnn0iii1001 0001dddddddddddd",
      "T": "-",
      "description": "Sets to 1 a specified bit of memory at the address indicated by (disp + Rn).<br />The bit number is specified by 3-bit immediate data. After data is read from<br />memory as a byte unit, the specified bit is set to 1, and the resulting data is<br />then written to memory as a byte unit.<br /><br /><br />",
      "operation": "void BSETM (int d, int i, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  long imm = (0x00000007 &amp; (long)i);\n  long temp = Read_8 (R[n] + disp);\n  temp |= (0x00000001 &lt;&lt; imm);\n  Write_8 (R[n] + disp, temp);\n  PC += 4;\n}\n"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bset       #imm3,Rn",
      "abstract": "1 -> imm of Rn",
      "code": "10000110nnnn1iii",
      "T": "-",
      "description": "Sets to 1 a specified bit of the LSB 8 bits of a general register Rn. The bit<br />number is specified by 3-bit immediate data.<br /><br /><br />",
      "operation": "void BSET (int i, int n)\n{\n  long imm, temp;\n  imm = (0x00000007 &amp; (long)i);\n  R[n] |= (0x00000001 &lt;&lt; imm);\n  PC += 2;\n}\n"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bst.b      #imm3,@(disp12,Rn)",
      "abstract": "T -> (imm of (disp+Rn))",
      "code": "0011nnnn0iii1001 0010dddddddddddd",
      "T": "-",
      "description": "Transfers the contents of the T bit to a specified 1-bit location of memory at<br />the address indicated by (disp + Rn). The bit number is specified by 3-bit<br />immediate data. After data is read from memory as a byte unit, transfer from the<br />T bit to the specified bit is executed, and the resulting data is then written<br />to memory as a byte unit.<br /><br /><br />",
      "operation": "void BSTM (int d, int i, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  long imm = (0x00000007 &amp; (long)i);\n  long temp = Read_8 (R[n] + disp);\n\n  if (T == 0)\n    temp &amp;= (~(0x00000001 &lt;&lt; imm));\n  else\n    temp |= (0x00000001 &lt;&lt; imm);\n\n  Write_8 (R[n] + disp, temp);\n  PC += 4;\n}\n"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bst        #imm3,Rn",
      "abstract": "T -> imm of Rn",
      "code": "10000111nnnn0iii",
      "T": "-",
      "description": "Transfers the contents of the T bit to a specified 1-bit location of the<br />LSB 8 bits of a general register Rn. The bit number is specified by 3-bit<br />immediate data.<br /><br /><br />",
      "operation": "void BST (int i, int n)\n{\n  long disp, imm;\n  disp = (0x00000FFF &amp; (long)d);\n  imm = (0x00000007 &amp; (long)i);\n\n  if (T == 0)\n    R[n] &amp;= (~(0x00000001 &lt;&lt; imm));\n  else\n    R[n] |= (0x00000001 &lt;&lt; imm);\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Bit Manipulation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bxor.b     #imm3,@(disp12,Rn)",
      "abstract": "(imm of (disp+Rn)) ^ T -> T",
      "code": "0011nnnn0iii1001 0110dddddddddddd",
      "T": "result",
      "description": "Exclusive-ORs a specified bit in memory at the address indicated by (disp + Rn)<br />with the T bit, and stores the result in the T bit. The bit number is specified<br />by 3-bit immediate data. With this instruction, data is read from memory as a<br />byte unit.<br /><br /><br />",
      "operation": "void BXORM (int d, int i, int n)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  long imm = (0x00000007 &amp; (long)i);\n  long temp = Read_8 (R[n] + disp);\n  long assignbit = (0x00000001 &lt;&lt; imm) &amp; temp;\n\n  if (assignbit == 0)\n  {\n    if (T == 0)\n      T = 0;\n    else\n      T = 1;\n  }\n  else\n  {\n    if (T == 0)\n      T = 1;\n    else\n      T = 0;\n  }\n\n  PC += 4;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "add\tRm,Rn",
      "abstract": "Rn + Rm -> Rn",
      "code": "0011nnnnmmmm1100",
      "T": "-",
      "description": "Adds together the contents of general registers Rn and Rm and stores the<br />result in Rn.<br /><br /><br />",
      "operation": "void ADD (int m, int n)\n{\n  R[n] += R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "add\t#imm,Rn",
      "abstract": "Rn + (sign extension)imm",
      "code": "0111nnnniiiiiiii",
      "T": "-",
      "description": "Adds together the contents of general register Rn and the immediate value<br />and stores the result in Rn.  The 8-bit immediate value is sign-extended to<br />32 bits, which allows it to be used for immediate subtraction or decrement<br />operations.<br /><br /><br />",
      "operation": "void ADDI (int i, int n)\n{\n  if ((i &amp; 0x80) == 0)\n    R[n] += (0x000000FF &amp; (long)i);\n  else\n    R[n] += (0xFFFFFF00 | (long)i);\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "addc\tRm,Rn",
      "abstract": "Rn + Rm + T -> Rn, carry -> T",
      "code": "0011nnnnmmmm1110",
      "T": "carry",
      "description": "Adds together the contents of general registers Rn and Rm and the T bit, and<br />stores the result in Rn.  A carry resulting from the operation is reflected in<br />the T bit.  This instruction can be used to implement additions exceeding 32<br />bits.<br /><br /><br /><br />",
      "operation": "void ADDC (int m, int n)\n{\n  unsigned long tmp0, tmp1;\n  tmp1 = R[n] + R[m];\n  tmp0 = R[n];\n  R[n] = tmp1 + T;\n\n  if (tmp0&gt;tmp1)\n    T = 1;\n  else\n    T = 0;\n\n  if (tmp1 &gt; R[n])\n    T = 1;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "addv\tRm,Rn",
      "abstract": "Rn + Rm -> Rn, overflow -> T",
      "code": "0011nnnnmmmm1111",
      "T": "overflow",
      "description": "Adds together the contents of general registers Rn and Rm and stores the result<br />in Rn.  If overflow occurs, the T bit is set.<br /><br /><br /><br />",
      "operation": "void ADDV (int m, int n)\n{\n  long dest, src, ans;\n\n  if ((long)R[n] &gt;= 0)\n    dest = 0;\n  else\n    dest = 1;\n\n  if ((long)R[m] &gt;= 0)\n    src = 0;\n  else\n    src = 1;\n\n  src += dest;\n  R[n] += R[m];\n\n  if ((long)R[n] &gt;= 0)\n    ans = 0;\n  else\n    ans = 1;\n\n  ans += dest;\n\n  if (src == 0 || src == 2)\n  {\n    if (ans == 1)\n      T = 1;\n    else\n      T = 0;\n  }\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "cmp/eq\t#imm,R0",
      "abstract": "If R0 = (sign extension)imm: 1 -> T\nElse: 0 -> T",
      "code": "10001000iiiiiiii",
      "T": "result",
      "description": "Compares general register R0 and the sign-extended 8-bit immediate data and sets<br />the T bit if the values are equal.  If they are not equal the T bit is cleared.<br />The contents of R0 are not changed.<br /><br /><br />",
      "operation": "void CMPIM (int i)\n{\n  long imm;\n\n  if ((i &amp; 0x80) == 0)\n    imm = (0x000000FF &amp; (long i));\n  else\n    imm = (0xFFFFFF00 | (long i));\n\n  if (R[0] == imm)\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "cmp/eq\tRm,Rn",
      "abstract": "If Rn = Rm: 1 -> T\nElse: 0 -> T",
      "code": "0011nnnnmmmm0000",
      "T": "result",
      "description": "Compares general registers Rn and Rm, and sets the T bit if they are equal.<br />The contents of Rn and Rm are not changed.<br /><br /><br />",
      "operation": "void CMPEQ (int m, int n)\n{\n  if (R[n] == R[m])\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "cmp/hs\tRm,Rn",
      "abstract": "If Rn >= Rm (unsigned): 1 -> T\nElse: 0 -> T",
      "code": "0011nnnnmmmm0010",
      "T": "result",
      "description": "Compares general registers Rn and Rm, and sets the T bit if Rn is greater or<br />equal Rm.  The values for the comparison are interpreted as unsigned integer<br />values.  The contents of Rn and Rm are not changed.<br /><br /><br />",
      "operation": "void CMPHI (int m, int n)\n{\n  if ((unsigned long)R[n] &gt;= (unsigned long)R[m])\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "cmp/ge\tRm,Rn",
      "abstract": "If Rn >= Rm (signed): 1 -> T\nElse: 0 -> T",
      "code": "0011nnnnmmmm0011",
      "T": "result",
      "description": "Compares general registers Rn and Rm, and sets the T bit if Rn is greater or<br />equal Rm.  The values for the comparison are interpreted as signed integer<br />values.  The contents of Rn and Rm are not changed.<br /><br /><br />",
      "operation": "void CMPGE (int m, int n)\n{\n  if ((long)R[n] &gt;= (long)R[m])\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "cmp/hi\tRm,Rn",
      "abstract": "If Rn > Rm (unsigned): 1 -> T\nElse: 0 -> T",
      "code": "0011nnnnmmmm0110",
      "T": "result",
      "description": "Compares general registers Rn and Rm, and sets the T bit if Rn is greater Rm.<br />The values for the comparison are interpreted as unsigned integer values.<br />The contents of Rn and Rm are not changed.<br /><br /><br />",
      "operation": "void CMPHI (int m, int n)\n{\n  if ((unsigned long)R[n] &gt; (unsigned long)R[m])\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "cmp/gt\tRm,Rn",
      "abstract": "If Rn > Rm (signed): 1 -> T\nElse: 0 -> T",
      "code": "0011nnnnmmmm0111",
      "T": "result",
      "description": "Compares general registers Rn and Rm, and sets the T bit if Rn is greater Rm.<br />The values for the comparison are interpreted as signed integer values.<br />The contents of Rn and Rm are not changed.<br /><br /><br />",
      "operation": "void CMPGT (int m, int n)\n{\n  if ((long)R[n] &gt; (long)R[m])\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "cmp/pl\tRn",
      "abstract": "If Rn > 0 (signed): 1 -> T\nElse: 0 -> T",
      "code": "0100nnnn00010101",
      "T": "result",
      "description": "Compares general register Rn and sets the T bit if Rn is greater 0.  The value<br />in Rn for the comparison is interpreted as signed integer.  The contents of Rn<br />are not changed.<br /><br /><br />",
      "operation": "void CMPPL (int n)\n{\n  if ((long)R[n] &gt; 0)\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "cmp/pz\tRn",
      "abstract": "If Rn >= 0 (signed): 1 -> T\nElse: 0 -> T",
      "code": "0100nnnn00010001",
      "T": "result",
      "description": "Compares general register Rn and sets the T bit if Rn is greater or equal 0.<br />The value in Rn for the comparison is interpreted as signed integer.  The<br />contents of Rn are not changed.<br /><br /><br />",
      "operation": "void CMPPZ (int n)\n{\n  if ((long)R[n] &gt;= 0)\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "cmp/str\tRm,Rn",
      "abstract": "If Rn and Rm have an equal byte: 1 -> T\nElse: 0 -> T",
      "code": "0010nnnnmmmm1100",
      "T": "result",
      "description": "Compares general registers Rn and Rm, and sets the T bit if any of the 4 bytes<br />in Rn are equal to the corresponding byte in Rm. The contents of Rn and Rm are<br />not changed.<br /><br /><br />NoteThis instruction can be used to speed up some string operations such as<br />finding the string length of a zero terminated string or string matching.<br /><br /><br />",
      "operation": "void CMPSTR (int m, int n)\n{\n  unsigned long temp;\n  long HH, HL, LH, LL;\n  temp = R[n] ^ R[m];\n  HH = (temp &amp; 0xFF000000) &gt;&gt; 24;\n  HL = (temp &amp; 0x00FF0000) &gt;&gt; 16;\n  LH = (temp &amp; 0x0000FF00) &gt;&gt; 8;\n  LL = temp &amp; 0x000000FF;\n  HH = HH &amp;&amp; HL &amp;&amp; LH &amp;&amp; LL;\n\n  if (HH == 0)\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "clips.b\tRn",
      "abstract": "If Rn > 0x0000007F: 0x0000007F -> Rn, 1 -> CS\nIf Rn < 0xFFFFFF80: 0xFFFFFF80 -> Rn, 1 -> CS",
      "code": "0100nnnn10010001",
      "T": "-",
      "description": "Determines saturation. Signed data is used with this instruction. The saturation<br />upper-limit value is stored in general register Rn if the contents of Rn exceed<br />the saturation upper-limit value, or the saturation lower-limit value is stored<br />in Rn if the contents of Rn are less than the saturation lower-limit value, and<br />the CS bit is set to 1.<br />The saturation upper-limit value is 0x0000007F (127).<br />The saturation lower-limit value is 0xFFFFFF80 (-128).<br /><br /><br />NoteThe CS bit value does not change if the contents of general register Rn do not<br />exceed the saturation upper-limit value or are not less than the saturation<br />lower-limit value.<br /><br /><br />",
      "operation": "void CLIPSB (int n)\n{\n  if (R[n] &gt; 0x0000007F)\n  {\n    R[n] = 0x0000007F;\n    CS = 1;\n  }\n  else if (R[n] &lt; 0xFFFFFF80)\n  {\n    R[n] = 0xFFFFFF80;\n    CS = 1;\n  }\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "clips.w\tRn",
      "abstract": "If Rn > 0x00007FFF: 0x00007FFF -> Rn, 1 -> CS\nIf Rn < 0xFFFF8000: 0xFFFF8000 -> Rn, 1 -> CS",
      "code": "0100nnnn10010101",
      "T": "-",
      "description": "Determines saturation. Signed data is used with this instruction. The saturation<br />upper-limit value is stored in general register Rn if the contents of Rn exceed<br />the saturation upper-limit value, or the saturation lower-limit value is stored<br />in Rn if the contents of Rn are less than the saturation lower-limit value, and<br />the CS bit is set to 1.<br />The saturation upper-limit value is 0x00007FFF (32767).<br />The saturation lower-limit value is 0xFFFF8000 (-32768).<br /><br /><br />NoteThe CS bit value does not change if the contents of general register Rn do not<br />exceed the saturation upper-limit value or are not less than the saturation<br />lower-limit value.<br /><br /><br />",
      "operation": "void CLIPSW (int n)\n{\n  if (R[n] &gt; 0x00007FFF)\n  {\n    R[n] = 0x00007FFF;\n    CS = 1;\n  }\n  else if (R[n] &lt; 0xFFFF8000)\n  {\n    R[n] = 0xFFFF8000;\n    CS = 1;\n  }\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "clipu.b\tRn",
      "abstract": "If Rn > 0x000000FF: 0x000000FF -> Rn, 1 -> CS",
      "code": "0100nnnn10000001",
      "T": "-",
      "description": "Determines saturation. Unsigned data is used with this instruction. If the<br />contents of general register Rn exceed the saturation value, the saturation<br />value is stored in Rn and the CS bit is set to 1.<br />The saturation value is 0x000000FF (255).<br /><br /><br />NoteThe CS bit value does not change if the contents of general register Rn do not<br />exceed the saturation upper-limit value.<br /><br /><br />",
      "operation": "void CLIPUB (int n)\n{\n  if (R[n] &gt; 0x000000FF)\n  {\n    R[n] = 0x000000FF;\n    CS = 1;\n  }\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "clipu.w\tRn",
      "abstract": "If Rn > 0x0000FFFF: 0x0000FFFF -> Rn, 1 -> CS",
      "code": "0100nnnn10000101",
      "T": "-",
      "description": "Determines saturation. Unsigned data is used with this instruction. If the<br />contents of general register Rn exceed the saturation value, the saturation<br />value is stored in Rn and the CS bit is set to 1.<br />The saturation value is 0x0000FFFF (65535).<br /><br /><br />NoteThe CS bit value does not change if the contents of general register Rn do not<br />exceed the saturation upper-limit value.<br /><br /><br />",
      "operation": "void CLIPUW (int n)\n{\n  if (R[n] &gt; 0x0000FFFF)\n  {\n    R[n] = 0x0000FFFF;\n    CS = 1;\n  }\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "div0s\tRm,Rn",
      "abstract": "MSB of Rn -> Q, MSB of Rm -> M, M ^ Q -> T",
      "code": "0010nnnnmmmm0111",
      "T": "result",
      "description": "Performs initial settings for signed division. This instruction is followed by<br />a DIV1 instruction that executes 1-digit division, for example, and repeated<br />division steps are executed to find the quotient. See the description of the<br />DIV1 instruction for details.<br /><br /><br />NoteThis instruction can also be used to compare the signs of Rm and Rn.  If the<br />signs of Rm and Rn are equal, T will be set to 0.  If the signs of Rm and Rn<br />are not equal, T will be set to 1.<br /><br /><br />",
      "operation": "void DIV0S (int m, int n)\n{\n  if ((R[n] &amp; 0x80000000) == 0)\n    Q = 0;\n  else\n    Q = 1;\n\n  if ((R[m] &amp; 0x80000000) == 0)\n    M = 0;\n  else\n    M = 1;\n\n  T = ! (M == Q);\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "div0u",
      "abstract": "0 -> M, 0 -> Q, 0 -> T",
      "code": "0000000000011001",
      "T": "0",
      "description": "Performs initial settings for unsigned division. This instruction is followed by<br />a DIV1 instruction that executes 1-digit division, for example, and repeated<br />division steps are executed to find the quotient. See the description of the<br />DIV1 instruction for details.<br /><br /><br />",
      "operation": "void DIV0U (void)\n{\n  M = Q = T = 0;\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "div1\tRm,Rn",
      "abstract": "1-step division (Rn / Rm)",
      "code": "0011nnnnmmmm0100",
      "T": "result",
      "description": "Performs 1-digit division (1-step division) of the 32-bit contents of general<br />register Rn (dividend) by the contents of Rm (divisor).<br />The quotient is obtained by repeated execution of this instruction alone or in<br />combination with other instructions. The specified registers and the M, Q, and<br />T bits must not be modified during these repeated executions.<br /><br />In 1-step division, the dividend is shifted 1 bit to the left, the divisor is<br />subtracted from this, and the quotient bit is reflected in the Q bit according<br />to whether the result is positive or negative.<br /><br />Detection of division by zero or overflow is not provided. Check for division by<br />zero and overflow division before executing the division. A remainder operation<br />is not provided. Find the remainder by finding the product of the divisor and<br />the obtained quotient, and subtracting this value from the dividend:<br /><br />remainder = dividend - (divisor * quotient)<br /><br />Initial settings should first be made with the DIV0S or DIV0U instruction. DIV1<br />is executed once for each bit of the divisor. If a quotient of more than 17<br />bits is required, place an ROTCL instruction before the DIV1 instruction. See<br />the examples for details of the division sequence.<br /><br /><br />",
      "operation": "void DIV1 (int m, int n)\n{\n  unsigned long tmp0, tmp2;\n  unsigned char old_q, tmp1;\n\n  old_q = Q;\n  Q = (0x80000000 &amp; R[n]) != 0;\n  tmp2 = R[m];\n  R[n] <<= 1;\n  R[n] |= (unsigned long)T;\n\n  if (old_q == 0)\n  {\n    if (M == 0)\n    {\n      tmp0 = R[n];\n      R[n] -= tmp2;\n      tmp1 = R[n] > tmp0;\n\n      if (Q == 0)\n        Q = tmp1;\n      else if (Q == 1)\n        Q = tmp1 == 0;\n    }\n\n    else if (M == 1)\n    {\n      tmp0 = R[n];\n      R[n] += tmp2;\n      tmp1 = R[n] < tmp0;\n\n      if (Q == 0)\n        Q = tmp1 == 0;\n      else if (Q == 1)\n        Q = tmp1;\n    }\n  }\n\n  else if (old_q == 1)\n  {\n    if (M == 0)\n    {\n      tmp0 = R[n];\n      R[n] += tmp2;\n      tmp1 = R[n] < tmp0;\n\n      if (Q == 0)\n        Q = tmp1;\n      else if (Q == 1)\n        Q = tmp1 == 0;\n    }\n\n    else if (M == 1)\n    {\n       tmp0 = R[n];\n       R[n] -= tmp2;\n       tmp1 = R[n] > tmp0;\n\n       if (Q == 0)\n         Q = tmp1 == 0;\n       else if (Q == 1)\n         Q = tmp1;\n    }\n  }\n\n  T = (Q == M);\n  PC += 2;\n}"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "divs\tR0,Rn",
      "abstract": "Signed, Rn / R0 -> Rn\n32 / 32 -> 32 bits",
      "code": "0100nnnn10010100",
      "T": "-",
      "description": "Executes division of the 32-bit contents of a general register Rn (dividend) by<br />the contents of R0 (divisor). This instruction executes signed division and<br />finds the quotient only. A remainder operation is not provided. To obtain the<br />remainder, find the product of the divisor and the obtained quotient, and<br />subtract this value from the dividend. The sign of the remainder will be the<br />same as that of the dividend.<br /><br /><br />NoteAn overflow exception will occur if the negative maximum value (0x00000000) is<br />divided by -1. If division by zero is performed a division by zero exception<br />will occur.<br /><br />If an interrupt is generated while this instruction is being executed, execution<br />will be halted. The return address will be the start address of this instruction,<br />and this instruction will be re-executed.  This avoids increased interrupt<br />latency.<br /><br /><br />",
      "operation": "void DIVS (int n)\n{\n  R[n] = R[n] / R[0];\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "divu\tR0,Rn",
      "abstract": "Unsigned, Rn / R0 -> Rn\n32 / 32 -> 32 bits",
      "code": "0100nnnn10000100",
      "T": "-",
      "description": "Executes division of the 32-bit contents of a general register Rn (dividend) by<br />the contents of R0 (divisor). This instruction executes unsigned division and<br />finds the quotient only. A remainder operation is not provided. To obtain the<br />remainder, find the product of the divisor and the obtained quotient, and<br />subtract this value from the dividend.<br /><br /><br />NoteA division by zero exception will occur if division by zero is performed.<br /><br />If an interrupt is generated while this instruction is being executed, execution<br />will be halted. The return address will be the start address of this instruction,<br />and this instruction will be re-executed.  This avoids increased interrupt<br />latency.<br /><br /><br />",
      "operation": "void DIVU (int n)\n{\n  R[n]= (unsigned long)R[n] / (unsigned long)R[0];\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": true,
      "SH2.issue": 2,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 2,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 2,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "dmuls.l\tRm,Rn",
      "abstract": "Signed, Rn * Rm -> MACH:MACL\n32 * 32 -> 64 bits",
      "code": "0011nnnnmmmm1101",
      "T": "-",
      "description": "Performs 32-bit multiplication of the contents of general register Rn by the<br />contents of Rm, and stores the 64-bit result in the MACH and MACL registers.<br />The multiplication is performed as a signed arithmetic operation.<br /><br /><br />NoteOn SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of MAC*/MUL* is 5 cycles.<br /><br /><br />",
      "operation": "void DMULS (int m, int n)\n{\n  unsigned long RnL, RnH, RmL, RmH, Res0, Res1, Res2;\n  unsigned long temp0, temp1, temp2, temp3;\n  long tempm, tempn, fnLmL;\n\n  tempn = (long)R[n];\n  tempm = (long)R[m];\n\n  if (tempn &lt; 0)\n    tempn = 0 - tempn;\n\n  if (tempm &lt; 0)\n    tempm = 0 - tempm;\n\n  if ((long)(R[n] ^ R[m]) &lt; 0)\n    fnLmL = -1;\n  else\n    fnLmL = 0;\n\n  temp1 = (unsigned long)tempn;\n  temp2 = (unsigned long)tempm;\n\n  RnL = temp1 &amp; 0x0000FFFF;\n  RnH = (temp1 &gt;&gt; 16) &amp; 0x0000FFFF;\n\n  RmL = temp2 &amp; 0x0000FFFF;\n  RmH = (temp2 &gt;&gt; 16) &amp; 0x0000FFFF;\n\n  temp0 = RmL * RnL;\n  temp1 = RmH * RnL;\n  temp2 = RmL * RnH;\n  temp3 = RmH * RnH;\n\n  Res2 = 0;\n  Res1 = temp1 + temp2;\n  if (Res1 &lt; temp1)\n    Res2 += 0x00010000;\n\n  temp1 = (Res1 &lt;&lt; 16) &amp; 0xFFFF0000;\n  Res0 = temp0 + temp1;\n  if (Res0 &lt; temp0)\n    Res2++;\n\n  Res2 = Res2 + ((Res1 &gt;&gt; 16) &amp; 0x0000FFFF) + temp3;\n\n  if (fnLmL &lt; 0)\n  {\n    Res2 = ~Res2;\n    if (Res0 == 0)\n      Res2++;\n    else\n      Res0 = (~Res0) + 1;\n  }\n\n  MACH = Res2;\n  MACL = Res0;\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": true,
      "SH2.issue": 2,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 2,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 2,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "dmulu.l\tRm,Rn",
      "abstract": "Unsigned, Rn * Rm -> MACH:MACL\n32 * 32 -> 64 bits",
      "code": "0011nnnnmmmm0101",
      "T": "-",
      "description": "Performs 32-bit multiplication of the contents of general register Rn by the<br />contents of Rm, and stores the 64-bit result in the MACH and MACL registers.<br />The multiplication is performed as an unsigned arithmetic operation.<br /><br /><br />NoteOn SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of MAC*/MUL* is 5 cycles.<br /><br /><br />",
      "operation": "void DMULU (int m, int n)\n{\n  unsigned long RnL, RnH, RmL, RmH, Res0, Res1, Res2;\n  unsigned long temp0, temp1, temp2, temp3;\n\n  RnL = R[n] &amp; 0x0000FFFF;\n  RnH = (R[n] &gt;&gt; 16) &amp; 0x0000FFFF;\n\n  RmL = R[m] &amp; 0x0000FFFF;\n  RmH = (R[m] &gt;&gt; 16) &amp; 0x0000FFFF;\n\n  temp0 = RmL * RnL;\n  temp1 = RmH * RnL;\n  temp2 = RmL * RnH;\n  temp3 = RmH * RnH;\n\n  Res2 = 0\n  Res1 = temp1 + temp2;\n  if (Res1 &lt; temp1)\n    Res2 += 0x00010000;\n\n  temp1 = (Res1 &lt;&lt; 16) &amp; 0xFFFF0000;\n  Res0 = temp0 + temp1;\n  if (Res0 &lt; temp0)\n    Res2++;\n\n  Res2 = Res2 + ((Res1 &gt;&gt; 16) &amp; 0x0000FFFF) + temp3;\n\n  MACH = Res2;\n  MACL = Res0;\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "dt\tRn",
      "abstract": "Rn-1 -> Rn\nIf Rn = 0: 1 -> T\nElse: 0 -> T",
      "code": "0100nnnn00010000",
      "T": "-",
      "description": "Decrements the contents of general register Rn by 1 and compares the result<br />with zero. If the result is zero, the T bit is set to 1.<br />If the result is nonzero, the T bit is cleared to 0.<br /><br /><br />",
      "operation": "void DT (int n)\n{\n  R[n]--;\n\n  if (R[n] == 0)\n    T = 1;\n  else T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "exts.b\tRm,Rn",
      "abstract": "Rm sign-extended from byte -> Rn",
      "code": "0110nnnnmmmm1110",
      "T": "-",
      "description": "Sign-extends the contents of general register Rm and stores the result in Rn.<br />The value of Rm bit 7 is transferred to Rn bits 8 to 31.<br /><br /><br />",
      "operation": "void EXTSB (int m, int n)\n{\n  R[n] = R[m];\n\n  if ((R[m] &amp; 0x00000080) == 0)\n    R[n] &amp; = 0x000000FF;\n  else\n    R[n] |= 0xFFFFFF00;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "exts.w\tRm,Rn",
      "abstract": "Rm sign-extended from word -> Rn",
      "code": "0110nnnnmmmm1111",
      "T": "-",
      "description": "Sign-extends the contents of general register Rm and stores the result in Rn.<br />The value of Rm bit 15 is transferred to Rn bits 16 to 31.<br /><br /><br />",
      "operation": "void EXTSW (int m, int n)\n{\n  R[n] = R[m];\n\n  if ((R[m] &amp; 0x00008000) == 0)\n    R[n] &amp; = 0x0000FFFF;\n  else\n    R[n] |= 0xFFFF0000;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "extu.b\tRm,Rn",
      "abstract": "Rm zero-extended from byte -> Rn",
      "code": "0110nnnnmmmm1100",
      "T": "-",
      "description": "Zero-extends the contents of general register Rm and stores the result in Rn.<br />0 is transferred to Rn bits 8 to 31.<br /><br /><br />",
      "operation": "void EXTUB (int m, int n)\n{\n  R[n] = R[m];\n  R[n] &amp;= 0x000000FF;\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "extu.w\tRm,Rn",
      "abstract": "Rm zero-extended from word -> Rn",
      "code": "0110nnnnmmmm1101",
      "T": "-",
      "description": "Zero-extends the contents of general register Rm and stores the result in Rn.<br />0 is transferred to Rn bits 16 to 31.<br /><br /><br />",
      "operation": "void EXTUW (int m, int n)\n{\n  R[n] = R[m];\n  R[n] &amp;= 0x0000FFFF;\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": true,
      "SH2.issue": 2,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 2,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 2,
      "SH4A.latency": 5,
      "SH2A": true,
      "SH2A.issue": 4,
      "SH2A.latency": 5,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mac.l\t@Rm+,@Rn+",
      "abstract": "Signed, (Rn) * (Rm) + MAC -> MAC\n32 * 32 + 64 -> 64 bits",
      "code": "0000nnnnmmmm1111",
      "T": "-",
      "description": "Performs signed multiplication of the 32-bit operands whose addresses are the<br />contents of general registers Rm and Rn, adds the 64-bit result to the MAC<br />register contents, and stores the result in the MAC register.<br />Operands Rm and Rn are each incremented by 4 each time they are read.<br /><br />When the S bit is cleared to 0, the 64-bit result is stored in the coupled MACH<br />and MACL registers.<br /><br />When bit S is set to 1, addition to the MAC register is a saturation operation<br />of 48 bits starting from the LSB. For the saturation operation, only the lower<br />48 bits of the MACL register are enabled and the result is limited to a range<br />of 0xFFFF800000000000 (minimum) and 0x00007FFFFFFFFFFF (maximum).<br /><br /><br />NoteOn SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of MAC*/MUL* is 5 cycles.  In the case of consecutive executions of<br />MAC.W/MAC.L, the latency is decreased to 2 cycles.<br /><br /><br />",
      "operation": "void MACL (int m, int n)\n{\n  unsigned long RnL, RnH, RmL, RmH, Res0, Res1, Res2;\n  unsigned long temp0, temp1, temp2, temp3;\n  long tempm, tempn, fnLmL;\n\n  tempn = Read_32 (R[n]);\n  R[n] += 4;\n  tempm = Read_32 (R[m]);\n  R[m] += 4;\n\n  if ((long)(tempn ^ tempm) &lt; 0)\n    fnLmL = -1;\n  else\n    fnLmL = 0;\n\n  if (tempn &lt; 0)\n    tempn = 0 - tempn;\n  if (tempm &lt; 0)\n    tempm = 0 - tempm;\n\n  temp1 = (unsigned long)tempn;\n  temp2 = (unsigned long)tempm;\n\n  RnL = temp1 &amp; 0x0000FFFF;\n  RnH = (temp1 &gt;&gt; 16) &amp; 0x0000FFFF;\n  RmL = temp2 &amp; 0x0000FFFF;\n  RmH = (temp2 &gt;&gt; 16) &amp; 0x0000FFFF;\n  temp0 = RmL * RnL;\n  temp1 = RmH * RnL;\n  temp2 = RmL * RnH;\n  temp3 = RmH * RnH;\n\n  Res2 = 0;\n\n  Res1 = temp1 + temp2;\n  if (Res1 &lt; temp1)\n    Res2 += 0x00010000;\n\n  temp1 = (Res1 &lt;&lt; 16) &amp; 0xFFFF0000;\n\n  Res0 = temp0 + temp1;\n  if (Res0 &lt; temp0)\n    Res2++;\n\n  Res2 = Res2 + ((Res1 &gt;&gt; 16) &amp; 0x0000FFFF) + temp3;\n\n  if(fnLmL &lt; 0)\n  {\n    Res2 = ~Res2;\n    if (Res0 == 0)\n      Res2++;\n    else\n      Res0 = (~Res0) + 1;\n  }\n\n  if (S == 1)\n  {\n    Res0 = MACL + Res0;\n    if (MACL &gt; Res0)\n      Res2++;\n\n    Res2 += MACH &amp; 0x0000FFFF;\n\n    if (((long)Res2 &lt; 0) &amp;&amp; (Res2 &lt; 0xFFFF8000))\n    {\n      Res2 = 0xFFFF8000;\n      Res0 = 0x00000000;\n    }\n\n    if (((long)Res2 &gt; 0) &amp;&amp; (Res2 &gt; 0x00007FFF))\n    {\n      Res2 = 0x00007FFF;\n      Res0 = 0xFFFFFFFF;\n    }\n\n    MACH = (Res2 &amp; 0x0000FFFF) | (MACH &amp; 0xFFFF0000);\n    MACL = Res0;\n  }\n  else\n  {\n    Res0 = MACL + Res0;\n    if (MACL &gt; Res0)\n      Res2 ++;\n\n    Res2 += MACH;\n    MACH = Res2;\n    MACL = Res0;\n  }\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 2,
      "SH1.latency": 2,
      "SH2": true,
      "SH2.issue": 2,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 2,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 2,
      "SH4A.latency": 4,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 4,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mac.w\t@Rm+,@Rn+",
      "abstract": "Signed, (Rn) * (Rm) + MAC -> MAC\nSH1: 16 * 16 + 42 -> 42 bits\nOther: 16 * 16 + 64 -> 64 bits",
      "code": "0100nnnnmmmm1111",
      "T": "-",
      "description": "Performs signed multiplication of the 16-bit operands whose addresses are the<br />contents of general registers Rm and Rn, adds the 32-bit result to the MAC<br />register contents, and stores the result in the MAC register.<br />Operands Rm and Rn are each incremented by 2 each time they are read.<br /><br />If the S bit is 0, a 16 * 16 + 64 -> 64-bit multiply-and-accumulate operation<br />is performed, and the 64-bit result is stored in the linked MACH and MACL<br />registers.<br /><br />If the S bit is 1, a 16 * 16 + 32 -> 32-bit multiply-and-accumulate operation is<br />performed, and the addition to the MAC register contents is a saturation<br />operation. In a saturation operation, only the MACL register is valid, and the<br />result range is limited to 0x80000000 (minimum value) to 0x7FFFFFFF<br />(maximum value). If overflow occurs, the LSB of the MACH register is set to 1.<br />0x80000000 (minimum value) is stored in the MACL register if the result<br />overflows in the negative direction, and 0x7FFFFFFF (maximum value) is stored<br />if the result overflows in the positive direction<br /><br /><br />NoteWhen the S bit is 0, the SH2 and SH-DSP CPU perform a 16 * 16 + 64 -> 64 bit<br />multiply and accumulate operation and the SH1 CPU performs a 16 * 16 + 42 -><br />42 bit multiply and accumulate operation.<br /><br />On SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of MAC*/MUL* is 5 cycles.  In the case of consecutive executions of<br />MAC.W/MAC.L, the latency is decreased to 2 cycles.<br /><br /><br />",
      "operation": "void MACW (int m, int n)\n{\n  long tempm, tempn, dest, src, ans;\n  unsigned long templ;\n\n  tempn = Read_16 (R[n]);\n  R[n] += 2;\n  tempm = Read_16 (R[m]);\n  R[m] += 2;\n\n  templ = MACL;\n  tempm = ((long)(short)tempn * (long)(short)tempm);\n\n  if ((long)MACL &gt;= 0)\n    dest = 0;\n  else\n    dest = 1;\n\n  if ((long)tempm &gt;= 0)\n  {\n    src = 0;\n    tempn = 0;\n  }\n  else\n  {\n    src = 1;\n    tempn = 0xFFFFFFFF;\n  }\n\n  src += dest;\n  MACL += tempm;\n\n  if ((long)MACL &gt;= 0)\n    ans = 0;\n  else\n    ans = 1;\n\n  ans += dest;\n\n  if (S == 1)\n  {\n    if (ans == 1)\n    {\n      #if SH1\n      if (src == 0 || src == 2)\n        MACH |= 0x00000001;\n      #endif\n\n      if (src == 0)\n        MACL = 0x7FFFFFFF;\n      if (src == 2)\n        MACL = 0x80000000;\n    }\n  }\n  else\n  {\n    MACH += tempn;\n    if (templ &gt; MACL)\n      MACH += 1;\n\n    #if SH1\n    if ((MACH &amp; 0x00000200) == 0)\n      MACH &amp;= 0x000003FF;\n    else\n      MACH |= 0xFFFFFC00;\n    #endif\n  }\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": true,
      "SH2.issue": 2,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 2,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 2,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mul.l\tRm,Rn",
      "abstract": "Rn * Rm -> MACL\n32 * 32 -> 32 bits",
      "code": "0000nnnnmmmm0111",
      "T": "-",
      "description": "Performs 32-bit multiplication of the contents of general registers Rn and Rm,<br />and stores the lower 32 bits of the result in the MACL register. The contents<br />of MACH are not changed.<br /><br /><br />NoteOn SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of MAC*/MUL* is 5 cycles.<br /><br /><br />",
      "operation": "void MULL (int m, int n)\n{\n  MACL = R[n] * R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 4,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mulr\tR0,Rn",
      "abstract": "R0 * Rn -> Rn\n32 * 32 -> 32 bits",
      "code": "0100nnnn10000000",
      "T": "-",
      "description": "Performs 32-bit multiplication of the contents of general register R0 by Rn,<br />and stores the lower 32 bits of the result in general register Rn.<br /><br /><br />",
      "operation": "void MULR (int n)\n{\n  R[n] = R[0] * R[n];\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 2,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 2,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "muls.w\tRm,Rn",
      "abstract": "Signed, Rn * Rm -> MACL\n16 * 16 -> 32 bits",
      "code": "0010nnnnmmmm1111",
      "T": "-",
      "description": "Performs 16-bit multiplication of the contents of general registers Rn and Rm,<br />and stores the 32-bit result in the MACL register. The multiplication is<br />performed as a signed arithmetic operation. The contents of MACH are not<br />changed.<br /><br /><br />NoteOn SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of MAC*/MUL* is 5 cycles.<br /><br /><br />",
      "operation": "void MULS (int m, int n)\n{\n  MACL = ((long)(short)R[n] * (long)(short)R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 2,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 2,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "mulu.w\tRm,Rn",
      "abstract": "Unsigned, Rn * Rm -> MACL\n16 * 16 -> 32 bits",
      "code": "0010nnnnmmmm1110",
      "T": "-",
      "description": "Performs 16-bit multiplication of the contents of general registers Rn and Rm,<br />and stores the 32-bit result in the MACL register. The multiplication is<br />performed as an unsigned arithmetic operation. The contents of MACH are not<br />changed.<br /><br /><br />NoteOn SH4, when MAC*/MUL* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of MAC*/MUL* is 5 cycles.<br /><br /><br />",
      "operation": "void MULU (int m, int n)\n{\n  MACL = ((unsigned long)(unsigned short)R[n]* (unsigned long)(unsigned short)R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "neg\tRm,Rn",
      "abstract": "0 - Rm -> Rn",
      "code": "0110nnnnmmmm1011",
      "T": "-",
      "description": "Finds the two's complement of the contents of general register Rm and stores<br />the result in Rn. That is, it subtracts Rm from 0 and stores the result in Rn.<br /><br /><br />",
      "operation": "void NEG (int m, int n)\n{\n  R[n] = 0 - R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "negc\tRm,Rn",
      "abstract": "0 - Rm - T -> Rn, borrow -> T",
      "code": "0110nnnnmmmm1010",
      "T": "borrow",
      "description": "Subtracts the contents of general register Rm and the T bit from 0 and stores<br />the result in Rn. A borrow resulting from the operation is reflected in the<br />T bit. This instruction can be  used for sign inversion of a value exceeding<br />32 bits.<br /><br /><br />NoteThis instruction can also be used to efficiently store the reversed T bit value<br />in a general register, if the MOVRT instruction is not available.<br /><br /><br />",
      "operation": "void NEGC (int m, int n)\n{\n  unsigned long temp;\n  temp = 0 - R[m];\n  R[n] = temp - T;\n\n  if (0 &lt; temp)\n    T = 1;\n  else\n    T = 0;\n\n  if (temp &lt; R[n])\n    T = 1;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sub\tRm,Rn",
      "abstract": "Rn - Rm -> Rn",
      "code": "0011nnnnmmmm1000",
      "T": "-",
      "description": "Subtracts the contents of general register Rm from the contents of general<br />register Rn and stores the result in Rn. For immediate data subtraction,<br />ADD #imm,Rn should be used.<br /><br /><br />",
      "operation": "void SUB (int m, int n)\n{\n  R[n] -= R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "subc\tRm,Rn",
      "abstract": "Rn - Rm - T -> Rn, borrow -> T",
      "code": "0011nnnnmmmm1010",
      "T": "borrow",
      "description": "Subtracts the contents of general register Rm and the T bit from the contents of<br />general register Rn, and stores the result in Rn. A borrow resulting from the<br />operation is reflected in the T bit. This instruction is used for subtractions<br />exceeding 32 bits.<br /><br /><br />NoteThis instruction can also be used to store the T bit to all the bits of a<br />general register.<br /><br /><br />",
      "operation": "void SUBC (int m, int n)\n{\n  unsigned long tmp0, tmp1;\n  tmp1 = R[n] - R[m];\n  tmp0 = R[n];\n  R[n] = tmp1 - T;\n\n  if (tmp0 &lt; tmp1)\n    T = 1;\n  else\n    T = 0;\n\n  if (tmp1 &lt; R[n])\n    T = 1;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Arithmetic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "subv\tRm,Rn",
      "abstract": "Rn - Rm -> Rn, underflow -> T",
      "code": "0011nnnnmmmm1011",
      "T": "underflow",
      "description": "Subtracts the contents of general register Rm from the contents of general<br />register Rn, and stores the result in Rn. If underflow occurs, the T bit is set.<br /><br /><br />",
      "operation": "void SUBV (int m, int n)\n{\n  long dest, src, ans;\n\n  if ((long)R[n] &gt;= 0)\n    dest = 0;\n  else\n    dest = 1;\n\n  if ((long)R[m] &gt;= 0)\n    src = 0;\n  else\n    src = 1;\n\n  src += dest;\n  R[n] -= R[m];\n\n  if ((long)R[n] &gt;= 0)\n    ans = 0;\n  else\n    ans = 1;\n\n  ans += dest;\n\n  if (src == 1)\n  {\n    if (ans == 1)\n      T = 1;\n    else\n      T = 0;\n  }\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "and\tRm,Rn",
      "abstract": "Rn & Rm -> Rn",
      "code": "0010nnnnmmmm1001",
      "T": "-",
      "description": "ANDs the contents of general registers Rn and Rm and stores the result in Rn.<br /><br /><br />",
      "operation": "void AND (int m, int n)\n{\n  R[n] &amp;= R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "and\t#imm,R0",
      "abstract": "R0 & (zero extend)imm -> R0",
      "code": "11001001iiiiiiii",
      "T": "-",
      "description": "ANDs the contents of general register R0 and the zero-extended immediate value<br />and stores the result in R0.<br /><br /><br />NoteSince the 8-bit immediate value is zero-extended, the upper 24 bits of R0 are<br />always cleared to zero.<br /><br /><br />",
      "operation": "void ANDI (int i)\n{\n  R[0] &amp;= (0x000000FF &amp; (long)i);\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 2,
      "SH1.latency": 3,
      "SH2": true,
      "SH2.issue": 2,
      "SH2.latency": 3,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 3,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 4,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 3,
      "SH4A.latency": 3,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": null,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "and.b\t#imm,@(R0,GBR)",
      "abstract": "(R0 + GBR) & (zero extend)imm -> (R0 + GBR)",
      "code": "11001101iiiiiiii",
      "T": "-",
      "description": "ANDs the contents of the memory byte indicated by the indirect GBR address with<br />the immediate value and writes the result back to the memory byte.<br /><br /><br />",
      "operation": "void ANDM (long i)\n{\n  long temp = Read_8 (GBR + R[0]);\n  temp &amp;= 0x000000FF &amp; (long)i;\n  Write_8 (GBR + R[0], temp);\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "not\tRm,Rn",
      "abstract": "~Rm -> Rn",
      "code": "0110nnnnmmmm0111",
      "T": "-",
      "description": "Finds the one's complement of the contents of general register Rm and stores<br />the result in Rn. That is, it inverts the Rm bits and stores the result in Rn.<br /><br /><br />",
      "operation": "void NOT (int m, int n)\n{\n  R[n] = ~R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "or\tRm,Rn",
      "abstract": "Rn | Rm -> Rn",
      "code": "0010nnnnmmmm1011",
      "T": "-",
      "description": "ORs the contents of general registers Rn and Rm and stores the result in Rn.<br /><br /><br />",
      "operation": "void OR (int m, int n)\n{\n  R[n] |= R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "or\t#imm,R0",
      "abstract": "R0 | (zero extend)imm -> R0",
      "code": "11001011iiiiiiii",
      "T": "-",
      "description": "ORs the contents of general register R0 and the zero-extended immediate value<br />and stores the result in R0.<br /><br /><br />NoteSince the 8-bit immediate value is zero-extended, the upper 24 bits of R0 are<br />not modified.<br /><br /><br />",
      "operation": "void ORI (int i)\n{\n  R[0] |= (0x000000FF &amp; (long)i);\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 2,
      "SH1.latency": 3,
      "SH2": true,
      "SH2.issue": 2,
      "SH2.latency": 3,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 3,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 4,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 3,
      "SH4A.latency": 3,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "or.b\t#imm,@(R0,GBR)",
      "abstract": "(R0 + GBR) | (zero extend)imm -> (R0 + GBR)",
      "code": "11001111iiiiiiii",
      "T": "-",
      "description": "ORs the contents of the memory byte indicated by the indirect GBR address with<br />the immediate value and writes the result back to the memory byte.<br /><br /><br />",
      "operation": "void ORM (int i)\n{\n  long temp = Read_8 (GBR + R[0]);\n  temp |= (0x000000FF &amp; (long)i);\n  Write_8 (GBR + R[0], temp);\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 2,
      "SH1.latency": 4,
      "SH2": true,
      "SH2.issue": 2,
      "SH2.latency": 4,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 3,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 5,
      "SH4.latency": 5,
      "SH4A": true,
      "SH4A.issue": 4,
      "SH4A.latency": 4,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "tas.b\t@Rn",
      "abstract": "If (Rn) = 0: 1 -> T\nElse: 0 -> T\n1 -> MSB of (Rn)",
      "code": "0100nnnn00011011",
      "T": "result",
      "description": "Reads byte data from the address specified by general register Rn, and sets the<br />T bit to 1 if the data is 0, or clears the T bit to 0 if the data is not 0.<br />Then, data bit 7 is set to 1, and the data is written to the address specified<br />by Rn. During this operation, the bus is not released.<br /><br /><br />On SH4 and SH4A this instruction purges the cache block corresponding to the<br />memory area specified by the contents of general register Rn. <br />The purge operation is executed as follows.<br />In a purge operation, data is accessed using the contents of general register Rn<br />as the effective address. If there is a cache hit and the corresponding cache<br />block is dirty (U bit = 1), the contents of that cache block are written back to<br />external memory, and the cache block is then invalidated (by clearing the V bit<br />to 0). If there is a cache hit and the corresponding cache block is clean (U bit<br />= 0), the cache block is simply invalidated (by clearing the V bit to 0). A<br />purge is not executed in the event of a cache miss, or if the accessed memory<br />location is non-cacheable.<br /><br /><br />NoteThe two TAS.B memory accesses are executed automatically. Another memory access<br />is not executed between the two TAS.B accesses.<br /><br />On SH3 the destination of the TAS instruction should be placed in a<br />non-cacheable space when the cache is enabled.<br /><br /><br />",
      "operation": "void TAS (int n)\n{\n  int temp = Read_8 (R[n]); // Bus Lock\n\n  if (temp == 0)\n    T = 1;\n  else\n    T = 0;\n\n  temp |= 0x00000080;\n  Write_8 (R[n], temp);  // Bus unlock\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "tst\tRm,Rn",
      "abstract": "If Rn & Rm = 0: 1 -> T\nElse: 0 -> T",
      "code": "0010nnnnmmmm1000",
      "T": "result",
      "description": "ANDs the contents of general registers Rn and Rm, and sets the T bit if the<br />result is zero. If the result is nonzero, the T bit is cleared. The contents of<br />Rn are not changed.<br /><br /><br />",
      "operation": "void TST (int m, int n)\n{\n  if ((R[n] &amp; R[m]) == 0)\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "tst\t#imm,R0",
      "abstract": "If R0 & (zero extend)imm = 0: 1 -> T\nElse: 0 -> T",
      "code": "11001000iiiiiiii",
      "T": "result",
      "description": "ANDs the contents of general register R0 and the zero-extended immediate value<br />and sets the T bit if the result is zero. If the result is nonzero, the T bit<br />is cleared. The contents of Rn are not changed.<br /><br /><br />NoteSince the 8-bit immediate value is zero-extended, this instruction can only be<br />used to test the lower 8 bits of R0.<br /><br /><br />",
      "operation": "void TSTI (int i)\n{\n  long temp = R[0] &amp; (0x000000FF &amp; (long)i);\n\n  if (temp == 0)\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 2,
      "SH1.latency": 3,
      "SH2": true,
      "SH2.issue": 2,
      "SH2.latency": 3,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 3,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 3,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 3,
      "SH4A.latency": 3,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "tst.b\t#imm,@(R0,GBR)",
      "abstract": "If (R0 + GBR) & (zero extend)imm = 0: 1 -> T\nElse 0: -> T",
      "code": "11001100iiiiiiii",
      "T": "result",
      "description": "ANDs the contents of the memory byte indicated by the indirect GBR address with<br />the zero-extended immediate value and sets the T bit if the result is zero.<br />If the result is nonzero, the T bit is cleared.<br />The contents of the memory byte are not changed.<br /><br /><br />",
      "operation": "void TSTM (int i)\n{\n  long temp = Read_8 (GBR + R[0]);\n  temp &amp;= (0x000000FF &amp; (long)i);\n\n  if (temp == 0)\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "xor\tRm,Rn",
      "abstract": "Rn ^ Rm -> Rn",
      "code": "0010nnnnmmmm1010",
      "T": "-",
      "description": "XORs the contents of general registers Rn and Rm and stores the result in Rn.<br /><br /><br />",
      "operation": "void XOR (long m, long n)\n{\n  R[n] ^= R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "xor\t#imm,R0",
      "abstract": "R0 ^ (zero extend)imm -> R0",
      "code": "11001010iiiiiiii",
      "T": "-",
      "description": "XORs the contents of general register R0 and the zero-extended immediate value<br />and stores the result in R0.<br /><br /><br />NoteSince the 8-bit immediate value is zero-extended, the upper 24 bits of R0 are<br />not modified.<br /><br /><br />",
      "operation": "void XORI (int i)\n{\n  R[0] ^= (0x000000FF &amp; (long)i);\n  PC += 2;\n}\n"
    },
    {
      "group": "Logic Operation Instructions",
      "SH1": true,
      "SH1.issue": 2,
      "SH1.latency": 3,
      "SH2": true,
      "SH2.issue": 2,
      "SH2.latency": 3,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 3,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 4,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 3,
      "SH4A.latency": 3,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "xor.b\t#imm,@(R0,GBR)",
      "abstract": "(R0 + GBR) ^ (zero extend)imm -> (R0 + GBR)",
      "code": "11001110iiiiiiii",
      "T": "-",
      "description": "XORs the contents of the memory byte indicated by the indirect GBR address with<br />the immediate value and writes the result back to the memory byte.<br /><br /><br />",
      "operation": "void XORM (int i)\n{\n  int temp = Read_8 (GBR + R[0]);\n  temp ^= (0x000000FF &amp; (long)i);\n  Write_8 (GBR + R[0], temp);\n  PC += 2;\n}\n"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "rotcl\tRn",
      "abstract": "T << Rn << T",
      "code": "0100nnnn00100100",
      "T": "-",
      "description": "Rotates the contents of general register Rn one bit to the left through the<br />T bit, and stores the result in Rn. The bit rotated out of the operand is<br />transferred to the T bit.<br /><br /><br /><br />",
      "operation": "void ROTCL (int n)\n{\n  long temp;\n\n  if ((R[n] & 0x80000000) == 0)\n    temp = 0;\n  else\n    temp = 1;\n\n  R[n] <<= 1;\n\n  if (T == 1)\n    R[n] |= 0x00000001;\n  else\n    R[n] &= 0xFFFFFFFE;\n\n  if (temp == 1)\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "rotcr\tRn",
      "abstract": "T >> Rn >> T",
      "code": "0100nnnn00100101",
      "T": "-",
      "description": "Rotates the contents of general register Rn one bit to the right through the<br />T bit, and stores the result in Rn. The bit rotated out of the operand is<br />transferred to the T bit.<br /><br /><br /><br />",
      "operation": "void ROTCR (int n)\n{\n  long temp;\n\n  if ((R[n] &amp; 0x00000001) == 0)\n    temp = 0;\n  else\n    temp = 1;\n\n  R[n] &gt;&gt;= 1;\n\n  if (T == 1)\n    R[n] |= 0x80000000;\n  else\n    R[n] &amp;= 0x7FFFFFFF;\n\n  if (temp == 1)\n    T = 1;\n  else\n    T = 0;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "rotl\tRn",
      "abstract": "T << Rn << MSB",
      "code": "0100nnnn00000100",
      "T": "-",
      "description": "Rotates the contents of general register Rn one bit to the left, and stores the<br />result in Rn. The bit rotated out of the operand is transferred to the T bit.<br /><br /><br /><br />",
      "operation": "void ROTL (int n)\n{\n  if ((R[n] & 0x80000000) == 0)\n    T = 0;\n  else\n    T = 1;\n\n  R[n] <<= 1;\n\n  if (T == 1)\n    R[n] |= 0x00000001;\n  else\n    R[n] &= 0xFFFFFFFE;\n\n  PC += 2;\n}"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "rotr\tRn",
      "abstract": "LSB >> Rn >> T",
      "code": "0100nnnn00000101",
      "T": "-",
      "description": "Rotates the contents of general register Rn one bit to the right, and stores the<br />result in Rn. The bit rotated out of the operand is transferred to the T bit.<br /><br /><br /><br />",
      "operation": "void ROTR (int n)\n{\n  if ((R[n] &amp; 0x00000001) == 0)\n    T = 0;\n  else\n    T = 1;\n\n  R[n] &gt;&gt;= 1;\n\n  if (T == 1)\n    R[n] |= 0x80000000;\n  else\n    R[n] &amp;= 0x7FFFFFFF;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Shift Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "shad\tRm,Rn",
      "abstract": "If Rm >= 0: Rn << Rm -> Rn\nIf Rm < 0: Rn >> |Rm| -> [MSB -> Rn]",
      "code": "0100nnnnmmmm1100",
      "T": "-",
      "description": "Arithmetically shifts the contents of general register Rn. General register Rm<br />specifies the shift direction and the number of bits to be shifted.<br /><br />Rn register contents are shifted to the left if the Rm register value is<br />positive, and to the right if negative. In a shift to the right, the MSB is<br />added at the upper end.<br /><br />The number of bits to be shifted is specified by the lower 5 bits (bits 4 to 0)<br />of the Rm register. If the value is negative (MSB = 1), the Rm register is<br />represented as a two's complement. The left shift range is 0 to 31, and the<br />right shift range, 1 to 32.<br /><br /><br /><br />NoteOn SH4, if there is a load of the shift amount immediately before an SHAD/SHLD<br />instruction, the latency of the load is increased by 1 cycle.<br /><br /><br />",
      "operation": "void SHAD (int m, int n)\n{\n  int sgn = R[m] & 0x80000000;\n\n  if (sgn == 0)\n    R[n] <<= (R[m] & 0x1F);\n  else if ((R[m] & 0x1F) == 0)\n  {\n    if ((R[n] & 0x80000000) == 0)\n      R[n] = 0;\n    else\n      R[n] = 0xFFFFFFFF;\n  }\n  else\n    R[n] = (long)R[n] >> ((~R[m] & 0x1F) + 1);\n\n  PC += 2;\n}"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "shal\tRn",
      "abstract": "T << Rn << 0",
      "code": "0100nnnn00100000",
      "T": "-",
      "description": "Arithmetically shifts the contents of general register Rn one bit to the left<br />and stores the result in Rn. The bit shifted out of the operand is transferred<br />to the T bit.<br /><br /><br /><br />",
      "operation": "void SHAL (int n)\n{\n  if ((R[n] &amp; 0x80000000) == 0)\n    T = 0;\n  else\n    T = 1;\n\n  R[n] &lt;<= 1;\n  PC += 2;\n}"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "shar\tRn",
      "abstract": "MSB >> Rn >> T",
      "code": "0100nnnn00100001",
      "T": "-",
      "description": "Arithmetically shifts the contents of general register Rn one bit to the right<br />and stores the result in Rn. The bit shifted out of the operand is transferred<br />to the T bit.<br /><br /><br /><br />",
      "operation": "void SHAR (int n)\n{\n  long temp;\n\n  if ((R[n] &amp; 0x00000001) == 0)\n    T = 0;\n  else\n    T = 1;\n\n  if ((R[n] &amp; 0x80000000) == 0)\n    temp = 0;\n  else\n    temp = 1;\n\n  R[n] &gt;&gt;= 1;\n\n  if (temp == 1)\n    R[n] |= 0x80000000;\n  else\n    R[n] &amp;= 0x7FFFFFFF;\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Shift Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "shld\tRm,Rn",
      "abstract": "If Rm >= 0: Rn << Rm -> Rn\nIf Rm < 0: Rn >> |Rm| -> [0 -> Rn]",
      "code": "0100nnnnmmmm1101",
      "T": "-",
      "description": "Logically shifts the contents of general register Rn. General register Rm<br />specifies the shift direction and the number of bits to be shifted.<br /><br />Rn register contents are shifted to the left if the Rm register value is<br />positive, and to the right if negative. In a shift to the right, 0s are added<br />at the upper end.<br /><br />The number of bits to be shifted is specified by the lower 5 bits (bits 4 to 0)<br />of the Rm register. If the value is negative (MSB = 1), the Rm register is<br />represented as a two's complement. The left shift range is 0 to 31, and the<br />right shift range, 1 to 32.<br /><br /><br /><br />NoteOn SH4, if there is a load of the shift amount immediately before an SHAD/SHLD<br />instruction, the latency of the load is increased by 1 cycle.<br /><br /><br />",
      "operation": "void SHLD (int m, int n)\n{\n  int sgn = R[m] & 0x80000000;\n\n  if (sgn == 0)\n    R[n] <<= (R[m] & 0x1F);\n  else if ((R[m] & 0x1F) == 0)\n    R[n] = 0;\n  else\n    R[n] = (unsigned)R[n] >> ((~R[m] & 0x1F) + 1);\n\n  PC += 2;\n}"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "shll\tRn",
      "abstract": "T << Rn << 0",
      "code": "0100nnnn00000000",
      "T": "-",
      "description": "Logically shifts the contents of general register Rn one bit to the left and<br />stores the result in Rn. The bit shifted out of the operand is transferred to<br />the T bit.<br /><br /><br /><br />NoteEffectively, the operation performed is the same as the SHAL instruction.<br /><br /><br />",
      "operation": "void SHLL (int n)\n{\n  if ((R[n] &amp; 0x80000000) == 0)\n    T = 0;\n  else\n    T = 1;\n\n  R[n] &lt;<= 1;\n  PC += 2;\n}"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "shll2\tRn",
      "abstract": "Rn << 2 -> Rn",
      "code": "0100nnnn00001000",
      "T": "-",
      "description": "Logically shifts the contents of general register Rn 2 bits to the left and<br />stores the result in Rn. The bits shifted out of the operand are discarded.<br /><br /><br /><br />",
      "operation": "void SHLL2 (int n)\n{\n  R[n] &lt;<= 2;\n  PC += 2;\n}"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "shll8\tRn",
      "abstract": "Rn << 8 -> Rn",
      "code": "0100nnnn00011000",
      "T": "-",
      "description": "Logically shifts the contents of general register Rn 8 bits to the left and<br />stores the result in Rn. The bits shifted out of the operand are discarded.<br /><br /><br /><br />",
      "operation": "void SHLL8 (int n)\n{\n  R[n] &lt;<= 8;\n  PC += 2;\n}"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "shll16\tRn",
      "abstract": "Rn << 16 -> Rn",
      "code": "0100nnnn00101000",
      "T": "-",
      "description": "Logically shifts the contents of general register Rn 16 bits to the left and<br />stores the result in Rn. The bits shifted out of the operand are discarded.<br /><br /><br /><br />",
      "operation": "void SHLL16 (int n)\n{\n  R[n] &lt;<= 16;\n  PC += 2;\n}"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "shlr\tRn",
      "abstract": "0 >> Rn >> T",
      "code": "0100nnnn00000001",
      "T": "-",
      "description": "Logically shifts the contents of general register Rn one bit to the right and<br />stores the result in Rn. The bit shifted out of the operand is transferred to<br />the T bit.<br /><br /><br /><br />",
      "operation": "void SHLR (int n)\n{\n  if ((R[n] &amp; 0x00000001) == 0)\n    T = 0;\n  else\n    T = 1;\n\n  R[n] &gt;&gt;= 1;\n  R[n] &amp;= 0x7FFFFFFF;\n  PC += 2;\n}\n"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "shlr2\tRn",
      "abstract": "Rn >> 2 -> [0 -> Rn]",
      "code": "0100nnnn00001001",
      "T": "-",
      "description": "Logically shifts the contents of general register Rn 2 bits to the right, and<br />stores the result in Rn. The bits shifted out of the operand are discarded.<br /><br /><br /><br />",
      "operation": "void SHLR2 (int n)\n{\n  R[n] &gt;&gt;= 2;\n  R[n] &amp;= 0x3FFFFFFF;\n  PC += 2;\n}\n"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "shlr8\tRn",
      "abstract": "Rn >> 8 -> [0 -> Rn]",
      "code": "0100nnnn00011001",
      "T": "-",
      "description": "Logically shifts the contents of general register Rn 8 bits to the right, and<br />stores the result in Rn. The bits shifted out of the operand are discarded.<br /><br /><br /><br />",
      "operation": "void SHLR8 (int n)\n{\n  R[n] &gt;&gt;= 8;\n  R[n] &amp;= 0x00FFFFFF;\n  PC += 2;\n}\n"
    },
    {
      "group": "Shift Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "shlr16\tRn",
      "abstract": "Rn >> 16 -> [0 -> Rn]",
      "code": "0100nnnn00101001",
      "T": "-",
      "description": "Logically shifts the contents of general register Rn 16 bits to the right and<br />stores the result in Rn. The bits shifted out of the operand are discarded.<br /><br /><br /><br />",
      "operation": "void SHLR16 (int n)\n{\n  R[n] &gt;&gt;= 16;\n  R[n] &amp;= 0x0000FFFF;\n  PC += 2;\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bf\tlabel",
      "abstract": "If T = 0: disp*2 + PC + 4 -> PC\nElse: nop",
      "code": "10001011dddddddd",
      "T": "-",
      "description": "This is a conditional branch instruction that references the T bit. The branch<br />is taken if T = 0, and not taken if T = 1. The branch destination is address<br />(PC + 4 + displacement * 2).  The PC source value is the BF instruction address.<br />As the 8-bit displacement is multiplied by two after sign-extension, the branch<br />destination can be located in the range from -256 to +254 bytes from the BF<br />instruction.<br /><br /><br />NoteIf the branch destination cannot be reached, the branch must be handled by using<br />BF in combination with a BRA or JMP instruction, for example.<br /><br />On some SH4 implementations a branch with a displacement value of zero does not<br />cause the pipeline I-stage to be stalled even if the branch is taken.  This can<br />be utilized for efficient conditional operations.<br /><br />On some SH2E implementations (SH7055) there is an FPU related hardware bug<br />which affects this instruction.  The recommended workaround is to use bt/s with<br />a nop in the delay slot.<br />See also documents \"sh2eoc.pdf\" and \"win_update_a.pdf\".<br /><br /><br />",
      "operation": "void BF (int d)\n{\n  int disp;\n  if ((d &amp; 0x80) == 0)\n    disp = (0x000000FF &amp; d);\n  else\n    disp = (0xFFFFFF00 | d);\n\n  if (T == 0)\n    PC = PC + 4 + (disp &lt;&lt; 1);\n  else\n    PC += 2;\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bf/s\tlabel",
      "abstract": "If T = 0: disp*2 + PC + 4 -> PC\nElse: nop\n(Delayed branch)",
      "code": "10001111dddddddd",
      "T": "-",
      "description": "This is a delayed conditional branch instruction that references the T bit.<br />If T = 1, the next instruction is executed and the branch is not taken.<br />If T = 0, the branch is taken after execution of the next instruction.<br /><br />The branch destination is address (PC + 4 + displacement * 2). The PC source<br />value is the BF/S instruction address.  As the 8-bit displacement is multiplied<br />by two after sign-extension, the branch destination can be located in the range<br />from -256 to +254 bytes from the BF/S instruction.<br /><br /><br />NoteAs this is a delayed branch instruction, when the branch condition is satisfied,<br />the instruction following this instruction is executed before the branch<br />destination instruction.<br /><br />Interrupts are not accepted between this instruction and the following<br />instruction.<br /><br />If the following instruction is a branch instruction, it is identified as a slot<br />illegal instruction.<br /><br />If this instruction is located in the delay slot immediately following a delayed<br />branch instruction, it is identified as a slot illegal instruction.<br /><br />If the branch destination cannot be reached, the branch must be handled by using<br />BF/S in combination with a BRA or JMP instruction, for example.<br /><br /><br />",
      "operation": "void BFS (int d)\n{\n  int disp;\n  unsigned int temp;\n  temp = PC;\n  if ((d &amp; 0x80) == 0)\n    disp = (0x000000FF &amp; d);\n  else\n    disp = (0xFFFFFF00 | d);\n\n  if (T == 0)\n    PC = PC + 4 + (disp &lt;&lt; 1);\n  else\n    PC += 4;\n\n  Delay_Slot (temp + 2);\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bt\tlabel",
      "abstract": "If T = 1: disp*2 + PC + 4 -> PC\nElse: nop",
      "code": "10001001dddddddd",
      "T": "-",
      "description": "This is a conditional branch instruction that references the T bit. The branch<br />is taken if T = 1, and not taken if T = 0.  The branch destination is address<br />(PC + 4 + displacement * 2). The PC source value is the BT instruction address.<br />As the 8-bit displacement is multiplied by two after sign-extension, the branch<br />destination can be located in the range from -256 to +254 bytes from the BT<br />instruction.<br /><br /><br />NoteIf the branch destination cannot be reached, the branch must be handled by using<br />BT in combination with a BRA or JMP instruction, for example.<br /><br />On some SH4 implementations a branch with a displacement value of zero does not<br />cause the pipeline I-stage to be stalled even if the branch is taken.  This can<br />be utilized for efficient conditional operations.<br /><br />On some SH2E implementations (SH7055) there is an FPU related hardware bug<br />which affects this instruction.  The recommended workaround is to use bt/s with<br />a nop in the delay slot.<br />See also documents \"sh2eoc.pdf\" and \"win_update_a.pdf\".<br /><br /><br />",
      "operation": "void BT (int d)\n{\n  int disp;\n  if ((d &amp; 0x80) == 0)\n    disp = (0x000000FF &amp; d);\n  else\n    disp = (0xFFFFFF00 | d);\n\n  if (T == 1)\n    PC = PC + 4 + (disp &lt;&lt; 1);\n  else\n    PC += 2;\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bt/s\tlabel",
      "abstract": "If T = 1: disp*2 + PC + 4 -> PC\nElse: nop\n(Delayed branch)",
      "code": "10001101dddddddd",
      "T": "-",
      "description": "This is a conditional branch instruction that references the T bit. The branch<br />is taken if T = 1, and not taken if T = 0.  The PC source value is the BT/S<br />instruction address. As the 8-bit displacement is multiplied by two after<br />sign-extension, the branch destination can be located in the range from -256 to<br />+254 bytes from the BT/S instruction.<br /><br /><br />NoteAs this is a delayed branch instruction, when the branch condition is satisfied,<br />the instruction following this instruction is executed before the branch<br />destination instruction.<br /><br />Interrupts are not accepted between this instruction and the following<br />instruction.<br /><br />If the following instruction is a branch instruction, it is identified as a slot<br />illegal instruction.<br /><br />If the branch destination cannot be reached, the branch must be handled by using<br />BT/S in combination with a BRA or JMP instruction, for example.<br /><br /><br />",
      "operation": "void BTS (int d)\n{\n  int disp;\n  unsigned temp;\n  temp = PC;\n\n  if ((d &amp; 0x80) == 0)\n    disp = (0x000000FF &amp; d);\n  else\n    disp = (0xFFFFFF00 | d);\n\n  if (T == 1)\n    PC = PC + 4 + (disp &lt;&lt; 1);\n  else\n    PC += 4;\n\n  Delay_Slot (temp + 2);\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 2,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 2,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bra\tlabel",
      "abstract": "disp*2 + PC + 4 -> PC\n(Delayed branch)",
      "code": "1010dddddddddddd",
      "T": "-",
      "description": "This is an unconditional branch instruction. The branch destination is address<br />(PC + 4 + displacement * 2). The PC source value is the BRA instruction address.<br />As the 12-bit displacement is multiplied by two after sign-extension, the branch<br />destination can be located in the range from -4096 to +4094 bytes from the BRA<br />instruction. If the branch destination cannot be reached, this branch can be<br />performed with a JMP instruction.<br /><br /><br />NoteAs this is a delayed branch instruction, the instruction following this<br />instruction is executed before the branch destination instruction.<br /><br />Interrupts are not accepted between this instruction and the following<br />instruction.<br /><br />If the following instruction is a branch instruction, it is identified as a slot<br />illegal instruction.<br /><br /><br />",
      "operation": "void BRA (int d)\n{\n  int disp;\n  unsigned int temp;\n  temp = PC;\n\n  if ((d &amp; 0x800) == 0)\n    disp = (0x00000FFF &amp; d);\n  else\n    disp = (0xFFFFF000 | d);\n\n  PC = PC + 4 + (disp &lt;&lt; 1);\n  Delay_Slot(temp + 2);\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 2,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 4,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "braf\tRm",
      "abstract": "Rm + PC + 4 -> PC\n(Delayed branch)",
      "code": "0000mmmm00100011",
      "T": "-",
      "description": "This is an unconditional branch instruction. The branch destination is address<br />(PC + 4 + Rm).<br /><br /><br />NoteAs this is a delayed branch instruction, the instruction following this<br />instruction is executed before the branch destination instruction.<br /><br />Interrupts are not accepted between this instruction and the following<br />instruction.<br /><br />If the following instruction is a branch instruction, it is identified as a slot<br />illegal instruction.<br /><br /><br />",
      "operation": "void BRAF (int m)\n{\n  unsigned int temp;\n  temp = PC;\n  PC = PC + 4 + R[m];\n  Delay_Slot (temp + 2);\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 2,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 2,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bsr\tlabel",
      "abstract": "PC + 4 -> PR, disp*2 + PC + 4 -> PC\n(Delayed branch)",
      "code": "1011dddddddddddd",
      "T": "-",
      "description": "Branches to address (PC + 4 + displacement * 2), and stores address (PC + 4) in<br />PR. The PC source value is the BSR instruction address.<br />As the 12-bit displacement is multiplied by two after sign-extension, the branch<br />destination can be located in the range from -4096 to +4094 bytes from the BSR<br />instruction. If the branch destination cannot be reached, this branch can be<br />performed with a JSR instruction.<br /><br /><br />NoteAs this is a delayed branch instruction, the instruction following this<br />instruction is executed before the branch destination instruction.<br /><br />Interrupts are not accepted between this instruction and the following<br />instruction.<br /><br />If the following instruction is a branch instruction, it is identified as a slot<br />illegal instruction.<br /><br /><br />",
      "operation": "void BSR (int d)\n{\n  int disp;\n  unsigned int temp;\n  temp = PC;\n\n  if ((d &amp; 0x800) == 0)\n    disp = (0x00000FFF &amp; d);\n  else\n    disp = (0xFFFFF000 | d);\n\n  PR = PC + 4;\n  PC = PC + 4 + (disp &lt;&lt; 1);\n  Delay_Slot (temp + 2);\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 2,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 4,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "bsrf\tRm",
      "abstract": "PC + 4 -> PR, Rm + PC + 4 -> PC\n(Delayed branch)",
      "code": "0000mmmm00000011",
      "T": "-",
      "description": "Branches to address (PC + 4 + Rm), and stores address (PC + 4) in PR. The PC<br />source value is the BSRF instruction address. The branch destination address is<br />the result of adding the 32-bit contents of general register Rm to PC + 4.<br /><br /><br />NoteAs this is a delayed branch instruction, the instruction following this<br />instruction is executed before the branch destination instruction.<br /><br />Interrupts are not accepted between this instruction and the following<br />instruction.<br /><br />If the following instruction is a branch instruction, it is identified as a slot<br />illegal instruction.<br /><br /><br />",
      "operation": "void BSRF (int m)\n{\n  unsigned int temp;\n  temp = PC;\n  PR = PC + 4;\n  PC = PC + 4 + R[m];\n  Delay_Slot (temp + 2);\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 2,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 2,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 4,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "jmp\t@Rm",
      "abstract": "Rm -> PC\n(Delayed branch)",
      "code": "0100mmmm00101011",
      "T": "-",
      "description": "Unconditionally makes a delayed branch to the address specified by Rm.<br /><br /><br />NoteAs this is a delayed branch instruction, the instruction following this<br />instruction is executed before the branch destination instruction.<br /><br />Interrupts are not accepted between this instruction and the following<br />instruction.<br /><br />If the following instruction is a branch instruction, it is identified as a slot<br />illegal instruction.<br /><br /><br />",
      "operation": "void JMP (int m)\n{\n  unsigned int temp;\n  temp = PC;\n  PC = R[m];\n  Delay_Slot (temp + 2);\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 2,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 2,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 4,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "jsr\t@Rm",
      "abstract": "PC + 4 -> PR, Rm -> PC\n(Delayed branch)",
      "code": "0100mmmm00001011",
      "T": "-",
      "description": "Makes a delayed branch to the subroutine procedure at the specified address<br />after execution of the following instruction. Return address (PC + 4) is saved<br />in PR, and a branch is made to the address indicated by general register Rm.<br />JSR is used in combination with RTS for subroutine procedure calls.<br /><br /><br />NoteAs this is a delayed branch instruction, the instruction following this<br />instruction is executed before the branch destination instruction.<br /><br />Interrupts are not accepted between this instruction and the following<br />instruction.<br /><br />If the following instruction is a branch instruction, it is identified as a slot<br />illegal instruction.<br /><br /><br />",
      "operation": "void JSR (int m)\n{\n  unsigned int temp;\n  temp = PC;\n  PR = PC + 4;\n  PC = R[m];\n  Delay_Slot (temp + 2);\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "jsr/n\t@Rm",
      "abstract": "PC + 2 -> PR, Rm -> PC",
      "code": "0100mmmm01001011",
      "T": "-",
      "description": "Branches to a subroutine procedure at the designated address. The contents of<br />PC are stored in PR and execution branches to the address indicated by the<br />contents of general register Rm as 32-bit data. The stored contents of PC<br />indicate the starting address of the second instruction after the present<br />instruction. This instruction is used with RTS as a subroutine procedure call.<br /><br /><br />NoteThis is not a delayed branch instruction.<br /><br /><br />",
      "operation": "void JSRN (int m)\n{\n  unsigned long temp;\n  temp = PC;\n  PR = PC + 2;\n  PC = R[m];\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 5,
      "SH2A.latency": 5,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "jsr/n\t@@(disp8,TBR)",
      "abstract": "PC + 2 -> PR, (disp*4 + TBR) -> PC",
      "code": "10000011dddddddd",
      "T": "-",
      "description": "Branches to a subroutine procedure at the designated address. The contents of PC<br />are stored in PR and execution branches to the address indicated by the address<br />read from memory address (disp × 4 + TBR). The stored contents of PC indicate<br />the starting address of the second instruction after the present instruction.<br />This instruction is used with RTS as a subroutine procedure call.<br /><br /><br />NoteThis is not a delayed branch instruction.<br /><br /><br />",
      "operation": "void JSRNM (int d)\n{\n  long disp = (0x000000FF &amp; d);\n  PR = PC + 2;\n  PC = Read_32 (TBR + (disp &lt;&lt; 2));\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 2,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 2,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "rts",
      "abstract": "PR -> PC\nDelayed branch",
      "code": "0000000000001011",
      "T": "-",
      "description": "Returns from a subroutine procedure by restoring the PC from PR. Processing<br />continues from the address indicated by the restored PC value. This instruction<br />can be used to return from a subroutine procedure called by a BSR or JSR<br />instruction to the source of the call.<br /><br /><br />NoteAs this is a delayed branch instruction, the instruction following this<br />instruction is executed before the branch destination instruction.<br /><br />Interrupts are not accepted between this instruction and the following<br />instruction. <br /><br />If the following instruction is a branch instruction, it is identified as a<br />slot illegal instruction.<br /><br />The instruction that restores PR must be executed before the RTS instruction.<br />This restore instruction cannot be in the RTS delay slot.<br /><br /><br />",
      "operation": "void RTS (void)\n{\n  unsigned int temp;\n  temp = PC;\n  PC = PR;\n  Delay_Slot (temp + 2);\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "rts/n",
      "abstract": "PR -> PC",
      "code": "0000000001101011",
      "T": "-",
      "description": "Performs a return from a subroutine procedure. That is, the PC is restored from<br />PR, and processing is resumed from the address indicated by the PC. This<br />instruction enables a return to be made from a subroutine procedure called by a<br />BSR or JSR instruction to the origin of the call.<br /><br /><br />NoteThis is not a delayed branch instruction.<br /><br /><br />",
      "operation": "void RTSN (void)\n{\n  PC = PR;\n}\n"
    },
    {
      "group": "Branch Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "rtv/n\tRm",
      "abstract": "Rm -> R0, PR -> PC",
      "code": "0000mmmm01111011",
      "T": "-",
      "description": "Performs a return from a subroutine procedure after a transfer from specified<br />general register Rm to R0. That is, after the Rm value is stored in R0, the PC<br />is restored from PR, and processing is resumed from the address indicated by the<br />PC. This instruction enables a return to be made from a subroutine procedure<br />called by a BSR or JSR instruction to the origin of the call.<br /><br /><br />NoteThis is not a delayed branch instruction.<br /><br /><br />",
      "operation": "void RTVN (int m)\n{\n  R[0] = R[m];\n  PC = PR;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "clrmac",
      "abstract": "0 -> MACH, 0 -> MACL",
      "code": "0000000000101000",
      "T": "-",
      "description": "Clears the MACH and MACL registers.<br /><br /><br />",
      "operation": "void CLRMAC (void)\n{\n  MACH = 0;\n  MACL = 0;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "clrs",
      "abstract": "0 -> S",
      "code": "0000000001001000",
      "T": "-",
      "description": "Clears the S bit to 0.<br /><br /><br />",
      "operation": "void CLRS (void)\n{\n  S = 0;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "clrt",
      "abstract": "0 -> T",
      "code": "0000000000001000",
      "T": "0",
      "description": "Clears the T bit.<br /><br /><br />",
      "operation": "void CLRT (void)\n{\n  T = 0;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "icbi\t@Rn",
      "abstract": "Invalidate instruction cache block indicated by logical address",
      "code": "0000nnnn11100011",
      "T": "-",
      "description": "Accesses the instruction cache at the effective address indicated by the<br />contents of Rn. When the cache is hit, the corresponding cache block is<br />invalidated (the V bit is cleared to 0). At this time, write-back is not<br />performed. No operation is performed in the case of a cache miss or access to<br />a non-cache area.<br /><br /><br />NoteWhen a program is overwriting RAM to modify its own execution, the corresponding<br />block of the instruction cache should be invalidated by the ICBI instruction.<br />This prevents execution of the program from the instruction cache, where the<br />non-overwritten instructions are stored.<br /><br /><br />",
      "operation": "void ICBI (int n)\n{\n  invalidate_instruction_cache_block (R[n]);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 6,
      "SH2A.latency": 5,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldbank\t@Rm,R0",
      "abstract": "(Specified register bank entry) -> R0",
      "code": "0100mmmm11100101",
      "T": "-",
      "description": "The register bank entry indicated by the contents of general register Rm is<br />transferred to general register R0. The register bank number and register stored<br />in the bank are specified by general register Rm.<br /><br /><br /><br />NoteThe architecture supports a maximum of 512 banks. However, the number of banks<br />differs depending on the product.<br /><br /><br />",
      "operation": "void LDBANK (int m)\n{\n  R[0] = Read_Bank_32 (R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 5,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 4,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 7,
      "SH4A.latency": 4,
      "SH2A": true,
      "SH2A.issue": 3,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc\tRm,SR",
      "abstract": "Rm -> SR",
      "code": "0100mmmm00001110",
      "T": "-",
      "description": "Stores the source operand in the control register SR.<br /><br /><br />NoteThis instruction is only usable in privileged mode. Issuing this instruction in<br />user mode will cause an illegal instruction exception.<br /><br /><br />",
      "operation": "void LDCSR (int m)\n{\n  #if SH1 || SH2 || SH2 || SH3\n  SR = R[m] &amp; 0x0FFF0FFF;\n\n  #elif SH2A\n  SR = R[m] &amp; 0x000063F3;\n\n  #elif SH4 || SH4A\n  SR = R[m] &amp; 0x700083F3;\n\n  #endif\n\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 3,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 3,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 7,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 4,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 9,
      "SH4A.latency": 4,
      "SH2A": true,
      "SH2A.issue": 5,
      "SH2A.latency": 4,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc.l\t@Rm+,SR",
      "abstract": "(Rm) -> SR, Rm+4 -> Rm",
      "code": "0100mmmm00000111",
      "T": "-",
      "description": "Stores the source operand in the control register SR.<br /><br /><br />NoteThis instruction is only usable in privileged mode. Issuing this instruction in<br />user mode will cause an illegal instruction exception.<br /><br /><br />",
      "operation": "void LDCMSR (int m)\n{\n  #if SH1 || SH2 || SH2 || SH3\n  SR = Read_32 (R[m]) &amp; 0x0FFF0FFF;\n\n  #elif SH2A\n  SR = Read_32 (R[m]) &amp; 0x000063F3;\n\n  #elif SH4 || SH4A\n  SR = Read_32 (R[m]) &amp; 0x700083F3;\n\n  #endif\n\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc\tRm,TBR",
      "abstract": "Rm -> TBR",
      "code": "0100mmmm01001010",
      "T": "-",
      "description": "Stores a source operand in control register TBR.<br /><br /><br />",
      "operation": "void LDCTBR (int m)\n{\n  TBR = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 3,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc\tRm,GBR",
      "abstract": "Rm -> GBR",
      "code": "0100mmmm00011110",
      "T": "-",
      "description": "Stores a source operand in control register GBR.<br /><br /><br />NoteThis instruction can also be issued in user mode.<br /><br /><br />",
      "operation": "void LDCGBR (int m)\n{\n  GBR = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 3,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 3,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 3,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc.l\t@Rm+,GBR",
      "abstract": "(Rm) -> GBR, Rm+4 -> Rm",
      "code": "0100mmmm00010111",
      "T": "-",
      "description": "Stores a source operand in control register GBR.<br /><br /><br />NoteThis instruction can also be issued in user mode.<br /><br /><br />",
      "operation": "void LDCMGBR (int m)\n{\n  GBR = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc\tRm,VBR",
      "abstract": "Rm -> VBR",
      "code": "0100mmmm00101110",
      "T": "-",
      "description": "Stores a source operand in control register VBR.<br /><br /><br />",
      "operation": "void LDCVBR (int m)\n{\n  VBR = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 3,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 3,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc.l\t@Rm+,VBR",
      "abstract": "(Rm) -> VBR, Rm+4 -> Rm",
      "code": "0100mmmm00100111",
      "T": "-",
      "description": "Stores a source operand in control register VBR.<br /><br /><br />",
      "operation": "void LDCMVBR (int m)\n{\n  VBR = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "ldc\tRm,MOD",
      "abstract": "Rm -> MOD",
      "code": "0100mmmm01011110",
      "T": "-",
      "description": "Stores a source operand in control register MOD.<br /><br /><br />NoteOn the SH-DSP the latency of this instruction is 1 cycle.<br /><br /><br />",
      "operation": "void LDCMOD (int m)\n{\n  MOD = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "ldc.l\t@Rm+,MOD",
      "abstract": "(Rm) -> MOD, Rm+4 -> Rm",
      "code": "0100mmmm01010111",
      "T": "-",
      "description": "Stores a source operand in control register MOD.<br /><br /><br />NoteOn the SH-DSP the latency of this instruction is 3 cycles.<br /><br /><br />",
      "operation": "void LDCMMOD (int m)\n{\n  MOD = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "ldc\tRm,RE",
      "abstract": "Rm -> RE",
      "code": "0100mmmm01111110",
      "T": "-",
      "description": "Stores a source operand in control register RE.<br /><br /><br />NoteOn the SH-DSP the latency of this instruction is 1 cycle.<br /><br /><br />",
      "operation": "void LDCRE (int m)\n{\n  RE = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "ldc.l\t@Rm+,RE",
      "abstract": "(Rm) -> RE, Rm+4 -> Rm",
      "code": "0100mmmm01110111",
      "T": "-",
      "description": "Stores a source operand in control register RE.<br /><br /><br />NoteOn the SH-DSP the latency of this instruction is 3 cycles.<br /><br /><br />",
      "operation": "void LDCMRE (int m)\n{\n  RE = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "ldc\tRm,RS",
      "abstract": "Rm -> RS",
      "code": "0100mmmm01101110",
      "T": "-",
      "description": "Stores a source operand in control register RS.<br /><br /><br />NoteOn the SH-DSP the latency of this instruction is 1 cycle.<br /><br /><br />",
      "operation": "void LDCRS (int m)\n{\n  RS = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "ldc.l\t@Rm+,RS",
      "abstract": "(Rm) -> RS, Rm+4 -> Rm",
      "code": "0100mmmm01100111",
      "T": "-",
      "description": "Stores a source operand in control register RS.<br /><br /><br />NoteOn the SH-DSP the latency of this instruction is 3 cycles.<br /><br /><br />",
      "operation": "void LDCMRS (int m)\n{\n  RS = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 4,
      "SH4A.latency": 4,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc\tRm,SGR",
      "abstract": "Rm -> SGR",
      "code": "0100mmmm00111010",
      "T": "-",
      "description": "Stores a source operand in control register SGR.<br /><br /><br />NoteNot sure whether it is also available on SH4.<br />It is not marked as new instruction for SH4A but is also not listed in SH4<br />manuals.<br /><br /><br />",
      "operation": "void LDCSGR (int m)\n{\n  SGR = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 4,
      "SH4A.latency": 4,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc.l\t@Rm+,SGR",
      "abstract": "(Rm) -> SGR, Rm+4 -> Rm",
      "code": "0100mmmm00110110",
      "T": "-",
      "description": "Stores a source operand in control register SGR.<br /><br /><br />NoteNot sure whether it is also available on SH4.<br />It is not marked as new instruction for SH4A but is also not listed in SH4<br />manuals.<br /><br /><br />",
      "operation": "void LDCMSGR (int m)\n{\n  SGR = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc\tRm,SSR",
      "abstract": "Rm -> SSR",
      "code": "0100mmmm00111110",
      "T": "-",
      "description": "Stores a source operand in control register SSR.<br /><br /><br />",
      "operation": "void LDCSSR (int m)\n{\n  SSR = R[m],\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc.l\t@Rm+,SSR",
      "abstract": "(Rm) -> SSR, Rm+4 -> Rm",
      "code": "0100mmmm00110111",
      "T": "-",
      "description": "Stores a source operand in control register SSR.<br /><br /><br />",
      "operation": "void LDCMSSR (int m)\n{\n  SSR = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 3,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc\tRm,SPC",
      "abstract": "Rm -> SPC",
      "code": "0100mmmm01001110",
      "T": "-",
      "description": "Stores a source operand in control register SPC.<br /><br /><br />",
      "operation": "void LDCSPC (int m)\n{\n  SPC = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc.l\t@Rm+,SPC",
      "abstract": "(Rm) -> SPC, Rm+4 -> Rm",
      "code": "0100mmmm01000111",
      "T": "-",
      "description": "Stores a source operand in control register SPC.<br /><br /><br />",
      "operation": "void LDCMSPC (int m)\n{\n  SPC = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 4,
      "SH4A.latency": 4,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc\tRm,DBR",
      "abstract": "Rm -> DBR",
      "code": "0100mmmm11110110",
      "T": "-",
      "description": "Stores a source operand in control register DBR.<br /><br /><br />",
      "operation": "void LDCDBR (int m)\n{\n  DBR = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 4,
      "SH4A.latency": 4,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc.l\t@Rm+,DBR",
      "abstract": "(Rm) -> DBR, Rm+4 -> Rm",
      "code": "0100mmmm11110110",
      "T": "-",
      "description": "Stores a source operand in control register DBR.<br /><br /><br />",
      "operation": "void LDCMDBR (int m)\n{\n  DBR = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc\tRm,Rn_BANK",
      "abstract": "Rm -> Rn_BANK (n = 0-7)",
      "code": "0100mmmm1nnn1110",
      "T": "-",
      "description": "Stores a source operand in banked general register.<br />Rn_BANK0 is accessed when the RB bit in the SR register is 1, and Rn_BANK1 is<br />accessed when this bit is 0.<br /><br /><br />",
      "operation": "void LDCRn_BANK (int m)\n{\n  Rn_BANK = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldc.l\t@Rm+,Rn_BANK",
      "abstract": "(Rm) -> Rn_BANK, Rm+4 -> Rm",
      "code": "0100mmmm1nnn0111",
      "T": "-",
      "description": "Stores a source operand in banked general register.<br />Rn_BANK0 is accessed when the RB bit in the SR register is 1, and Rn_BANK1 is<br />accessed when this bit is 0.<br /><br /><br />",
      "operation": "void LDCMRn_BANK (int m)\n{\n  Rn_BANK = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 3,
      "format": "ldre\t@(disp,PC)",
      "abstract": "disp*2 + PC -> RE",
      "code": "10001110dddddddd",
      "T": "-",
      "description": "Stores the effective address of the source operand in the repeat end register<br />RE. The effective address is an address specified by PC + displacement. The PC<br />is the address four bytes after this instruction. The 8-bit displacement is<br />sign-extended and doubled. Consequently, the relative interval from the branch<br />destination is -256 to +254 bytes.<br /><br /><br />NoteThe effective address value designated for the RE reregister is different from<br />the actual repeat end address. Refer to RS and RE Design Rules, for more<br />information.<br /><br />When this instruction is arranged immediately after the delayed<br />branch instruction, PC becomes the \"first address +2\" of the branch destination.<br /><br />On the SH-DSP the latency of this instruction is 1 cycle.<br /><br /><br />",
      "operation": "void LDRE (int d)\n{\n  long disp;\n\n  if ((d &amp; 0x80) == 0)\n    disp = (0x000000FF &amp; (long)d);\n  else\n    disp = (0xFFFFFF00 | (long)d);\n\n  RE = PC + (disp &lt;&lt; 1);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 3,
      "format": "ldrs\t@(disp,PC)",
      "abstract": "disp*2 + PC -> RS",
      "code": "10001100dddddddd",
      "T": "-",
      "description": "Stores the effective address of the source operand in the repeat start register<br />RS. The effective address is an address specified by PC + displacement. The PC<br />is the address four bytes after this instruction. The 8-bit displacement is<br />sign-extended and doubled. Consequently, the relative interval from the branch<br />destination is -256 to +254 bytes.<br /><br /><br />NoteWhen the instructions of the repeat (loop) program are below 3, the effective<br />address value designated for the RS register is different from the actual repeat<br />start address. Refer to \"RS and RE setting rule\", for more information. If this<br /><br />instruction is arranged immediately after the delayed branch instruction, the PC<br />becomes \"the first address +2\" of the branch destination.<br /><br />On the SH-DSP the latency of this instruction is 1 cycle.<br /><br /><br />",
      "operation": "void LDRS (int d)\n{\n  long disp;\n\n  if ((d &amp; 0x80) == 0)\n    disp = (0x000000FF &amp; (long)d);\n  else\n    disp = (0xFFFFFF00 | (long)d);\n\n  RS = PC + (disp &lt;&lt; 1);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "lds\tRm,MACH",
      "abstract": "Rm -> MACH",
      "code": "0100mmmm00001010",
      "T": "-",
      "description": "Stores the source operand into the system register MACH.<br /><br /><br />NoteOn SH1, only the lower 10 bits are stored in MACH.<br /><br />On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of the LDS to MAC* is 4 cycles.   When an LDS to MAC* is followed by<br />MAC.W/MAC.L, the latency of the LDS to MAC* is 1 cycle.<br /><br /><br />",
      "operation": "void LDSMACH (int m)\n{\n  MACH = R[m];\n\n  #if SH1\n  if ((MACH &amp; 0x00000200) == 0)\n    MACH &amp;= 0x000003FF; \n  else\n    MACH |= 0xFFFFFC00;\n  #endif\n\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "lds.l\t@Rm+,MACH",
      "abstract": "(Rm) -> MACH, Rm+4 -> Rm",
      "code": "0100mmmm00000110",
      "T": "-",
      "description": "Stores the source operand into the system register MACH.<br /><br /><br />NoteOn SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of the LDS to MAC* is 4 cycles.   When an LDS to MAC* is followed by<br />MAC.W/MAC.L, the latency of the LDS to MAC* is 1 cycle.<br /><br /><br />",
      "operation": "void LDSMMACH (int m)\n{\n  MACH = Read_32 (R[m]);\n\n  #if SH1\n  if ((MACH &amp; 0x00000200) == 0)\n    MACH &amp;= 0x000003FF; \n  else\n    MACH |= 0xFFFFFC00;\n  #endif\n\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "lds\tRm,MACL",
      "abstract": "Rm -> MACL",
      "code": "0100mmmm00011010",
      "T": "-",
      "description": "Stores the source operand into the system register MACL.<br /><br /><br />NoteOn SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of the LDS to MAC* is 4 cycles.   When an LDS to MAC* is followed by<br />MAC.W/MAC.L, the latency of the LDS to MAC* is 1 cycle.<br /><br /><br />",
      "operation": "void LDSMACL (int m)\n{\n  MACL = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "lds.l\t@Rm+,MACL",
      "abstract": "(Rm) -> MACL, Rm+4 -> Rm",
      "code": "0100mmmm00010110",
      "T": "-",
      "description": "Stores the source operand into the system register MACL.<br /><br /><br />NoteOn SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of the LDS to MAC* is 4 cycles.   When an LDS to MAC* is followed by<br />MAC.W/MAC.L, the latency of the LDS to MAC* is 1 cycle.<br /><br /><br />",
      "operation": "void LDSMMACL (int m)\n{\n  MACL = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "lds\tRm,PR",
      "abstract": "Rm -> PR",
      "code": "0100mmmm00101010",
      "T": "-",
      "description": "Stores the source operand into the system register PR.<br /><br /><br />",
      "operation": "void LDSPR (int m)\n{\n  PR = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "lds.l\t@Rm+,PR",
      "abstract": "(Rm) -> PR, Rm+4 -> Rm",
      "code": "0100mmmm00100110",
      "T": "-",
      "description": "Stores the source operand into the system register PR.<br /><br /><br />",
      "operation": "void LDSMPR (int m)\n{\n  PR = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "lds\tRm,DSR",
      "abstract": "Rm -> DSR",
      "code": "0100mmmm01101010",
      "T": "-",
      "description": "Stores the source operand into the DSP register DSR.<br /><br /><br />",
      "operation": "void LDSDSR (int m)\n{\n  DSR = R[m] &amp; 0x0000000F;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "lds.l\t@Rm+,DSR",
      "abstract": "(Rm) -> DSR, Rm+4 -> Rm",
      "code": "0100mmmm01100110",
      "T": "-",
      "description": "Stores the source operand into the DSP register DSR.<br /><br /><br />NoteOn the SH-DSP the latency of this instruction is 1 cycle.<br /><br /><br />",
      "operation": "void LDSMDSR (int m)\n{\n  DSR = Read_32 (R[m]) &amp; 0x0000000F;\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "lds\tRm,A0",
      "abstract": "Rm -> A0",
      "code": "0100mmmm01110110",
      "T": "-",
      "description": "Stores the source operand into the DSP register A0.  The MSB of the data is<br />copied into A0G.<br /><br /><br />",
      "operation": "void LDSA0 (int m)\n{\n  A0 = R[m];\n\n  if ((A0 &amp; 0x80000000) == 0)\n    A0G = 0x00;\n  else\n    A0G = 0xFF;\n\n  PC+=2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "lds.l\t@Rm+,A0",
      "abstract": "(Rm) -> A0, Rm+4 -> Rm",
      "code": "0100mmmm01110110",
      "T": "-",
      "description": "Stores the source operand into the DSP register A0.  The MSB of the data is<br />copied into A0G.<br /><br /><br />",
      "operation": "void LDSMA0 (int m)\n{\n  A0 = Read_32 (R[m]);\n\n  if ((A0 &amp; 0x80000000) == 0)\n    A0G = 0x00;\n  else\n    A0G = 0xFF;\n\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "lds\tRm,X0",
      "abstract": "Rm -> X0",
      "code": "0100mmmm10001010",
      "T": "-",
      "description": "Stores the source operand into the DSP register X0.<br /><br /><br />",
      "operation": "void LDSX0 (int m)\n{\n  X0 = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "lds.l\t@Rm+,X0",
      "abstract": "(Rm) -> X0, Rm+4 -> Rm",
      "code": "0100nnnn10000110",
      "T": "-",
      "description": "Stores the source operand into the DSP register X0.<br /><br /><br />",
      "operation": "void LDSMX0 (int m)\n{\n  X0 = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "lds\tRm,X1",
      "abstract": "Rm -> X1",
      "code": "0100mmmm10011010",
      "T": "-",
      "description": "Stores the source operand into the DSP register X1.<br /><br /><br />",
      "operation": "void LDSX1 (int m)\n{\n  X1 = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "lds.l\t@Rm+,X1",
      "abstract": "(Rm) -> X1, Rm+4 -> Rm",
      "code": "0100nnnn10010110",
      "T": "-",
      "description": "Stores the source operand into the DSP register X1.<br /><br /><br />",
      "operation": "void LDSMX1 (int m)\n{\n  X1 = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "lds\tRm,Y0",
      "abstract": "Rm -> Y0",
      "code": "0100mmmm10101010",
      "T": "-",
      "description": "Stores the source operand into the DSP register Y0.<br /><br /><br />",
      "operation": "void LDSY0 (int m)\n{\n  Y0 = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "lds.l\t@Rm+,Y0",
      "abstract": "(Rm) -> Y0, Rm+4 -> Rm",
      "code": "0100nnnn10100110",
      "T": "-",
      "description": "Stores the source operand into the DSP register Y0.<br /><br /><br />",
      "operation": "void LDSMY0 (int m)\n{\n  Y0 = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "lds\tRm,Y1",
      "abstract": "Rm -> Y1",
      "code": "0100mmmm10111010",
      "T": "-",
      "description": "Stores the source operand into the DSP register Y1.<br /><br /><br />",
      "operation": "void LDSY1 (int m)\n{\n  Y1 = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "lds.l\t@Rm+,Y1",
      "abstract": "(Rm) -> Y1, Rm+4 -> Rm",
      "code": "0100nnnn10110110",
      "T": "-",
      "description": "Stores the source operand into the DSP register Y1.<br /><br /><br />",
      "operation": "void LDSMY1 (int m)\n{\n  Y1 = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ldtbl",
      "abstract": "PTEH/PTEL -> TLB",
      "code": "0000000000111000",
      "T": "-",
      "description": "Loads the contents of the PTEH/PTEL registers into the TLB (translation<br />lookaside buffer) specified by MMUCR.URC (random counter field in the MMC<br />control register).<br /><br />LDTLB is a privileged instruction, and can only be used in privileged mode. Use of this<br />instruction in user mode will cause an illegal instruction exception.<br /><br /><br />NoteAs this instruction loads the contents of the PTEH/PTEL registers into a TLB, it<br />should be used either with the MMU disabled, or in the P1 or P2 virtual space<br />with the MMU enabled (see the MMU section of the applicable hardware manual for<br />details).<br /><br />After this instruction is issued, there must be at least one instruction between<br />the LDTLB instruction and issuance of an instruction relating to address to the<br />P0, U0, and P3 areas (i.e. BRAF, BSRF, JMP, JSR, RTS, or RTE).<br /><br />If the instruction is issued in an exception handler, it should be at least two<br />instructions prior to an RTE instruction that terminates the handler.<br /><br /><br />",
      "operation": "void LDTLB (void)\n{\n  #if SH3\n  TLB_tag = PTEH;\n  TLB_data = PTEL;\n\n  #elif SH4\n  TLB[MMUCR.URC].ASID = PTEH &amp; 0x000000FF;\n  TLB[MMUCR.URC].VPN = (PTEH &amp; 0xFFFFFC00) &gt;&gt; 10;\n  TLB[MMUCR.URC].PPN = (PTEH &amp; 0x1FFFFC00) &gt;&gt; 10;\n  TLB[MMUCR.URC].SZ = (PTEL &amp; 0x00000080) &gt;&gt; 6 | (PTEL &amp; 0x00000010) &gt;&gt; 4;\n  TLB[MMUCR.URC].SH = (PTEH &amp; 0x00000002) &gt;&gt; 1;\n  TLB[MMUCR.URC].PR = (PTEH &amp; 0x00000060) &gt;&gt; 5;\n  TLB[MMUCR.URC].WT = (PTEH &amp; 0x00000001);\n  TLB[MMUCR.URC].C = (PTEH &amp; 0x00000008) &gt;&gt; 3;\n  TLB[MMUCR.URC].D = (PTEH &amp; 0x00000004) &gt;&gt; 2;\n  TLB[MMUCR.URC].V = (PTEH &amp; 0x00000100) &gt;&gt; 8;\n\n  #endif\n\n  PC += 2;\n}\n\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "movca.l\tR0,@Rn",
      "abstract": "R0 -> (Rn) (without fetching cache block)",
      "code": "0000nnnn11000011",
      "T": "-",
      "description": "Stores the contents of general register R0 in the memory location indicated by<br />effective address Rn. This instruction differs from other store instructions as<br />follows.<br /><br />If write-back is selected for the accessed memory, and a cache miss occurs, the<br />cache block will be allocated but an R0 data write will be performed to that<br />cache block without performing a block read. Other cache block contents are<br />undefined.<br /><br /><br />",
      "operation": "void MOVCAL (int n)\n{\n  if (is_write_back_memory (R[n]) &amp;&amp; look_up_in_operand_cache (R[n]) == MISS)\n    allocate_operand_cache_block (R[n]);\n\n  Write_32 (R[n], R[0]);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "nop",
      "abstract": "No operation",
      "code": "0000000000001001",
      "T": "-",
      "description": "nts the program counter (PC), advancing the processing flow to execution<br />of the next instruction.<br /><br /><br />",
      "operation": "void NOP (void)\n{\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ocbi\t@Rn",
      "abstract": "Invalidate operand cache block",
      "code": "0000nnnn10010011",
      "T": "-",
      "description": "Accesses data using the contents indicated by effective address Rn. In the case<br />of a hit in the cache, the corresponding cache block is invalidated (the V bit<br />is cleared to 0). If there is unwritten information (U bit = 1), write-back is<br />not performed even if write-back mode is selected. No operation is performed in<br />the case of a cache miss or an access to a non-cache area.<br /><br /><br />",
      "operation": "void OCBI (int n)\n{\n  invalidate_operand_cache_block (R[n]);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ocbp\t@Rn",
      "abstract": "Write back and invalidate operand cache block",
      "code": "0000nnnn10100011",
      "T": "-",
      "description": "Accesses data using the contents indicated by effective address Rn. If the cache<br />is hit and there is unwritten information (U bit = 1), the corresponding cache<br />block is written back to external memory and that block is invalidated (the V<br />bit is cleared to 0). If there is no unwritten information (U bit = 0), the<br />block is simply invalidated. No operation is performed in the case of a cache<br />miss or an access to a non-cache area.<br /><br /><br />",
      "operation": "void OCBP (int n)\n{\n  if (is_dirty_block (R[n]))\n    write_back (R[n])\n\n  invalidate_operand_cache_block (R[n]);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ocbwb\t@Rn",
      "abstract": "Write back operand cache block",
      "code": "0000nnnn10110011",
      "T": "-",
      "description": "Accesses data using the contents indicated by effective address Rn. If the cache<br />is hit and there is unwritten information (U bit = 1), the corresponding cache<br />block is written back to external memory and that block is cleaned (the U bit<br />is cleared to 0). In other cases (i.e. in the case of a cache miss or an access<br />to a non-cache area, or if the block is already clean), no operation is<br />performed.<br /><br /><br />",
      "operation": "void OCBWB (int n)\n{\n  if (is_dirty_block (R[n]))\n    write_back (R[n]);\n\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "pref\t@Rn",
      "abstract": "(Rn) -> operand cache",
      "code": "0000nnnn10000011",
      "T": "-",
      "description": "SH4 and SH4A<br /><br />Reads a 32-byte data block starting at a 32-byte boundary into the operand<br />cache. The lower 5 bits of the address specified by Rn are masked to zero.<br /><br />This instruction is also used to trigger a Store Queue write-back operation if<br />the specified address points to the Store Queue area.  For more information<br />refer to Store Queues in the manual.<br /><br /><br />SH3 and SH2A<br /><br />Reads a 16-byte data block into the cache.  The address specified by Rn should<br />be on 32-bit boundary.  No address related error is detected in this<br />instruction. In case of an error, the instruction operates as NOP.<br /><br /><br />NoteOn products with no cache, this instruction is handled as a NOP instruction.<br /><br /><br />",
      "operation": "void PREF (int n)\n{\n  prefetch_operand_cache_block (R[n]);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "prefi\t@Rn",
      "abstract": "Reads 32-byte instruction block into instruction cache",
      "code": "0000nnnn11010011",
      "T": "-",
      "description": "Reads a 32-byte block of data starting at a 32-byte boundary within the<br />instruction cache. The lower 5 bits of the address specified by Rn are masked<br />by zeroes.<br /><br />This instruction does not generate data address error and MMU exceptions. In the<br />event of an error, the PREFI instruction is treated as an NOP (no operation)<br />instruction.<br /><br />When the address to be prefetched is missing from UTLB or is protected, the<br />PREFI instruction is treated as an NOP instruction and a TLB exception does not<br />occur.<br /><br /><br />NoteThis instruction can be used before the SLEEP command is issued to prefetch<br />instructions for execution on return from the SLEEP state.<br /><br /><br />",
      "operation": "void PREFI (int n)\n{\n  prefetch_instruction_cache_block (R[n]);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 9,
      "SH2A.latency": 8,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "resbank",
      "abstract": "Bank -> R0 to R14, GBR, MACH, MACL, PR",
      "code": "0000000001011011",
      "T": "-",
      "description": "Restores the last register saved to a register bank.<br /><br /><br />NoteThe issue cycle count is 19 when a bank overflow has occured and the registers<br />are restored from the stack.<br /><br /><br />",
      "operation": "void RESBANK (void)\n{\n  int m;  // Number of register bank to which a save was last performed.\n\n  if (BO == 0)\n  {\n    PR = Register_Bank[m].PR_BANK;\n    GBR = Register_Bank[m].GBR_BANK;\n    MACL = Register_Bank[m].MACL_BANK;\n    MACH = Register_Bank[m].MACH_BANK;\n\n    for (int i = 0; i <= 14; i++)\n      R[i] = Register_Bank[m].R_BANK[i];\n  }\n  else\n  {\n    for (int i = 0; i <= 14; i++)\n    {\n      R[i] = Read_32 (R[15]);\n      R[15] += 4;\n    }\n\n    PR = Read_32 (R[15]);\n    R[15] += 4;\n    GBR = Read_32 (R[15]);\n    R[15] += 4;\n    MACH = Read_32 (R[15]);\n    R[15] += 4;\n    MACL = Read_32 (R[15]);\n    R[15] += 4;\n  }\n\n  PC += 2;\n}"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 4,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 4,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 4,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 5,
      "SH4.latency": 5,
      "SH4A": true,
      "SH4A.issue": 5,
      "SH4A.latency": 4,
      "SH2A": true,
      "SH2A.issue": 6,
      "SH2A.latency": 5,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "rte",
      "abstract": "Delayed branch\nSH1*,SH2*: stack area -> PC/SR\nSH3*,SH4*: SSR/SPC -> SR/PC",
      "code": "0000000000101011",
      "T": "-",
      "description": "Returns from an exception or interrupt handling routine by restoring the PC and<br />SR values.  Program execution continues from the address specified<br />by the restored PC value.<br /><br />On SH3 and SH4 the PC and SR values are restored from SPC and SSR.  The SR value<br />accessed by the instruction in the RTE delay slot is the value restored from SSR<br />by the RTE instruction. The SR and MD values defined prior to RTE execution are<br />used to fetch the instruction in the RTE delay slot.<br /><br />On SH1, SH2 and SH2A the PC and SR values are from the stack (R15).<br /><br /><br />NoteAs this is a delayed branch instruction, the instruction following the RTE<br />instruction is executed before the branch destination instruction.<br /><br />Interrupts are not accepted between this instruction and the following<br />instruction. An exception must not be generated by the instruction in this<br />instruction's delay slot. If the following instruction is a branch instruction,<br />it is identified as a slot illegal instruction.<br /><br />If this instruction is located in the delay slot immediately following a delayed<br />branch instruction, it is identified as a slot illegal instruction.<br /><br />On SH3 and SH4 the SR value accessed by the instruction in the RTE delay slot is<br />the value restored from SSR by the RTE instruction. The SR and MD values defined<br />prior to RTE execution are used to fetch the instruction in the RTE delay slot.<br /><br /><br />",
      "operation": "void RTE (void)\n{\n  unsigned long temp = PC;\n\n  #if SH1 || SH2 || SH2A\n  PC = Read_32 (R[15]);\n  R[15] += 4;\n  SR = Read_32 (R[15]) &amp; 0x000063F3;\n  R[15] += 4;\n\n  #elif SH3 || SH4 || SH4A\n  SR = SSR;\n  PC = SPC;\n\n  #endif\n\n  Delay_Slot (temp + 2);\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 3,
      "format": "setrc\tRn",
      "abstract": "Rn[11:0] -> RC (SR[27:16])",
      "code": "0100mmmm00010100",
      "T": "-",
      "description": "Sets the repeat count to the SR register's RC counter. The bottom 12 bits of the<br />general register Rn are used as the repeat count. <br />Set repeat control flags to RF1, RF0 bits of the SR register. Use of the SETRC<br />instruction is subject to any limitations. Refer to the DSP Repeat (Loop)<br />Control section of the manual for more information.<br /><br /><br /><br />NoteOn the SH-DSP the latency of this instruction is 1 cycle.<br /><br /><br />",
      "operation": "void SETRC (int m)\n{\n  long temp = (R[m] &amp; 0x00000FFF) &lt;&lt; 16;\n  SR &amp;= 0x00000FF3;\n  SR |= temp;\n  RF1 = Repeat_Control_Flag1;\n  RF0 = Repeat_Control_Flag0;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 3,
      "format": "setrc\t#imm",
      "abstract": "imm -> RC (SR[23:16]), 0 -> SR[27:24]",
      "code": "10000010iiiiiiii",
      "T": "-",
      "description": "Sets the repeat count to the SR register's RC counter. The 8-bit immediate value<br />is zero-extended and used as the repeat count. <br />Set repeat control flags to RF1, RF0 bits of the SR register. Use of the SETRC<br />instruction is subject to any limitations. Refer to the DSP Repeat (Loop)<br />Control section of the manual for more information.<br /><br /><br /><br />NoteOn the SH-DSP the latency of this instruction is 1 cycle.<br /><br /><br />",
      "operation": "void SETRCI (int i)\n{\n  long temp = ((long)i &amp; 0x000000FF) &lt;&lt; 16;\n  SR &amp;= 0x00000FFF;\n  SR |= temp;\n  RF1 = Repeat_Control_Flag1;\n  RF0 = Repeat_Control_Flag0;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sets",
      "abstract": "1 -> T",
      "code": "0000000000011000",
      "T": "-",
      "description": "Sets the S bit to 1.<br /><br /><br />",
      "operation": "void SETS (void)\n{\n  S = 1;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sett",
      "abstract": "1 -> T",
      "code": "0000000000011000",
      "T": "-",
      "description": "Sets the T bit to 1.<br /><br /><br />",
      "operation": "void SETT (void)\n{\n  T = 1;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 3,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 3,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 4,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 4,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": null,
      "SH4A.latency": null,
      "SH2A": true,
      "SH2A.issue": 5,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sleep",
      "abstract": "Sleep or standby",
      "code": "0000000000011011",
      "T": "-",
      "description": "Places the CPU in the power-down state.<br /><br />In power-down mode, the CPU retains its internal state, but immediately stops<br />executing instructions and waits for an interrupt request. When it receives an<br />interrupt request, the CPU exits the power-down state.<br /><br />SLEEP is a privileged instruction, and can only be used in privileged mode. Use<br />of this instruction in user mode will cause an illegal instruction exception.<br /><br /><br />NoteSLEEP performance depends on the standby control register (STBCR). See<br />Power-Down Modes in the target product's hardware manual, for details.<br /><br />The number of cycles given is for the transition to sleep mode. \"ud\" means<br />the number of cycles is undefined.<br /><br />Some SH4 implementations have a hardware bug which restricts the instructions<br />that should follow this instruction for safe operation.  There are two<br />recommended workarounds:<br />Put 8 NOP instructions following the SLEEP instruction.<br />Put 5 \"OR R0,R0\" instructions following the SLEEP instruction<br /><br />For more information see the document \"tnsh7456ae.pdf\".<br /><br /><br />",
      "operation": "void SLEEP (void)\n{\n  Sleep_standby();\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 7,
      "SH2A.latency": 6,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stbank\tR0,@Rn",
      "abstract": "R0 -> (specified register bank entry)",
      "code": "0100nnnn11100001",
      "T": "-",
      "description": "R0 is transferred to the register bank entry indicated by the contents of<br />general register Rn. The register bank number and register stored in the bank<br />are specified by general register Rn.<br /><br /><br /><br />NoteThe architecture supports a maximum of 512 banks. However, the number of banks<br />differs depending on the product.<br /><br /><br />",
      "operation": "void STBANK (int n)\n{\n  Write_Bank_32 (R[n], R[0])\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc\tSR,Rn",
      "abstract": "SR -> Rn",
      "code": "0000nnnn00000010",
      "T": "-",
      "description": "Stores control register SR in the destination.<br /><br /><br />NoteThis instruction is only usable in privileged mode. Issuing this instruction in<br />user mode will cause an illegal instruction exception. <br /><br /><br />",
      "operation": "void STCSR (int n)\n{\n  R[n] = SR;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 2,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc.l\tSR,@-Rn",
      "abstract": "Rn-4 -> Rn, SR -> (Rn)",
      "code": "0100nnnn00000011",
      "T": "-",
      "description": "Stores control register SR in the destination.<br /><br /><br />NoteThis instruction is only usable in privileged mode. Issuing this instruction in<br />user mode will cause an illegal instruction exception. <br /><br /><br />",
      "operation": "void STCMSR (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], SR);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc\tTBR,Rn",
      "abstract": "TBR -> Rn",
      "code": "0000nnnn01001010",
      "T": "-",
      "description": "Stores control register TBR in the destination.<br /><br /><br />",
      "operation": "void STCTBR (int n)\n{\n  R[n] = TBR;\n  PC += 2;\n}\n\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc\tGBR,Rn",
      "abstract": "GBR -> Rn",
      "code": "0000nnnn00010010",
      "T": "-",
      "description": "Stores control register GBR in the destination.<br /><br /><br />NoteThis instruction can also be issued in user mode. <br /><br /><br />",
      "operation": "STCGBR (int n)\n{\n  R[n] = GBR;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 2,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc.l\tGBR,@-Rn",
      "abstract": "Rn-4 -> Rn, GBR -> (Rn)",
      "code": "0100nnnn00010011",
      "T": "-",
      "description": "Stores control register GBR in the destination.<br /><br /><br />NoteThis instruction can also be issued in user mode. <br /><br /><br />",
      "operation": "void STCMGBR (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], GBR);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc\tVBR,Rn",
      "abstract": "VBR -> Rn",
      "code": "0000nnnn00100010",
      "T": "-",
      "description": "Stores control register VBR in the destination.<br /><br /><br />",
      "operation": "void STCVBR (int n)\n{\n  R[n] = VBR;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 2,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 2,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc.l\tVBR,@-Rn",
      "abstract": "Rn-4 -> Rn, VBR -> (Rn)",
      "code": "0100nnnn00100011",
      "T": "-",
      "description": "Stores control register VBR in the destination.<br /><br /><br />",
      "operation": "void STCMVBR (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], VBR);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "stc\tMOD,Rn",
      "abstract": "MOD -> Rn",
      "code": "0000nnnn01010010",
      "T": "-",
      "description": "Stores control register MOD in the destination.<br /><br /><br />",
      "operation": "void STCMOD (int n)\n{\n  R[n] = MOD;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "stc.l\tMOD,@-Rn",
      "abstract": "Rn-4 -> Rn, MOD -> (Rn)",
      "code": "0100nnnn01010011",
      "T": "-",
      "description": "Stores control register MOD in the destination.<br /><br /><br />NoteOn the SH-DSP the latency of this instruction is 2 cycles.<br /><br /><br />",
      "operation": "void STCMMOD (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], MOD);\n  PC += 2;\n}\n\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "stc\tRE,Rn",
      "abstract": "RE -> Rn",
      "code": "0000nnnn01110010",
      "T": "-",
      "description": "Stores control register RE in the destination.<br /><br /><br />",
      "operation": "void STCRE (int n)\n{\n  R[n] = RE;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "stc.l\tRE,@-Rn",
      "abstract": "Rn-4 -> Rn, RE -> (Rn)",
      "code": "0100nnnn01110011",
      "T": "-",
      "description": "Stores control register RE in the destination.<br /><br /><br />NoteOn the SH-DSP the latency of this instruction is 2 cycles.<br /><br /><br />",
      "operation": "void STCMRE (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], RE);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "stc\tRS,Rn",
      "abstract": "RS -> Rn",
      "code": "0000nnnn01100010",
      "T": "-",
      "description": "Stores control register RS in the destination.<br /><br /><br />",
      "operation": "void STCRS (int n)\n{\n  R[n] = RS;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "stc.l\tRS,@-Rn",
      "abstract": "Rn-4 -> Rn, RS -> (Rn)",
      "code": "0100nnnn01100011",
      "T": "-",
      "description": "Stores control register RS in the destination.<br /><br /><br />NoteOn the SH-DSP the latency of this instruction is 2 cycles.<br /><br /><br />",
      "operation": "void STCMRS (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], RS);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 3,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc\tSGR,Rn",
      "abstract": "SGR -> Rn",
      "code": "0000nnnn00111010",
      "T": "-",
      "description": "Stores control register SGR in the destination.<br /><br /><br />",
      "operation": "void STCSGR (int n)\n{\n  R[n] = SGR;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 3,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc.l\tSGR,@-Rn",
      "abstract": "Rn-4 -> Rn, SGR -> (Rn)",
      "code": "0100nnnn00110010",
      "T": "-",
      "description": "Stores control register SGR in the destination.<br /><br /><br />",
      "operation": "void STCMSGR (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], SGR);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc\tSSR,Rn",
      "abstract": "SSR -> Rn",
      "code": "0000nnnn00110010",
      "T": "-",
      "description": "Stores control register SSR in the destination.<br /><br /><br />",
      "operation": "void STCSSR (int n)\n{\n  R[n] = SSR;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc.l\tSSR,@-Rn",
      "abstract": "Rn-4 -> Rn, SSR -> (Rn)",
      "code": "0100nnnn00110011",
      "T": "-",
      "description": "Stores control register SSR in the destination.<br /><br /><br />",
      "operation": "void STCMSSR (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], SSR);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc\tSPC,Rn",
      "abstract": "SPC -> Rn",
      "code": "0000nnnn01000010",
      "T": "-",
      "description": "Stores control register SPC in the destination.<br /><br /><br />",
      "operation": "void STCSPC (int n)\n{\n  R[n] = SPC;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": null,
      "SH3.latency": null,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc.l\tSPC,@-Rn",
      "abstract": "Rn-4 -> Rn, SPC -> (Rn)",
      "code": "0100nnnn01000011",
      "T": "-",
      "description": "Stores control register SPC in the destination.<br /><br /><br />",
      "operation": "void STCMSPC (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], SPC);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc\tDBR,Rn",
      "abstract": "DBR -> Rn",
      "code": "0000nnnn11111010",
      "T": "-",
      "description": "Stores control register DBR in the destination.<br /><br /><br />",
      "operation": "void STCDBR (int n)\n{\n  R[n] = DBR;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc.l\tDBR,@-Rn",
      "abstract": "Rn-4 -> Rn, DBR -> (Rn)",
      "code": "0100nnnn11110010",
      "T": "-",
      "description": "Stores control register DBR in the destination.<br /><br /><br />",
      "operation": "void STCMDBR (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], DBR);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc\tRm_BANK,Rn",
      "abstract": "Rm_BANK -> Rn (m = 0-7)",
      "code": "0000nnnn1mmm0010",
      "T": "-",
      "description": "Stores a banked general register in the destination. Rn_BANK0 is accessed when<br />the RB bit in the SR register is 1, and Rn_BANK1 is accessed when this bit is 0. <br /><br /><br />",
      "operation": "void STCRm_BANK (int n)\n{\n  R[n] = Rm_BANK;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 2,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "stc.l\tRm_BANK,@-Rn",
      "abstract": "Rn-4 -> Rn, Rm_BANK -> (Rn) (m = 0-7)",
      "code": "0100nnnn1mmm0011",
      "T": "-",
      "description": "Stores a banked general register in the destination. Rn_BANK0 is accessed when<br />the RB bit in the SR register is 1, and Rn_BANK1 is accessed when this bit is 0. <br /><br /><br />",
      "operation": "void STCMRm_BANK (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], Rm_BANK);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sts\tMACH,Rn",
      "abstract": "MACH -> Rn",
      "code": "0000nnnn00001010",
      "T": "-",
      "description": "Stores system register MACH in the destination.<br /><br /><br />NoteOn SH1, the value of bit 9 is transferred to and stored in the higher 22 bits<br />(bits 31 to 10) of the destination.<br /><br />On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of the LDS to MAC* is 4 cycles.<br /><br /><br />",
      "operation": "void STSMACH (int n)\n{\n  R[n] = MACH;\n\n  #if SH1\n  if ((R[n] &amp; 0x00000200) == 0)\n    R[n] &amp;= 0x000003FF; \n  else\n    R[n] |= 0xFFFFFC00;\n\n  #endif\n\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sts.l\tMACH,@-Rn",
      "abstract": "Rn-4 -> Rn, MACH -> (Rn)",
      "code": "0100nnnn00000010",
      "T": "-",
      "description": "Stores system register MACH in the destination.<br /><br /><br />NoteOn SH1, the value of bit 9 is transferred to and stored in the higher 22 bits<br />(bits 31 to 10) of the destination.<br /><br />On SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of the LDS to MAC* is 4 cycles.<br /><br /><br />",
      "operation": "void STSMMACH (int n)\n{\n  R[n] -= 4;\n\n  #if SH1\n  if ((MACH &amp; 0x00000200) == 0)\n    Write_32 (R[n], MACH &amp; 0x000003FF);\n  else\n    Write_32 (R[n], MACH | 0xFFFFFC00)\n\n  #else\n  Write_32 (R[n], MACH);\n\n  #endif\n\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sts\tMACL,Rn",
      "abstract": "MACL -> Rn",
      "code": "0000nnnn00011010",
      "T": "-",
      "description": "Stores system register MACL in the destination.<br /><br /><br />NoteOn SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of the LDS to MAC* is 4 cycles.<br /><br /><br />",
      "operation": "void STSMACL (int n)\n{\n  R[n] = MACL;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sts.l\tMACL,@-Rn",
      "abstract": "Rn-4 -> Rn, MACL -> (Rn)",
      "code": "0100nnnn00010010",
      "T": "-",
      "description": "Stores system register MACL in the destination.<br /><br /><br />NoteOn SH4, when an LDS to MAC* is followed by an STS.L MAC*,@-Rn instruction, the<br />latency of the LDS to MAC* is 4 cycles.<br /><br /><br />",
      "operation": "void STSMMACL (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], MACL);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sts\tPR,Rn",
      "abstract": "PR -> Rn",
      "code": "0000nnnn00101010",
      "T": "-",
      "description": "Stores system register PR in the destination.<br /><br /><br />",
      "operation": "void STSPR (int n)\n{\n  R[n] = PR;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 1,
      "SH1.latency": 1,
      "SH2": true,
      "SH2.issue": 1,
      "SH2.latency": 1,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 1,
      "SH3.latency": 1,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sts.l\tPR,@-Rn",
      "abstract": "Rn-4 -> Rn, PR -> (Rn)",
      "code": "0100nnnn00100010",
      "T": "-",
      "description": "Stores system register PR in the destination.<br /><br /><br />",
      "operation": "void STSMPR (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], PR);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "sts\tDSR,Rn",
      "abstract": "DSR -> Rn",
      "code": "0000nnnn01101010",
      "T": "-",
      "description": "Stores DSP register DSR in the destination.<br /><br /><br />",
      "operation": "void STSDSR (int n)\n{\n  R[n] = DSR;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "sts.l\tDSR,@-Rn",
      "abstract": "Rn-4 -> Rn, DSR -> (Rn)",
      "code": "0100nnnn01100010",
      "T": "-",
      "description": "Stores DSP register DSR in the destination.<br /><br /><br />",
      "operation": "void STSMDSR (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], DSR);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "sts\tA0,Rn",
      "abstract": "A0 -> Rn",
      "code": "0000nnnn01111010",
      "T": "-",
      "description": "Stores DSP register A0 in the destination.<br /><br /><br />",
      "operation": "void STSA0 (int n)\n{\n  R[n] = A0;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "sts.l\tA0,@-Rn",
      "abstract": "Rn-4 -> Rn, A0 -> (Rn)",
      "code": "0100nnnn01100010",
      "T": "-",
      "description": "Stores DSP register A0 in the destination.<br /><br /><br />",
      "operation": "void STSMA0 (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], A0);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "sts\tX0,Rn",
      "abstract": "X0 -> Rn",
      "code": "0000nnnn10001010",
      "T": "-",
      "description": "Stores DSP register X0 in the destination.<br /><br /><br />",
      "operation": "void STSX0 (int n)\n{\n  R[n] = X0;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "sts.l\tX0,@-Rn",
      "abstract": "Rn-4 -> Rn, X0 -> (Rn)",
      "code": "0100nnnn10000010",
      "T": "-",
      "description": "Stores DSP register X0 in the destination.<br /><br /><br />",
      "operation": "void STSMX0 (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], X0);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "sts\tX1,Rn",
      "abstract": "X1 -> Rn",
      "code": "0000nnnn10011010",
      "T": "-",
      "description": "Stores DSP register X1 in the destination.<br /><br /><br />",
      "operation": "void STSX1 (int n)\n{\n  R[n] = X1;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "sts.l\tX1,@-Rn",
      "abstract": "Rn-4 -> Rn, X1 -> (Rn)",
      "code": "0100nnnn10010010",
      "T": "-",
      "description": "Stores DSP register X1 in the destination.<br /><br /><br />",
      "operation": "void STSMX1 (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], X1);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "sts\tY0,Rn",
      "abstract": "Y0 -> Rn",
      "code": "0000nnnn10101010",
      "T": "-",
      "description": "Stores DSP register Y0 in the destination.<br /><br /><br />",
      "operation": "void STSY0 (int n)\n{\n  R[n] = Y0;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "sts.l\tY0,@-Rn",
      "abstract": "Rn-4 -> Rn, Y0 -> (Rn)",
      "code": "0100nnnn10100010",
      "T": "-",
      "description": "Stores DSP register Y0 in the destination.<br /><br /><br />",
      "operation": "void STSMY0 (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], Y0);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "sts\tY1,Rn",
      "abstract": "Y1 -> Rn",
      "code": "0000nnnn10111010",
      "T": "-",
      "description": "Stores DSP register Y1 in the destination.<br /><br /><br />",
      "operation": "void STSY1 (int n)\n{\n  R[n] = Y1;\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "sts.l\tY1,@-Rn",
      "abstract": "Rn-4 -> Rn, Y1 -> (Rn)",
      "code": "0100nnnn10110010",
      "T": "-",
      "description": "Stores DSP register Y1 in the destination.<br /><br /><br />",
      "operation": "void STSMY1 (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], Y1);\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": null,
      "SH4A.latency": null,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "synco",
      "abstract": "Prevents the next instruction from being issued until instructions issued before this instruction has been completed.",
      "code": "0000000010101011",
      "T": "-",
      "description": "This instruction is used to synchronize data operations. When this instruction<br />is executed, the subsequent bus accesses are not executed until the execution of<br />all preceding bus accesses has been completed.<br /><br /><br />NoteThe SYNCO instruction can not guarantee the ordering of receipt timing which is<br />notified by the memory-mapped peripheral resources through the method except bus<br />when the register is changed by bus accesses. Refer to the description of each<br />registers to guarantee this ordering.<br /><br />Common example usages are:<br />Ordering access to memory areas which are shared with other memory users<br />Flushing all write buffers<br />Stopping memory-access operations from merging and becoming ineffective<br />Waiting for the completion of cache-control instructions<br /><br /><br />",
      "operation": "void SYNCO (void)\n{\n  synchronize_data_operaiton ();\n  PC += 2;\n}\n"
    },
    {
      "group": "System Control Instructions",
      "SH1": true,
      "SH1.issue": 2,
      "SH1.latency": 8,
      "SH2": true,
      "SH2.issue": 2,
      "SH2.latency": 8,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": true,
      "SH3.issue": 2,
      "SH3.latency": 8,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 7,
      "SH4.latency": 7,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 5,
      "SH2A.latency": 6,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "trapa\t#imm",
      "abstract": "SH1*,SH2*: PC/SR -> stack area, (imm*4 + VBR) -> PC\nSH3*,SH4*: PC/SR -> SPC/SSR, imm*4 -> TRA, 0x160 -> EXPEVT, VBR + 0x0100 -> PC",
      "code": "11000011iiiiiiii",
      "T": "-",
      "description": "Starts trap exception handling.<br /><br />SH1, SH2 and SH2A:<br /><br />The PC and SR values are stored on the stack, and the program branches to an<br />address specified by the vector. The vector is a memory address obtained by<br />zero-extending the 8-bit immediate data and then quadrupling it. The PC is the<br />start address of the next instruction. TRAPA and RTE are both used together for<br />system calls.<br /><br /><br />SH3, SH4 and SH4A:<br /><br />The values of (PC + 2), SR, and R15 are saved to SPC, SSR and SGR, and 8-bit<br />immediate data is stored in the TRA register (bits 9 to 2). The processor mode<br />is switched to privileged mode (the MD bit in SR is set to 1), and the BL bit<br />and RB bit in SR are set to 1.  As a result, exception and interrupt requests<br />are masked (not accepted), and the BANK1 registers (R0_BANK1 to R7_BANK1) are<br />selected. Exception code 0x160 is written to the EXPEVT register (bits 11 to 0).<br />The program branches to address (VBR + 0x00000100), indicated by the sum of the<br />VBR register contents and offset 0x00000100.<br /><br /><br />NoteSome SH4 implementations have a hardware bug which restricts the instructions<br />that should follow this instruction for safe operation.  There are two<br />recommended workarounds:<br />Put 8 NOP instructions following the TRAPA instruction.<br />Put 5 \"OR R0,R0\" instructions following the TRAPA instruction<br /><br />For more information see the document \"tnsh7456ae.pdf\".<br /><br />Some SH2E implementations (SH7055) have an FPU related hardware bug which<br />affects this instruction.  The recommended workaround is to align the addresses<br />of trapa handlers to 4 bytes and not to place any FPU or FPU related<br />instructions at addresses 4n + 2 in the handler.<br /><br /><br />",
      "operation": "void TRAPA (int i)\n{\n  int imm = (0x000000FF &amp; i);\n\n  #if SH1 || SH2 || SH2A\n  R[15] -= 4;\n  Write_32 (R[15], SR);\n  R[15] -= 4;\n  Write_32 (R[15], PC + 2);\n  PC = Read_32 (VBR + (imm &lt;&lt; 2));\n\n  #elif SH3 || SH4 || SH4A\n  TRA = imm &lt;&lt; 2;\n  SSR = SR;\n  SPC = PC + 2;\n  SGR = R15;\n  SR.MD = 1;\n  SR.BL = 1;\n  SR.RB = 1;\n  EXPEVT = 0x00000160;\n  PC = VBR + 0x00000100;\n\n  #endif\n}\n"
    },
    {
      "group": "32 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov\tFRm,FRn",
      "abstract": "FRm -> FRn",
      "code": "1111nnnnmmmm1100",
      "T": "-",
      "description": "Transfers FRm contents to FRn.<br /><br /><br />",
      "operation": "void FMOV (int m, int n)\n{\n  FR[n] = FR[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "32 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.s\t@Rm,FRn",
      "abstract": "(Rm) -> FRn",
      "code": "1111nnnnmmmm1000",
      "T": "-",
      "description": "Transfers contents of memory at address indicated by Rm to FRn.<br /><br /><br />",
      "operation": "void FMOV_LOAD (int m, int n)\n{\n  FR[n] = Read_32 (R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "32 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.s\tFRm,@Rn",
      "abstract": "FRm -> (Rn)",
      "code": "1111nnnnmmmm1010",
      "T": "-",
      "description": "Transfers FRm contents to memory at address indicated by Rn.<br /><br /><br />",
      "operation": "void FMOV_STORE (int m, int n)\n{\n  Write_32 (R[n], FR[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "32 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.s\t@Rm+,FRn",
      "abstract": "(Rm) -> FRn, Rm+4 -> Rm",
      "code": "1111nnnnmmmm1001",
      "T": "-",
      "description": "Transfers contents of memory at address indicated by Rm to FRn, and adds 4 to<br />Rm.<br /><br /><br />",
      "operation": "void FMOV_RESTORE (int m, int n)\n{\n  FR[n] = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "32 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.s\tFRm,@-Rn",
      "abstract": "Rn-4 -> Rn, FRm -> (Rn)",
      "code": "1111nnnnmmmm1011",
      "T": "-",
      "description": "Subtracts 4 from Rn, and transfers FRm contents to memory at address indicated<br />by resulting Rn value.<br /><br /><br />",
      "operation": "void FMOV_SAVE (int m, int n)\n{\n  Write_32 (R[n] - 4, FR[m]);\n  R[n] -= 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "32 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.s\t@(R0,Rm),FRn",
      "abstract": "(R0 + Rm) -> FRn",
      "code": "1111nnnnmmmm0110",
      "T": "-",
      "description": "Transfers contents of memory at address indicated by (R0 + Rm) to FRn.<br /><br /><br />",
      "operation": "void FMOV_INDEX_LOAD (int m, int n)\n{\n  FR[n] = Read_32 (R[0] + R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "32 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.s\tFRm,@(R0,Rn)",
      "abstract": "FRm -> (R0 + Rn)",
      "code": "1111nnnnmmmm0111",
      "T": "-",
      "description": "Transfers FRm contents to memory at address indicated by (R0 + Rn).<br /><br /><br />",
      "operation": "void FMOV_INDEX_STORE (int m, int n)\n{\n  Write_32 (R[0] + R[n], FR[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "32 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.s\t@(disp12,Rm),FRn",
      "abstract": "(disp*4 + Rm) -> FRn",
      "code": "0011nnnnmmmm0001 0111dddddddddddd",
      "T": "-",
      "description": "Transfers memory contents at the address indicated by (disp + Rn) to FRn.<br /><br /><br />",
      "operation": "void FMOV_INDEX_DISP12_LOAD (int m, int n, int d)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  FR[n] = Read_32 (R[m] + (disp &lt;&lt; 2));\n  PC += 4;\n}\n"
    },
    {
      "group": "32 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.s\tFRm,@(disp12,Rn)",
      "abstract": "FRm -> (disp*4 + Rn)",
      "code": "0011nnnnmmmm0001 0011dddddddddddd",
      "T": "-",
      "description": "Transfers FRm contents to memory at the address indicated by (disp + Rn).<br /><br /><br />",
      "operation": "void FMOV_INDEX_DISP12_STORE (int m, int n, int d)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  Write_32 (R[n] + (disp &lt;&lt; 2), FR[m]);\n  PC += 4;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov\tDRm,DRn",
      "abstract": "DRm -> DRn",
      "code": "1111nnn0mmm01100",
      "T": "-",
      "description": "Transfers DRm contents to DRn.<br /><br /><br />",
      "operation": "void FMOV_DR (int m, int n)\n{\n  DR[n &gt;&gt; 1] = DR[m &gt;&gt; 1];\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov\tDRm,XDn",
      "abstract": "DRm -> XDn",
      "code": "1111nnn1mmm01100",
      "T": "-",
      "description": "Transfers DRm contents to XDn.<br /><br /><br />",
      "operation": "void FMOV_DRXD (int m, int n)\n{\n  XD[n &gt;&gt; 1] = DR[m &gt;&gt; 1];\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov\tXDm,DRn",
      "abstract": "XDm -> DRn",
      "code": "1111nnn0mmm11100",
      "T": "-",
      "description": "Transfers XDm contents to DRn.<br /><br /><br />",
      "operation": "void FMOV_XDDR (int m, int n)\n{\n  DR[n &gt;&gt; 1] = XD[m &gt;&gt; 1];\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov\tXDm,XDn",
      "abstract": "XDm -> XDn",
      "code": "1111nnn1mmm11100",
      "T": "-",
      "description": "Transfers XDm contents to XDn.<br /><br /><br />",
      "operation": "void FMOV_XDXD (int m, int n)\n{\n  XD[n &gt;&gt; 1] = XD[m &gt;&gt; 1];\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\t@Rm,DRn",
      "abstract": "(Rm) -> DRn",
      "code": "1111nnn0mmmm1000",
      "T": "-",
      "description": "Transfers contents of memory at address indicated by Rm to DRn.<br /><br /><br />",
      "operation": "void FMOV_LOAD_DR (int m, int n)\n{\n  DR[n &gt;&gt; 1] = Read_64 (R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\t@Rm,XDn",
      "abstract": "(Rm) -> XDn",
      "code": "1111nnn1mmmm1000",
      "T": "-",
      "description": "Transfers contents of memory at address indicated by Rm to XDn.<br /><br /><br />",
      "operation": "void FMOV_LOAD_XD (int m, int n)\n{\n  XD[n &gt;&gt; 1] = Read_64 (R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\tDRm,@Rn",
      "abstract": "DRm -> (Rn)",
      "code": "1111nnnnmmm01010",
      "T": "-",
      "description": "Transfers DRm contents to memory at address indicated by Rn.<br /><br /><br />",
      "operation": "void FMOV_STORE_DR (int m, int n)\n{\n  Write_64 (R[n], DR[m &gt;&gt; 1]);\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\tXDm,@Rn",
      "abstract": "XDm -> (Rn)",
      "code": "1111nnnnmmm11010",
      "T": "-",
      "description": "Transfers contents of memory at address indicated by (R0 + Rm) to XDn.<br /><br /><br />",
      "operation": "void FMOV_STORE_XD (int m, int n)\n{\n  Write_64 (R[n], XD[m &gt;&gt; 1]);\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\t@Rm+,DRn",
      "abstract": "(Rm) -> DRn, Rm + 8 -> Rm",
      "code": "1111nnn0mmmm1001",
      "T": "-",
      "description": "Transfers contents of memory at address indicated by Rm to DRn, and adds 8 to<br />Rm.<br /><br /><br />",
      "operation": "void FMOV_RESTORE_DR (int m, int n)\n{\n  DR[n &gt;&gt; 1] = Read_64 (R[m]);\n  R[m] += 8;\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\t@Rm+,XDn",
      "abstract": "(Rm) -> XDn, Rm+8 -> Rm",
      "code": "1111nnn1mmmm1001",
      "T": "-",
      "description": "Transfers contents of memory at address indicated by Rm to XDn, and adds 8 to<br />Rm.<br /><br /><br />",
      "operation": "void FMOV_RESTORE_XD (int m, int n)\n{\n  XD[n &gt;&gt; 1] = Read_64 (R[m]);\n  R[m] += 8;\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\tDRm,@-Rn",
      "abstract": "Rn-8 -> Rn, DRm -> (Rn)",
      "code": "1111nnnnmmm01011",
      "T": "-",
      "description": "Subtracts 8 from Rn, and transfers DRm contents to memory at address indicated<br />by resulting Rn value.<br /><br /><br />",
      "operation": "void FMOV_SAVE_DR (int m, int n)\n{\n  Write_64 (R[n] - 8, DR[m &gt;&gt; 1]);\n  R[n] -= 8;\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\tXDm,@-Rn",
      "abstract": "Rn-8 -> Rn, (Rn) -> XDm",
      "code": "1111nnnnmmm11011",
      "T": "-",
      "description": "Subtracts 8 from Rn, and transfers XDm contents to memory at address indicated<br />by resulting Rn value.<br /><br /><br />",
      "operation": "void FMOV_SAVE_XD (int m, int n)\n{\n  Write_64 (R[n] - 8, XD[m &gt;&gt; 1]);\n  R[n] -= 8;\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\t@(R0,Rm),DRn",
      "abstract": "(R0 + Rm) -> DRn",
      "code": "1111nnn0mmmm0110",
      "T": "-",
      "description": "Transfers contents of memory at address indicated by (R0 + Rm) to DRn.<br /><br /><br />",
      "operation": "void FMOV_INDEX_LOAD_DR (int m, int n)\n{\n  DR[n &gt;&gt; 1] = Read_64 (R[0] + R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\t@(R0,Rm),XDn",
      "abstract": "(R0 + Rm) -> XDn",
      "code": "1111nnn1mmmm0110",
      "T": "-",
      "description": "Transfers contents of memory at address indicated by (R0 + Rm) to XDn.<br /><br /><br />",
      "operation": "void FMOV_INDEX_LOAD_XD (int m, int n)\n{\n  XD[n &gt;&gt; 1] = Read_64 (R[0] + R[m]);\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\tDRm,@(R0,Rn)",
      "abstract": "DRm -> (R0 + Rn)",
      "code": "1111nnnnmmm00111",
      "T": "-",
      "description": "Transfers DRm contents to memory at address indicated by (R0 + Rn).<br /><br /><br />",
      "operation": "void FMOV_INDEX_STORE_DR (int m, int n)\n{\n  Write_64 (R[0] + R[n], DR[m &gt;&gt; 1]);\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\tXDm,@(R0,Rn)",
      "abstract": "XDm -> (R0 + Rn)",
      "code": "1111nnnnmmm10111",
      "T": "-",
      "description": "Transfers XDm contents to memory at address indicated by (R0 + Rn).<br /><br /><br />",
      "operation": "void FMOV_INDEX_STORE_XD (int m, int n)\n{\n  Write_64 (R[0] + R[n], XD[m &gt;&gt; 1]);\n  PC += 2;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\t@(disp12,Rm),DRn",
      "abstract": "(disp*8 + Rm) -> DRn",
      "code": "0011nnn0mmmm0001 0111dddddddddddd",
      "T": "-",
      "description": "Transfers memory contents at the address indicated by (disp + Rn) to DRn.<br /><br /><br />",
      "operation": "void FMOV_INDEX_DISP12_LOAD_DR (int m, int n, int d)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  DR[n &gt;&gt; 1] = Read_64 (R[m] + (disp &lt;&lt; 3));\n  PC += 4;\n}\n"
    },
    {
      "group": "64 Bit Floating-Point Data Transfer Instructions (FPSCR.SZ = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmov.d\tDRm,@(disp12,Rn)",
      "abstract": "DRm -> (disp*8 + Rn)",
      "code": "0011nnnnmmm00001 0011dddddddddddd",
      "T": "-",
      "description": "Transfers DRm contents to memory at the address indicated by (disp + Rn).<br /><br /><br />",
      "operation": "void FMOV_INDEX_DISP12_STORE_DR (int m, int n, int d)\n{\n  long disp = (0x00000FFF &amp; (long)d);\n  Write_64 (R[n] + (disp &lt;&lt; 3), DR[m &gt;&gt; 1]);\n  PC += 4;\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fldi0\tFRn",
      "abstract": "0x00000000 -> FRn",
      "code": "1111nnnn10001101",
      "T": "-",
      "description": "When FPSCR.PR = 0, this instruction loads floating-point 0.0 (0x00000000) into<br />FRn.<br />If FPSCR.PR = 1, the instruction is handled as an illegal instruction.<br /><br /><br />",
      "operation": "void FLDI0 (int n)\n{\n  FR[n] = 0x00000000;\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fldi1\tFRn",
      "abstract": "0x3F800000 -> FRn",
      "code": "1111nnnn10011101",
      "T": "-",
      "description": "When FPSCR.PR = 0, this instruction loads floating-point 1.0 (0x3F800000) into<br />FRn.<br />If FPCSR.PR = 1, the instruction is handled as an illegal instruction.<br /><br /><br />",
      "operation": "void FLDI1 (int n)\n{\n  FR[n] = 0x3F800000;\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "flds\tFRm,FPUL",
      "abstract": "FRm -> FPUL",
      "code": "1111mmmm00011101",
      "T": "-",
      "description": "Transfers the contents of floating-point register FRm into system register FPUL.<br /><br /><br />",
      "operation": "void FLDS (int m)\n{\n  FPUL = FR[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fsts\tFPUL,FRn",
      "abstract": "FPUL -> FRn",
      "code": "1111nnnn00001101",
      "T": "-",
      "description": "Transfers the contents of system register FPUL to floating-point register FRn.<br /><br /><br />",
      "operation": "void FSTS (int n)\n{\n  FR[n] = FPUL;\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fabs\tFRn",
      "abstract": "FRn & 0x7FFFFFFF -> FRn",
      "code": "1111nnnn01011101",
      "T": "-",
      "description": "Clears the most significant bit of the contents of floating-point register FRn<br />to 0, and stores the result in FRn.<br /><br /><br />NoteThe cause and flag fields in FPSCR are not updated.<br /><br />A double-precision floating-point register DRn consists of a single-precision<br />floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is<br />the low part.  This instruction operates only on the high part and thus the<br />operation performed for double and single precision setting is the same.  It is<br />not necessary to adjust the FPSRC.PR setting before this instruction.<br /><br /><br />",
      "operation": "void FABS (int n)\n{\n  FR[n] = FR[n] &amp; 0x7FFFFFFFF;\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fneg\tFRn",
      "abstract": "FRn ^ 0x80000000 -> FRn",
      "code": "1111nnnn01001101",
      "T": "-",
      "description": "Inverts the most significant bit (sign bit) of the contents of floating-point<br />register FRn, and stores the result in FRn.<br /><br /><br />NoteThe cause and flag fields in FPSCR are not updated.<br /><br />A double-precision floating-point register DRn consists of a single-precision<br />floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is<br />the low part.  This instruction operates only on the high part and thus the<br />operation performed for double and single precision setting is the same.  It is<br />not necessary to adjust the FPSRC.PR setting before this instruction.<br /><br /><br />",
      "operation": "void FNEG (int n)\n{\n  FR[n] = -FR[n];\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fadd\tFRm,FRn",
      "abstract": "FRn + FRm -> FRn",
      "code": "1111nnnnmmmm0000",
      "T": "-",
      "description": "Arithmetically adds the two single-precision floating-point numbers in FRn and<br />FRm, and stores the result in FRn.<br /><br />When FPSCR.enable.I is set, an FPU exception trap is generated regardless of<br />whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU<br />exception traps are generated on actual generation by the FPU exception source<br />and on the satisfaction of certain special conditions that apply to this the<br />instruction. When an exception occurs, correct exception information is<br />reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate<br />processing should therefore be performed by software.<br />",
      "operation": "void FADD (int m, int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)\n    invalid (n);\n  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)\n    qnan (n);\n  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)\n    set_E ();\n  else\n    switch (data_type_of (m))\n    {\n    case NORM:\n      switch (data_type_of (n))\n      {\n      case NORM:\n        normal_faddsub (m, n, ADD);\n        break;\n      case PZERO:\n      case NZERO:\n        register_copy (m, n);\n        break;\n      default:\n        break;\n      }\n      break;\n\n    case PZERO:\n      switch (data_type_of (n))\n      {\n      case NZERO:\n        zero (n, 0);\n        break;\n      default:\n        break;\n      }\n      break;\n\n    case NZERO:\n      break;\n\n    case PINF:\n      switch (data_type_of (n))\n      {\n      case NINF:\n        invalid (n);\n        break;\n      default:\n        inf (n, 0);\n        break;\n      }\n      break;\n\n     case NINF:\n       switch (data_type_of (n))\n       {\n       case PINF:\n         invalid (n);\n         break;\n       default:\n         inf (n, 1);\n         break;\n       }\n       break;\n    }\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fsub\tFRm,FRn",
      "abstract": "FRn - FRm -> FRn",
      "code": "1111nnnnmmmm0001",
      "T": "-",
      "description": "Arithmetically subtracts the single-precision floating-point number in FRm from<br />the single-precision floating-point number in FRn, and stores the result in FRn.<br /><br />When FPSCR.enable.I is set, an FPU exception trap is generated regardless of<br />whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU<br />exception traps are generated on actual generation by the FPU exception source<br />and on the satisfaction of certain special conditions that apply to this the<br />instruction.  When an exception occurs, correct exception information is<br />reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate<br />processing should therefore be performed by software.<br />",
      "operation": "void FSUB (int m, int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)\n    invalid (n);\n  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)\n    qnan (n);\n  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)\n    set_E ();\n  else\n    switch (data_type_of (m))\n    {\n    case NORM:\n      switch (data_type_of (n))\n      {\n      case NORM:\n        normal_faddsub (m, n, SUB);\n        break;\n      case PZERO:\n      case NZERO:\n        register_copy (m, n);\n        FR[n] = -FR[n];\n        break;\n      default:\n        break;\n      }\n      break;\n\n    case PZERO:\n      break;\n\n    case NZERO:\n      switch (data_type_of (n))\n      {\n      case NZERO:\n        zero (n, 0);\n        break;\n      default:\n        break;\n      }\n      break;\n\n    case PINF:\n      switch (data_type_of (n))\n      {\n      case PINF:\n        invalid (n);\n        break;\n      default:\n        inf (n, 1);\n        break;\n      }\n      break;\n\n    case NINF:\n      switch (data_type_of (n))\n      {\n      case NINF:\n        invalid (n);\n        break;\n      default:\n        inf (n, 0);\n        break;\n      }\n      break;\n    }\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmul\tFRm,FRn",
      "abstract": "FRn * FRm -> FRn",
      "code": "1111nnnnmmmm0010",
      "T": "-",
      "description": "Arithmetically multiplies the two single-precision floating-point numbers in<br />FRn and FRm, and stores the result in FRn.<br /><br />When FPSCR.enable.I is set, an FPU exception trap is generated regardless of<br />whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU<br />exception traps are generated on actual generation by the FPU exception source<br />and on the satisfaction of certain special conditions that apply to this the<br />instruction. When an exception occurs, correct exception information is<br />reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate<br />processing should therefore be performed by software.<br />",
      "operation": "void FMUL (int m, int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)\n    invalid (n);\n  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)\n    qnan (n);\n  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)\n    set_E ();\n  else\n    switch (data_type_of (m))\n    {\n    case NORM:\n      switch (data_type_of (n))\n      {\n      case PZERO:\n      case NZERO:\n        zero (n, sign_of (m) ^ sign_of (n));\n        break;\n      case PINF:\n      case NINF:\n        inf (n, sign_of (m) ^ sign_of (n));\n        break;\n      default:\n        normal_fmul (m, n);\n        break;\n      }\n      break;\n\n    case PZERO:\n    case NZERO:\n      switch (data_type_of (n))\n      {\n      case PINF:\n      case NINF:\n        invalid (n);\n        break;\n      default: \n        zero (n,sign_of (m) ^ sign_of (n));\n        break;\n      }\n      break;\n\n    case PINF:\n    case NINF:\n      switch (data_type_of (n))\n      {\n      case PZERO:\n      case NZERO:\n        invalid (n);\n        break;\n      default:\n        inf (n, sign_of (m) ^ sign_of (n));\n        break\n      }\n      break;\n    }\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmac\tFR0,FRm,FRn",
      "abstract": "FR0 * FRm + FRn -> FRn",
      "code": "1111nnnnmmmm1110",
      "T": "-",
      "description": "Arithmetically multiplies the two single-precision floating-point numbers in<br />FR0 and FRm, arithmetically adds the contents of FRn, and stores the result in<br />FRn.<br /><br />When FPSCR.enable.I is set, an FPU exception trap is generated regardless of<br />whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU<br />exception traps are generated on actual generation by the FPU exception source<br />and on the satisfaction of certain special conditions that apply to this the<br />instruction.  When an exception occurs, correct exception information is<br />reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate<br />processing should therefore be performed by software.<br />",
      "operation": "void FMAC (int m, int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  if (FPSCR_PR == 1)\n    undefined_operation ();\n\n  else if (data_type_of (0) == sNaN\n           || data_type_of (m) == sNaN\n           || data_type_of (n) == sNaN)\n    invalid (n);\n\n  else if (data_type_of (0) == qNaN || data_type_of (m) == qNaN)\n    qnan (n);\n\n  else if (data_type_of (0) == DENORM || data_type_of (m) == DENORM)\n    set_E ();\n\n  else\n    switch (data_type_of (0))\n    {\n    case NORM:\n      switch (data_type_of (m))\n      {\n      case PZERO:\n      case NZERO:\n        switch (data_type_of (n))\n        {\n        case DENORM:\n          set_E ();\n          break;\n        case qNaN:\n          qnan (n);\n          break;\n        case PZERO:\n        case NZERO:\n          zero (n, sign_of (0) ^ sign_of (m) ^ sign_of (n));\n          break;\n        default:\n          break;\n        }\n\n      case PINF:\n      case NINF:\n        switch (data_type_of (n))\n        {\n        case DENORM:\n          set_E ();\n          break;\n        case qNaN:\n          qnan (n);\n          break;\n        case PINF:\n        case NINF:\n          if (sign_of (0) ^ sign_of (m) ^ sign_of (n))\n            invalid (n);\n          else\n            inf (n, sign_of (0) ^ sign_of (m));\n          break;\n        default:\n          inf (n, sign_of (0) ^ sign_of (m));\n          break;\n        }\n\n      case NORM:\n        switch (data_type_of (n))\n        {\n        case DENORM:\n          set_E ();\n          break;\n        case qNaN:\n          qnan (n);\n          break;\n        case PINF:\n        case NINF:\n          inf (n, sign_of (n));\n          break;\n        case PZERO:\n        case NZERO:\n        case NORM:\n          normal_fmac (m, n);\n          break;\n        }\n        break;\n\n      case PZERO:\n      case NZERO:\n        switch (data_type_of (m))\n        {\n        case PINF:\n        case NINF:\n          invalid (n);\n          break;\n        case PZERO:\n        case NZERO:\n        case NORM:\n          switch (data_type_of (n))\n          {\n          case DENORM:\n            set_E ();\n            break;\n          case qNaN:\n            qnan (n);\n            break;\n          case PZERO:\n          case NZERO:\n            zero (n, sign_of (0) ^ sign_of (m) ^ sign_of (n));\n            break;\n          default:\n            break;\n          }\n          break;\n        }\n        break;\n\n      case PINF:\n      case NINF:\n        switch (data_type_of (m))\n        {\n        case PZERO:\n        case NZERO:\n          invalid (n);\n          break;\n        default:\n          switch (data_type_of (n))\n          {\n          case DENORM:\n            set_E ();\n            break;\n          case qNaN:\n            qnan(n);\n            break;\n          default:\n            inf (n, sign_of (0) ^ sign_of (m) ^ sign_of (n));\n            break\n          }\n          break;\n        }\n        break;\n      }\n    }\n}\n\nvoid normal_fmac (int m, int n)\n{\n  union\n  {\n    int double x;\n    int l[4];\n  } dstx, tmpx;\n\n  float dstf, srcf;\n\n  if (data_type_of (n) == PZERO || data_type_of (n) == NZERO)\n    srcf = 0.0; // flush denormalized value\n  else\n    srcf = FR[n];\n\n  tmpx.x = FR[0]; // convert single to int double\n  tmpx.x *= FR[m]; //exact product\n  dstx.x = tmpx.x + srcf;\n\n  if ((dstx.x == srcf &amp;&amp; tmpx.x != 0.0)\n      || (dstx.x == tmpx.x &amp;&amp; srcf != 0.0))\n  {\n    set_I ();\n    if (sign_of (0) ^ sign_of (m) ^ sign_of (n))\n    {\n      dstx.l[3] -= 1; // correct result\n      if (dstx.l[3] == 0xFFFFFFFF)\n        dstx.l[2] -= 1;\n      if (dstx.l[2] == 0xFFFFFFFF)\n        dstx.l[1] -= 1;\n      if (dstx.l[1] == 0xFFFFFFFF)\n        dstx.l[0] -= 1;\n    }\n    else\n      dstx.l[3] |= 1\n  }\n\n  if ((dstx.l[1] &amp; 0x01FFFFFF) || dstx.l[2] || dstx.l[3])\n    set_I();\n\n  if(FPSCR_RM == 1)\n  {\n    dstx.l[1] &amp;= 0xFE000000; // round toward zero\n    dstx.l[2] = 0x00000000;\n    dstx.l[3] = 0x00000000;\n  }\n\n  dstf = dstx.x;\n  check_single_exception (&amp;FR[n], dstf);\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fdiv\tFRm,FRn",
      "abstract": "FRn / FRm -> FRn",
      "code": "1111nnnnmmmm0011",
      "T": "-",
      "description": "Arithmetically divides the single-precision floating-point number in FRn by the<br />single-precision floating-point number in FRm, and stores the result in FRn.<br /><br />When FPSCR.enable.I is set, an FPU exception trap is generated regardless of<br />whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU<br />exception traps are generated on actual generation by the FPU exception source<br />and on the satisfaction of certain special conditions that apply to this the<br />instruction. When an exception occurs, correct exception information is<br />reflected in FPSCR.cause and FPSCR.flag and FRn is not updated. Appropriate<br />processing should therefore be performed by software.<br />",
      "operation": "void FDIV (int m, int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)\n    invalid (n);\n  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)\n    qnan (n);\n  else\n    switch (data_type_of (m))\n    {\n    case NORM:\n      switch (data_type_of (n))\n      {\n      case PINF:\n      case NINF:\n        inf (n, sign_of (m) ^ sign_of (n));\n        break;\n      case PZERO:\n      case NZERO:\n        zero (n, sign_of (m) ^ sign_of (n));\n        break;\n      case DENORM:\n        set_E ();\n        break;\n      default:\n        normal_fdiv_single (m, n);\n        break;\n      }\n      break;\n\n    case PZERO:\n      switch (data_type_of (n))\n      {\n      case PZERO:\n      case NZERO:\n        invalid (n);\n        break;\n      case PINF:\n      case NINF:\n        break;\n      default:\n        dz (n, sign_of (m) ^ sign_of (n));\n        break;\n      }\n      break;\n\n    case NZERO:\n      switch (data_type_of (n))\n      {\n      case PZERO:\n      case NZERO:\n        invalid (n);\n        break;\n      case PINF:\n        inf (n, 1);\n        break;\n      case NINF:\n        inf (n, 0);\n        break;\n      default:\n        dz (FR[n], sign_of (m) ^ sign_of (n));\n        break;\n      }\n      break;\n\n    case DENORM:\n      set_E ();\n      break;\n\n    case PINF:\n    case NINF:\n      switch (data_type_of (n))\n      {\n      case DENORM:\n        set_E ();\n        break;\n      case PINF:\n      case NINF:\n        invalid (n);\n        break;\n      default:\n        zero (n, sign_of (m) ^ sign_of (n));\n        break;\n      }\n      break;\n    }\n}\n\nvoid normal_fdiv_single (int m, int n)\n{\n  union\n  {\n    float f;\n    int l;\n  } dstf, tmpf;\n\n  union\n  {\n    double d;\n    int l[2];\n  } tmpd;\n\n  tmpf.f = FR[n];   // save destination value\n  dstf.f /= FR[m];  // round toward nearest or even\n  tmpd.d = dstf.f;  // convert single to double\n  tmpd.d *= FR[m];\n\n  if (tmpf.f != tmpd.d)\n    set_I ();\n  if (tmpf.f &lt; tmpd.d &amp;&amp; FPSCR_RM == 1)\n    dstf.l -= 1; // round toward zero\n\n  check_single_exception (&amp;FR[n], dstf.f);\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 3,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fsqrt\tFRn",
      "abstract": "sqrt (FRn) -> FRn",
      "code": "1111nnnn01101101",
      "T": "-",
      "description": "Finds the arithmetical square root of the single-precision floating-point number<br />in FRn, and stores the result in FRn.<br /><br />When FPSCR.enable.I is set, an FPU exception trap is generated regardless of<br />whether or not an exception has occurred. When an exception occurs, correct<br />exception information is reflected in FPSCR.cause and FPSCR.flag and FRn is not<br />updated. Appropriate processing should therefore be performed by software.<br />",
      "operation": "void FSQRT (int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  switch (data_type_of (n))\n  {\n  case NORM:\n    if (sign_of (n) == 0)\n      normal_fsqrt_single (n);\n    else\n      invalid (n);\n    break;\n\n  case DENORM:\n    if (sign_of (n) == 0)\n      set_E ();\n    else\n      invalid (n);\n    break;\n\n  case PZERO:\n  case NZERO:\n  case PINF:\n    break;\n\n  case NINF:\n    invalid (n);\n    break;\n\n  case qNAN:\n    qnan (n);\n    break;\n\n  case sNAN:\n    invalid (n);\n    break;\n  }\n}\n\nvoid normal_fsqrt_single (int n)\n{\n  union\n  {\n    float f;\n    int l;\n  } dstf, tmpf;\n\n  union\n  {\n    double d;\n    int l[2];\n  } tmpd;\n\n  tmpf.f = FR[n];         // save destination value\n  dstf.f = sqrt (FR[n]);  // round toward nearest or even\n  tmpd.d = dstf.f;        // convert single to double\n  tmpd.d *= dstf.f;\n\n  if (tmpf.f != tmpd.d)\n    set_I ();\n  if (tmpf.f &lt; tmpd.d &amp;&amp; FPSCR_RM == 1)\n    dstf.l -= 1;  // round toward zero\n  if (FPSCR &amp; ENABLE_I)\n    fpu_exception_trap ();\n  else\n    FR[n] = dstf.f;\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fcmp/eq\tFRm,FRn",
      "abstract": "If FRn = FRm: 1 -> T\nElse: 0 -> T",
      "code": "1111nnnnmmmm0100",
      "T": "result",
      "description": "Arithmetically compares the two single-precision floating-point numbers in FRn<br />and FRm, and stores 1 in the T bit if they are equal, or 0 otherwise.<br />",
      "operation": "void FCMP_EQ (int m, int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  if (fcmp_chk_single (m, n) == INVALID)\n    fcmp_invalid ();\n  else if (fcmp_chk_single (m, n) == EQ)\n    T = 1;\n  else\n    T = 0;\n}\n\nint fcmp_chk_single (int m, int n)\n{\n  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)\n    return INVALID;\n  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)\n    return UO;\n  else\n    switch (data_type_of (m))\n    {\n    case NORM:\n      switch (data_type_of (n))\n      {\n      case PINF:\n        return GT;\n      case NINF:\n        return LT;\n      default:\n        break;\n      }\n      break;\n\n    case PZERO:\n    case NZERO:\n      switch (data_type_of (n))\n      {\n      case PZERO:\n      case NZERO:\n        return EQ;\n      default:\n        break;\n      }\n      break;\n\n    case PINF:\n      switch (data_type_of (n))\n      {\n        case PINF:\n          return EQ;\n        default:\n          return LT;\n      }\n\n    case NINF:\n      switch (data_type_of (n))\n      {\n      case NINF:\n        return EQ;\n      default:\n        return GT;\n      }\n    }\n\n  if (FR[n] == FR[m])\n    return EQ;\n  else if (FR[n] &gt; FR[m])\n    return GT;\n  else\n    return LT;\n}\n\nvoid fcmp_invalid (void)\n{\n  set_V ();\n\n  if ((FPSCR &amp; ENABLE_V) == 0)\n    T = 0;\n  else\n    fpu_exception_trap ();\n}\n\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fcmp/gt\tFRm,FRn",
      "abstract": "If FRn > FRm: 1 -> T\nElse: 0 -> T",
      "code": "1111nnnnmmmm0101",
      "T": "result",
      "description": "Arithmetically compares the two single-precision floating-point numbers in FRn<br />and FRm, and stores 1 in the T bit if FRn > FRm, or 0 otherwise.<br />",
      "operation": "void FCMP_GT (int m, int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  if (fcmp_chk_single (m, n) == INVALID || fcmp_chk_single (m, n) == UO)\n    fcmp_invalid ();\n  else if (fcmp_chk_single (m, n) == GT)\n    T = 1;\n  else\n    T = 0;\n}\n\nint fcmp_chk_single (int m, int n)\n{\n  // see description of FCMP/EQ instruction.\n}\n\nvoid fcmp_invalid (void)\n{\n  // see description of FCMP/EQ instruction.\n}\n\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "float\tFPUL,FRn",
      "abstract": "(float)FPUL -> FRn",
      "code": "1111nnnn00101101",
      "T": "-",
      "description": "Taking the contents of FPUL as a 32-bit integer, converts this integer to a<br />single-precision floating-point number and stores the result in FRn.<br /><br />When FPSCR.enable.I = 1 an FPU exception trap is generated regardless of whether<br />or not an exception has occurred. When an exception occurs, correct exception<br />information is reflected in FPSCR.cause and FPSCR.flag, and FRn is not updated.<br />Appropriate processing should therefore be performed by software.<br /><br /><br />NoteSH2E and SH3E support only invalid operation (V) and division by zero<br />(Z) exception flags.<br /><br /><br />",
      "operation": "void FLOAT_single (int n)\n{\n  union\n  {\n    double d;\n    int l[2];\n  } tmp;\n\n  PC += 2;\n  clear_cause ();\n\n  FR[n] = FPUL; // convert from integer to float\n  tmp.d = FPUL;\n  if (tmp.l[1] &amp; 0x1FFFFFFF)\n    inexact();\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ftrc\tFRm,FPUL",
      "abstract": "(long)FRm -> FPUL",
      "code": "1111mmmm00111101",
      "T": "-",
      "description": "Converts the single-precision floating-point number in FRm to a 32-bit integer,<br />and stores the result in FPUL.<br />",
      "operation": "#define NEG_INT_SINGLE_RANGE 0xCF000000 &amp; 0x7FFFFFFF // -1.000000 * 2^31\n#define POS_INT_SINGLE_RANGE 0x4EFFFFFF              // 1.FFFFFE * 2^30\n\nvoid FTRC_single (int m)\n{\n  PC += 2;\n  clear_cause ();\n\n  switch (ftrc_single_type_of (m))\n  {\n    case NORM:\n      FPUL = FR[m];  // Convert float to integer\n      break;\n    case PINF:\n      ftrc_invalid (0, &amp;FPUL);\n      break;\n    case NINF:\n      ftrc_invalid (1, &amp;FPUL);\n      break;\n  }\n}\n\nint ftrc_single_type_of (int m)\n{\n  if (sign_of (m) == 0)\n  {\n    if (FR_HEX[m] &gt; 0x7F800000)\n      return NINF;  // NaN\n    else if (FR_HEX[m] &gt; POS_INT_SINGLE_RANGE)\n      return PINF;  // out of range, +INF\n    else\n      return NORM;  // +0, +NORM\n  }\n  else\n  {\n    if ((FR_HEX[m] &amp; 0x7FFFFFFF) &gt; NEG_INT_SINGLE_RANGE)\n      return NINF;  // out of range, +INF, NaN\n    else\n      return NORM;  // -0, -NORM\n  }\n}\n\nvoid ftrc_invalid (int sign, int* result)\n{\n  set_V ();\n\n  if ((FPSCR &amp; ENABLE_V) == 0)\n  {\n    if (sign == 0)\n      *result = 0x7FFFFFFF;\n    else\n      *result = 0x80000000;\n  }\n  else\n    fpu_exception_trap ();\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fipr\tFVm,FVn",
      "abstract": "inner_product (FVm, FVn) -> FR[n+3]",
      "code": "1111nnmm11101101",
      "T": "-",
      "description": "Calculates the inner products of the 4-dimensional single-precision<br />floating-point vector indicated by FVn and FVm, and stores the results in<br />FR[n + 3].<br /><br />The FIPR instruction is intended for speed rather than accuracy, and therefore<br />the results will differ from those obtained by using a combination of FADD and<br />FMUL instructions. The FIPR execution sequence is as follows:<br /><br /> Multiplies all terms.  The results are 28 bits long.<br /> Aligns these results, rounding them to fit within 30 bits.<br /> Adds the aligned values.<br /> Performs normalization and rounding.<br /><br /><br />Special processing is performed in the following cases:<br /><br />If an input value is an sNaN, an invalid exception is generated.<br /><br />If the input values to be multiplied include a combination of 0 and<br />infinity, an invalid exception is generated.<br /><br />In cases other than the above, if the input values include a qNaN, the<br />result will be a qNaN.<br /><br />In cases other than the above, if the input values include infinity:<br />  <br />  If multiplication results in two or more infinities and the signs are<br />  different, an invalid exception will be generated.<br />  Otherwise, correct infinities will be stored.<br />  <br /><br />If the input values do not include an sNaN, qNaN, or infinity, processing<br />is performed in the normal way.<br /><br />When FPSCR.enable.U/I is set, an FPU exception trap is generated regardless of<br />whether or not an exception has occurred. When FPSCR.enable.O is set, FPU<br />exception traps are generated on actual generation by the FPU exception source<br />and on the satisfaction of certain special conditions that apply to this the<br />instruction. When an exception occurs, correct exception information is<br />reflected in FPSCR.cause and FPSCR.flag, and FR[n+3] is not updated. Appropriate<br />processing should therefore be performed by software.<br /><br /><br />NoteFV0 = { FR0, FR1, FR2, FR3 }<br />FV4 = { FR4, FR5, FR6, FR7 }<br />FV8 = { FR8, FR9, FR10, FR11 }<br />FV12 = { FR12, FR13, FR14, FR15 }<br /><br /><br />",
      "operation": "void FIPR (int m, int n)\n{\n  if (FPSCR_PR == 0)\n  {\n    PC += 2;\n    clear_cause ();\n    fipr (m,n);\n  }\n  else\n    undefined_operation ();\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 5,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 4,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ftrv\tXMTRX,FVn",
      "abstract": "transform_vector (XMTRX, FVn) -> FVn",
      "code": "1111nn0111111101",
      "T": "-",
      "description": "Takes the contents of floating-point registers XF0 to XF15 indicated by XMTRX<br />as a 4-row × 4-column matrix, takes the contents of floating-point<br />registers FR[n] to FR[n + 3] indicated by FVn as a 4-dimensional vector,<br />multiplies the array by the vector, and stores the results in FV[n].<br /><br /><br /><br />The FTRV instruction is intended for speed rather than accuracy, and therefore<br />the results will differ from those obtained by using a combination of FADD and<br />FMUL instructions. The FTRV execution sequence is as follows:<br /><br />Multiplies all terms. The results are 28 bits long.<br />Aligns these results, rounding them to fit within 30 bits.<br />Adds the aligned values.<br />Performs normalization and rounding.<br /><br /><br />Special processing is performed in the following cases:<br /><br />If an input value is an sNaN, an invalid exception is generated.<br /><br />If the input values to be multiplied include a combination of 0 and<br />infinity, an invalid operation exception is generated.<br /><br />In cases other than the above, if the input values include a qNaN, the<br />result will be a qNaN.<br /><br />In cases other than the above, if the input values include infinity:<br />  <br />  If multiplication results in two or more infinities and the signs are<br />  different, an invalid exception will be generated.<br /><br />  Otherwise, correct infinities will be stored.<br />  <br /><br /><br />If the input values do not include an sNaN, qNaN, or infinity, processing<br />is performed in the normal way.<br /><br /><br /><br />When FPSCR.enable.V/O/U/I is set, an FPU exception trap is generated regardless<br />of whether or not an exception has occurred. When an exception occurs, correct<br />exception information is reflected in FPSCR.cause and FPSCR.flag, and FVn is not<br />updated. Appropriate processing should therefore be performed by software.<br /><br /><br />NoteA 4-dimensional matrix × matrix transformation can be realized by four FTRV<br />instructions, where every FTRV calculates a column of the result matrix.  The<br />resulting matrix can be set to the XMTRX registers by toggling the FPSCR.FR bit<br />to switch register banks without copying them.<br /><br /><br />",
      "operation": "void FTRV (int n)\n{\n  if (FPSCR_PR != 0)\n    undefined_operation ();\n  else\n  {\n    float saved_vec[4];\n    float result_vec[4];\n    int saved_fpscr;\n    int dst;\n\n    PC += 2;\n    clear_cause ();\n\n    saved_fpscr = FPSCR;\n    FPSCR &amp;= ~ENABLE_VOUI;  // mask VOUI enable\n    dst = 12 - n;           // select other vector than FVn\n\n    for (int i = 0; i &lt; 4; i++)\n      saved_vec[i] = FR[dst+i];\n\n    for (int i = 0; i &lt; 4; i++)\n    {\n      for (int j = 0; j &lt; 4; j++)\n        FR[dst+j] = XF[i+4j];\n\n      fipr (n, dst);\n      saved_fpscr |= FPSCR &amp; (CAUSE | FLAG);\n      result_vec[i] = FR[dst+3];\n    }\n\n    for (int i = 0; i &lt; 4; i++)\n      FR[dst+i] = saved_vec[i];\n\n    FPSCR = saved_fpscr;\n\n    if (FPSCR &amp; ENABLE_VOUI)\n      fpu_exception_trap();\n    else\n      for (int i = 0; i &lt; 4; i++)\n        FR[n+i] = result_vec[i];\n  }\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fsrra\tFRn",
      "abstract": "1.0 / sqrt (FRn) -> FRn",
      "code": "1111nnnn01111101",
      "T": "-",
      "description": "Takes the approximate inverse of the arithmetic square root (absolute error is<br />within ±2-21) of the single-precision floating-point in FRn<br />and writes the result to FRn. Since the this instruction operates by<br />approximation, an imprecision exception is required when the input is a<br />normalized value. In other cases, the instruction does not require an<br />imprecision exception.<br /><br />When FPSCR.enable.I is set, an FPU exception trap is generated. When an<br />exception occurs, correct exception information is reflected in FPSCR.cause and<br />FPSCR.flag, and FRn is not updated. Appropriate processing should therefore be<br />performed by software.<br />",
      "operation": "void FSRRA (int n)\n{\n  if (FPSCR_PR != 0)\n    undefined_operation ();\n  else\n  {\n    PC += 2;\n    clear_cause();\n\n    switch (data_type_of (n))\n    {\n    case NORM:\n      if (sign_of (n) == 0)\n      {\n        set_I ();\n        FR[n] = 1 / sqrt (FR[n]);\n      }\n      else\n        invalid (n);\n      break;\n\n    case DENORM:\n      if (sign_of (n) == 0)\n        fpu_error ();\n      else\n        invalid (n);\n      break;\n\n    case PZERO:\n    case NZERO:\n      dz (n, sign_of (n));\n      break;\n\n    case PINF:\n      FR[n] = 0;\n      break;\n\n    case NINF:\n      invalid (n);\n      break;\n\n    case qNAN:\n      qnan (n);\n      break;\n\n    case sNAN:\n      invalid (n);\n      break;\n    }\n  }\n}\n"
    },
    {
      "group": "Floating-Point Single-Precision Instructions (FPSCR.PR = 0)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 3,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fsca\tFPUL,DRn",
      "abstract": "sin (FPUL) -> FRn\ncos (FPUL) -> FR[n+1]",
      "code": "1111nnn011111101",
      "T": "-",
      "description": "Calculates the sine and cosine approximations of FPUL (absolute error is<br />within ±2-21) as single-precision floating point values, and<br />places the values of the sine and cosine in FRn and FR[n + 1], respectively.<br />Since this instruction is an approximate operation instruction, an imprecision<br />exception is always required (even if the input is a 0, the result is<br />imprecise).<br /><br />The input angle is specified as a signed fraction in twos complement.  The<br />result of sin and cos is a single-precision floating-point number.<br /><br />0x7FFFFFFF to 0x00000001:<br />360×215−360/216 to 360/216 degrees<br /><br />0x00000000: 0 degree<br /><br />0xFFFFFFFF to 0x80000000:<br />−360/216 to −360×215 degrees<br /><br /><br />NoteThis instruction is also supported by the SH4 variant SH7091.  Other SH4<br />variants such as SH7751, SH7760, SH7761 might also support it.<br /><br /><br />",
      "operation": "void FSCA (int n)\n{\n  if (FPSCR_PR != 0)\n    undefined_operation ();\n  else\n  {\n    float angle;\n    long offset = 0x00010000;\n    long fraction = 0x0000FFFF;\n\n    set_I ();\n    fraction &amp;= FPUL;  // extract sub-rotation (fraction) part\n    angle = fraction;  // convert to float\n    angle = 2 * M_PI * angle / offset;  // convert to radian\n    FR[n] = sin (angle);\n    FR[n+1] = cos (angle);\n    PC += 2;\n  }\n}\n"
    },
    {
      "group": "Floating-Point Double-Precision Instructions (FPSCR.PR = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fabs\tDRn",
      "abstract": "DRn & 0x7FFFFFFFFFFFFFFF -> DRn",
      "code": "1111nnn001011101",
      "T": "-",
      "description": "Clears the most significant bit of the contents of floating-point register DRn<br />to 0, and stores the result in DRn.<br /><br /><br />NoteThe cause and flag fields in FPSCR are not updated.<br /><br />A double-precision floating-point register DRn consists of a single-precision<br />floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is<br />the low part.  This instruction operates only on the high part and thus the<br />operation performed for double and single precision setting is the same.  It is<br />not necessary to adjust the FPSRC.PR setting before this instruction.<br /><br /><br />",
      "operation": "void FABS (int n)\n{\n  FR[n] = FR[n] &amp; 0x7FFFFFFFF;\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Double-Precision Instructions (FPSCR.PR = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fneg\tDRn",
      "abstract": "DRn ^ 0x8000000000000000 -> DRn",
      "code": "1111nnn001001101",
      "T": "-",
      "description": "Inverts the most significant bit (sign bit) of the contents of floating-point<br />register DRn, and stores the result in DRn.<br /><br /><br />NoteThe cause and flag fields in FPSCR are not updated.<br /><br />A double-precision floating-point register DRn consists of a single-precision<br />floating-point register pair FRn:FRn+1, where FRn is the high part and FRn+1 is<br />the low part.  This instruction operates only on the high part and thus the<br />operation performed for double and single precision setting is the same.  It is<br />not necessary to adjust the FPSRC.PR setting before this instruction.<br /><br /><br />",
      "operation": "void FNEG (int n)\n{\n  FR[n] = -FR[n];\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Double-Precision Instructions (FPSCR.PR = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 7,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fadd\tDRm,DRn",
      "abstract": "DRn + DRm -> DRn",
      "code": "1111nnn0mmm00000",
      "T": "-",
      "description": "Arithmetically adds the two double-precision floating-point numbers in DRn and<br />DRm, and stores the result in DRn.<br /><br />When FPSCR.enable.I is set, an FPU exception trap is generated regardless of<br />whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU<br />exception traps are generated on actual generation by the FPU exception source<br />and on the satisfaction of certain special conditions that apply to this the<br />instruction. When an exception occurs, correct exception information is<br />reflected in FPSCR.cause and FPSCR.flag and DRn is not updated. Appropriate<br />processing should therefore be performed by software.<br />",
      "operation": "void FADD (int m, int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)\n    invalid (n);\n  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)\n    qnan (n);\n  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)\n    set_E ();\n  else\n    switch (data_type_of (m))\n    {\n    case NORM:\n      switch (data_type_of (n))\n      {\n      case NORM:\n        normal_faddsub (m, n, ADD);\n        break;\n      case PZERO:\n      case NZERO:\n        register_copy (m, n);\n        break;\n      default:\n        break;\n      }\n      break;\n\n    case PZERO:\n      switch (data_type_of (n))\n      {\n      case NZERO:\n        zero (n, 0);\n        break;\n      default:\n        break;\n      }\n      break;\n\n    case NZERO:\n      break;\n\n    case PINF:\n      switch (data_type_of (n))\n      {\n      case NINF:\n        invalid (n);\n        break;\n      default:\n        inf (n, 0);\n        break;\n      }\n      break;\n\n     case NINF:\n       switch (data_type_of (n))\n       {\n       case PINF:\n         invalid (n);\n         break;\n       default:\n         inf (n, 1);\n         break;\n       }\n       break;\n    }\n}\n"
    },
    {
      "group": "Floating-Point Double-Precision Instructions (FPSCR.PR = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 7,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fsub\tDRm,DRn",
      "abstract": "DRn - DRm -> DRn",
      "code": "1111nnn0mmm00001",
      "T": "-",
      "description": "Arithmetically subtracts the double-precision floating-point number in DRm from<br />the double-precision floating-point number in DRn, and stores the result in DRn.<br /><br />When FPSCR.enable.I is set, an FPU exception trap is generated regardless of<br />whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU<br />exception traps are generated on actual generation by the FPU exception source<br />and on the satisfaction of certain special conditions that apply to this the<br />instruction.  When an exception occurs, correct exception information is<br />reflected in FPSCR.cause and FPSCR.flag and DRn is not updated. Appropriate<br />processing should therefore be performed by software.<br />",
      "operation": "void FSUB (int m, int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)\n    invalid (n);\n  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)\n    qnan (n);\n  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)\n    set_E ();\n  else\n    switch (data_type_of (m))\n    {\n    case NORM:\n      switch (data_type_of (n))\n      {\n      case NORM:\n        normal_faddsub (m, n, SUB);\n        break;\n      case PZERO:\n      case NZERO:\n        register_copy (m, n);\n        FR[n] = -FR[n];\n        break;\n      default:\n        break;\n      }\n      break;\n\n    case PZERO:\n      break;\n      case NZERO:\n        switch (data_type_of (n))\n        {\n        case NZERO:\n          zero (n, 0);\n          break;\n        default:\n          break;\n        }\n        break;\n\n    case PINF:\n      switch (data_type_of (n))\n      {\n      case PINF:\n        invalid (n);\n        break;\n      default:\n        inf (n, 1);\n        break;\n      }\n      break;\n\n    case NINF:\n      switch (data_type_of (n))\n      {\n      case NINF:\n        invalid (n);\n        break;\n      default:\n        inf (n, 0);\n        break;\n      }\n      break;\n    }\n}\n"
    },
    {
      "group": "Floating-Point Double-Precision Instructions (FPSCR.PR = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 7,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 3,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fmul\tDRm,DRn",
      "abstract": "DRn * DRm -> DRn",
      "code": "1111nnn0mmm00010",
      "T": "-",
      "description": "Arithmetically multiplies the two double-precision floating-point numbers in<br />DRn and DRm, and stores the result in FRn.<br /><br />When FPSCR.enable.I is set, an FPU exception trap is generated regardless of<br />whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU<br />exception traps are generated on actual generation by the FPU exception source<br />and on the satisfaction of certain special conditions that apply to this the<br />instruction. When an exception occurs, correct exception information is<br />reflected in FPSCR.cause and FPSCR.flag and DRn is not updated. Appropriate<br />processing should therefore be performed by software.<br />",
      "operation": "void FMUL (int m, int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)\n    invalid (n);\n  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)\n    qnan (n);\n  else if (data_type_of (m) == DENORM || data_type_of (n) == DENORM)\n    set_E ();\n  else\n    switch (data_type_of (m))\n    {\n    case NORM:\n      switch (data_type_of (n))\n      {\n      case PZERO:\n      case NZERO:\n        zero (n, sign_of (m) ^ sign_of (n));\n        break;\n      case PINF:\n      case NINF:\n        inf (n, sign_of (m) ^ sign_of (n));\n        break;\n      default:\n        normal_fmul (m, n);\n        break;\n      }\n      break;\n\n    case PZERO:\n    case NZERO:\n      switch (data_type_of (n))\n      {\n      case PINF:\n      case NINF:\n        invalid (n);\n        break;\n      default: \n        zero (n,sign_of (m) ^ sign_of (n));\n        break;\n      }\n      break;\n\n    case PINF:\n    case NINF:\n      switch (data_type_of (n))\n      {\n      case PZERO:\n      case NZERO:\n        invalid (n);\n        break;\n      default:\n        inf (n, sign_of (m) ^ sign_of (n));\n        break\n      }\n      break;\n    }\n}\n"
    },
    {
      "group": "Floating-Point Double-Precision Instructions (FPSCR.PR = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fdiv\tDRm,DRn",
      "abstract": "DRn / DRm -> DRn",
      "code": "1111nnn0mmm00011",
      "T": "-",
      "description": "Arithmetically divides the double-precision floating-point number in DRn by the<br />double-precision floating-point number in DRm, and stores the result in DRn.<br /><br />When FPSCR.enable.I is set, an FPU exception trap is generated regardless of<br />whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU<br />exception traps are generated on actual generation by the FPU exception source<br />and on the satisfaction of certain special conditions that apply to this the<br />instruction. When an exception occurs, correct exception information is<br />reflected in FPSCR.cause and FPSCR.flag and DRn is not updated. Appropriate<br />processing should therefore be performed by software.<br />",
      "operation": "void FDIV (int m, int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)\n    invalid (n);\n  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)\n    qnan (n);\n  else\n    switch (data_type_of (m))\n    {\n    case NORM:\n      switch (data_type_of (n))\n      {\n      case PINF:\n      case NINF:\n        inf (n, sign_of (m) ^ sign_of (n));\n        break;\n      case PZERO:\n      case NZERO:\n        zero (n, sign_of (m) ^ sign_of (n));\n        break;\n      case DENORM:\n        set_E ();\n        break;\n      default:\n        normal_fdiv_double (m, n);\n        break;\n      }\n      break;\n\n    case PZERO:\n      switch (data_type_of (n))\n      {\n      case PZERO:\n      case NZERO:\n        invalid (n);\n        break;\n      case PINF:\n      case NINF:\n        break;\n      default:\n        dz (n, sign_of (m) ^ sign_of (n));\n        break;\n      }\n      break;\n\n    case NZERO:\n      switch (data_type_of (n))\n      {\n      case PZERO:\n      case NZERO:\n        invalid (n);\n        break;\n      case PINF:\n        inf (n, 1);\n        break;\n      case NINF:\n        inf (n, 0);\n        break;\n      default:\n        dz (FR[n], sign_of (m) ^ sign_of (n));\n        break;\n      }\n      break;\n\n    case DENORM:\n      set_E ();\n      break;\n\n    case PINF:\n    case NINF:\n      switch (data_type_of (n))\n      {\n      case DENORM:\n        set_E ();\n        break;\n      case PINF:\n      case NINF:\n        invalid (n);\n        break;\n      default:\n        zero (n, sign_of (m) ^ sign_of (n));\n        break;\n      }\n      break;\n    }\n}\n\nvoid normal_fdiv_double (int m, int n)\n{\n  union\n  {\n    double d;\n    int l[2];\n  } dstd, tmpd;\n\n  union\n  {\n    int double x;\n    int l[4];\n  } tmpx;\n\n  tmpd.d = DR[n &gt;&gt; 1];   // save destination value\n  dstd.d /= DR[m &gt;&gt; 1];  // round toward nearest or even\n  tmpx.x = dstd.d;       // convert double to int double\n  tmpx.x *= DR[m &gt;&gt; 1];\n\n  if (tmpd.d != tmpx.x)\n    set_I ();\n  if (tmpd.d &lt; tmpx.x &amp;&amp; FPSCR_RM == 1)\n  {\n    dstd.l[1] -= 1;  // round toward zero\n    if (dstd.l[1] == 0xFFFFFFFF)\n      dstd.l[0] -= 1;\n  }\n\n  check_double_exception (&amp;DR[n &gt;&gt; 1], dstd.d);\n}\n"
    },
    {
      "group": "Floating-Point Double-Precision Instructions (FPSCR.PR = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 2,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 3,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fsqrt\tDRn",
      "abstract": "sqrt (DRn) -> DRn",
      "code": "1111nnn001101101",
      "T": "-",
      "description": "Finds the arithmetical square root of the double-precision floating-point number<br />in DRn, and stores the result in DRn.<br /><br />When FPSCR.enable.I is set, an FPU exception trap is generated regardless of<br />whether or not an exception has occurred. When an exception occurs, correct<br />exception information is reflected in FPSCR.cause and FPSCR.flag and DRn is not<br />updated. Appropriate processing should therefore be performed by software.<br />",
      "operation": "void FSQRT (int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  switch (data_type_of (n))\n  {\n  case NORM:\n    if (sign_of (n) == 0)\n      normal_fsqrt_double (n);\n    else\n      invalid (n);\n    break;\n\n  case DENORM:\n    if (sign_of (n) == 0)\n      set_E ();\n    else\n      invalid (n);\n    break;\n\n  case PZERO:\n  case NZERO:\n  case PINF:\n    break;\n\n  case NINF:\n    invalid (n);\n    break;\n\n  case qNAN:\n    qnan (n);\n    break;\n\n  case sNAN:\n    invalid (n);\n    break;\n  }\n}\n\nvoid normal_fsqrt_double (int n)\n{\n  union\n  {\n    double d;\n    int l[2];\n  } dstd, tmpd;\n\n  union\n  {\n    int double x;\n    int l[4];\n  } tmpx;\n\n  tmpd.d = DR[n &gt;&gt; 1];         // save destination value\n  dstd.d = sqrt (DR[n &gt;&gt; 1]);  // round toward nearest or even\n  tmpx.x = dstd.d;             // convert double to int double\n  tmpx.x *= dstd.d;\n\n  if (tmpd.d != tmpx.x)\n    set_I ();\n  if (tmpd.d &lt; tmpx.x &amp;&amp; FPSCR_RM == 1)\n  {\n    dstd.l[1] -= 1;  // round toward zero\n    if (dstd.l[1] == 0xFFFFFFFF)\n      dstd.l[0] -= 1;\n  }\n  if (FPSCR &amp; ENABLE_I)\n    fpu_exception_trap();\n  else\n    DR[n &gt;&gt; 1] = dstd.d;\n}\n"
    },
    {
      "group": "Floating-Point Double-Precision Instructions (FPSCR.PR = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fcmp/eq\tDRm,DRn",
      "abstract": "If DRn = DRm: 1 -> T\nElse: 0 -> T",
      "code": "1111nnn0mmm00100",
      "T": "-",
      "description": "Arithmetically compares the two double-precision floating-point numbers in DRn<br />and DRm, and stores 1 in the T bit if they are equal, or 0 otherwise.<br />",
      "operation": "void FCMP_EQ (int m, int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  if (fcmp_chk_double (m, n) == INVALID)\n    fcmp_invalid ();\n  else if (fcmp_chk_double (m, n) == EQ)\n    T = 1;\n  else\n    T = 0;\n}\n\nint fcmp_chk_double (int m, int n)\n{\n  if (data_type_of (m) == sNaN || data_type_of (n) == sNaN)\n    return INVALID;\n  else if (data_type_of (m) == qNaN || data_type_of (n) == qNaN)\n    return UO;\n  else\n    switch (data_type_of (m))\n    {\n    case NORM:\n      switch (data_type_of (n))\n      {\n      case PINF:\n        return GT;\n      case NINF:\n        return LT;\n      default:\n        break;\n      }\n      break;\n\n    case PZERO:\n    case NZERO:\n      switch (data_type_of (n))\n      {\n      case PZERO:\n      case NZERO:\n        return EQ;\n      default:\n        break;\n      }\n      break;\n\n    case PINF:\n      switch (data_type_of (n))\n      {\n        case PINF:\n          return EQ;\n        default:\n          return LT;\n      }\n\n    case NINF:\n      switch (data_type_of (n))\n      {\n      case NINF:\n        return EQ;\n      default:\n        return GT;\n      }\n    }\n\n  if (DR[n &gt;&gt; 1] == DR[m &gt;&gt; 1])\n    return EQ;\n  else if (DR[n &gt;&gt; 1] &gt; DR[m &gt;&gt; 1])\n    return GT;\n  else\n    return LT;\n}\n\nvoid fcmp_invalid (void)\n{\n  set_V ();\n\n  if ((FPSCR &amp; ENABLE_V) == 0)\n    T = 0;\n  else\n    fpu_exception_trap ();\n}\n"
    },
    {
      "group": "Floating-Point Double-Precision Instructions (FPSCR.PR = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 2,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 2,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fcmp/gt\tDRm,DRn",
      "abstract": "If DRn > DRm: 1 -> T\nElse: 0 -> T",
      "code": "1111nnn0mmm00101",
      "T": "-",
      "description": "Arithmetically compares the two double-precision floating-point numbers in DRn<br />and DRm, and stores 1 in the T bit if DRn > DRm, or 0 otherwise.<br />",
      "operation": "void FCMP_GT (int m, int n)\n{\n  PC += 2;\n  clear_cause ();\n\n  if (fcmp_chk_double (m, n) == INVALID || fcmp_chk_double (m, n) == UO)\n    fcmp_invalid ();\n  else if (fcmp_chk_double (m, n) == GT)\n    T = 1;\n  else\n    T = 0;\n}\n\nint fcmp_chk_double (int m, int n)\n{\n  // see description of FCMP/EQ instruction.\n}\n\nvoid fcmp_invalid (void)\n{\n  // see description of FCMP/EQ instruction.\n}\n"
    },
    {
      "group": "Floating-Point Double-Precision Instructions (FPSCR.PR = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "float\tFPUL,DRn",
      "abstract": "(double)FPUL -> DRn",
      "code": "1111nnn000101101",
      "T": "-",
      "description": "Taking the contents of FPUL as a 32-bit integer, converts this integer to a<br />double-precision floating-point number and stores the result in DRn.<br /><br /><br />",
      "operation": "void FLOAT_double (int n)\n{\n  union\n  {\n    double d;\n    int l[2];\n  } tmp;\n\n  PC += 2;\n  clear_cause ();\n\n  DR[n &gt;&gt; 1] = FPUL; // convert from integer to double\n}\n"
    },
    {
      "group": "Floating-Point Double-Precision Instructions (FPSCR.PR = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "ftrc\tDRm,FPUL",
      "abstract": "(long)DRm -> FPUL",
      "code": "1111mmm000111101",
      "T": "-",
      "description": "Converts the double-precision floating-point number in DRm to a 32-bit integer,<br />and stores the result in FPUL.<br />",
      "operation": "#define NEG_INT_DOUBLE_RANGE 0xC1E0000000200000 &amp; 0x7FFFFFFFFFFFFFFF\n#define POS_INT_DOUBLE_RANGE 0x41E0000000000000\n\nvoid FTRC_double (int m)\n{\n  PC += 2;\n  clear_cause ();\n\n  switch (ftrc_double_type_of (m))\n  {\n    case NORM:\n      FPUL = DR[m &gt;&gt; 1];  // Convert double to integer\n      break;\n    case PINF:\n      ftrc_invalid (0, &amp;FPUL);\n      break;\n    case NINF:\n      ftrc_invalid (1, &amp;FPUL);\n      break;\n  }\n}\n\nint ftrc_double_type_of (int m)\n{\n  if (sign_of (m) == 0)\n  {\n    if (FR_HEX[m] &gt; 0x7FF00000\n        || (FR_HEX[m] == 0x7FF00000 &amp;&amp; FR_HEX[m+1] != 0x00000000))\n      return NINF;  // NaN\n    else if (DR_HEX[m &gt;&gt; 1] &gt;= POS_INT_DOUBLE_RANGE)\n      return PINF;  // out of range, +INF\n    else\n      return NORM;  // +0, +NORM\n  }\n  else\n  {\n    if ((DR_HEX[m &gt;&gt; 1] &amp; 0x7FFFFFFFFFFFFFFF) &gt;= NEG_INT_DOUBLE_RANGE)\n      return NINF;  // out of range, +INF, NaN\n    else\n      return NORM;  // -0, -NORM\n  }\n}\n\nvoid ftrc_invalid (int sign, int* result)\n{\n  set_V ();\n\n  if ((FPSCR &amp; ENABLE_V) == 0)\n  {\n    if (sign == 0)\n      *result = 0x7FFFFFFF;\n    else\n      *result = 0x80000000;\n  }\n  else\n    fpu_exception_trap ();\n}\n"
    },
    {
      "group": "Floating-Point Double-Precision Instructions (FPSCR.PR = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 4,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fcnvds\tDRm,FPUL",
      "abstract": "double_to_float (DRm) -> FPUL",
      "code": "1111mmm010111101",
      "T": "-",
      "description": "Converts the double-precision floating-point number in DRm to a single-precision<br />floating-point number, and stores the result in FPUL.<br /><br />When FPSCR.enable. I is set, an FPU exception trap is generated regardless of<br />whether or not an exception has occurred. When FPSCR.enable.O/U is set, FPU<br />exception traps are generated on actual generation by the FPU exception source<br />and on the satisfaction of certain special conditions that apply to this the<br />instruction. When an exception occurs, correct exception information is<br />reflected in FPSCR.cause and FPSCR.flag, and FPUL is not updated. Appropriate<br />processing should therefore be performed by software.<br />",
      "operation": "void FCNVDS (int m)\n{\n  if (FPSCR_PR != 1)\n    undefined_operation ();\n  else\n  {\n    PC += 2;\n    clear_cause ();\n\n    switch (data_type_of (m))\n    {\n    case NORM:\n    case PZERO:\n    case NZERO:\n      normal_fcnvds (m, &amp;FPUL);\n      break;\n\n    case DENORM:\n      set_E ();\n\n    case PINF:\n      FPUL = 0x7F800000;\n      break;\n\n    case NINF:\n      FPUL = 0xFF800000;\n      break;\n\n    case qNaN:\n      FPUL = 0x7FBFFFFF;\n      break;\n\n    case sNaN:\n      set_V ();\n      if ((FPSCR &amp; ENABLE_V) == 0)\n        FPUL = 0x7FBFFFFF;\n      else\n        fpu_exception_trap ();\n      break;\n    }\n  }\n}\n\nvoid normal_fcnvds (int m, float* result)\n{\n  int sign;\n  float abs;\n\n  union\n  {\n    float f;\n    int l;\n  } dstf, tmpf;\n\n  union\n  {\n    double d;\n    int l[2];\n  } dstd;\n\n  dstd.d = DR [m &gt;&gt; 1];\n\n  if (dstd.l[1] &amp; 0x1FFFFFFF))\n    set_I ();\n\n  if (FPSCR_RM == 1)\n    dstd.l[1] &amp;= 0xE0000000;  // round toward zero\n\n  dstf.f = dstd.d;\n  check_single_exception (result, dstf.f);\n}\n"
    },
    {
      "group": "Floating-Point Double-Precision Instructions (FPSCR.PR = 1)",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 4,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fcnvsd\tFPUL,DRn",
      "abstract": "float_to_double (FPUL) -> DRn",
      "code": "1111nnn010101101",
      "T": "-",
      "description": "Converts the single-precision floating-point number in FPUL to a<br />double-precision floating-point number, and stores the result in DRn.<br />",
      "operation": "void FCNVSD (int n)\n{\n  if (FPSCR_PR != 1)\n    undefined_operation ();\n  else\n  {\n    switch (fpul_type ())\n    {\n    case PZERO:\n    case NZERO:\n    case PINF:\n    case NINF:\n    case NORM:\n      DR[n &gt;&gt; 1] = FPUL;  // convert float to double\n      break;\n\n    case DENORM:\n      set_E ();\n      break;\n\n    case qNaN:\n      qnan (n);\n      break;\n\n    case sNaN:\n      invalid (n);\n      break;\n    }\n  }\n}\n\nint fpul_type ()\n{\n  int abs = FPUL &amp; 0x7FFFFFFF;\n  if (abs &lt; 0x00800000)\n  {\n    if (FPSCR_DN == 1 || abs == 0x00000000)\n    {\n      if (sign_of (FPUL) == 0)\n        return PZERO;\n      else\n        return NZERO;\n    }\n    else\n      return DENORM;\n  }\n  else if (abs &lt; 0x7F800000)\n    return NORM;\n  else if (abs == 0x7F800000)\n  {\n    if (sign_of (FPUL) == 0)\n      return PINF;\n    else\n      return NINF;\n  }\n  else if (abs &lt; 0x7FC00000)\n    return qNaN;\n  else\n    return sNaN;\n}\n"
    },
    {
      "group": "Floating-Point Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 4,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "lds\tRm,FPSCR",
      "abstract": "Rm -> FPSCR",
      "code": "0100mmmm01101010",
      "T": "-",
      "description": "Loads the source operand into FPU system register FPSCR.<br /><br /><br />",
      "operation": "void LDSFPSCR (int m)\n{\n  #if SH2E || SH3E\n  FPSCR = R[m] &amp; 0x00018C60;\n\n  #elif SH4 || SH4A || SH2A\n  FPSCR = R[m] &amp; 0x003FFFFF;\n\n  #endif\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sts\tFPSCR,Rn",
      "abstract": "FPSCR -> Rn",
      "code": "0000nnnn01101010",
      "T": "-",
      "description": "Stores FPU system register FPSCR in the destination.<br /><br /><br />",
      "operation": "void STSFPSCR (int n)\n{\n  #if SH2E || SH3E\n  R[n] = FPSCR;\n\n  #elif SH4 || SH4A || SH2A\n  R[n] = FPSCR &amp; 0x003FFFFF;\n\n  #endif\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 3,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "lds.l\t@Rm+,FPSCR",
      "abstract": "(Rm) -> FPSCR, Rm+4 -> Rm",
      "code": "0100mmmm01100110",
      "T": "-",
      "description": "Loads the source operand into FPU system register FPSCR.<br /><br /><br />",
      "operation": "void LDSMFPSCR (int m)\n{\n  #if SH2E || SH3E\n  FPSCR = Read_32 (R[m]) &amp; 0x00018C60;\n\n  #elif SH4 || SH4A || SH2A\n  FPSCR = Read_32 (R[m]) &amp; 0x003FFFFF;\n\n  #endif\n\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sts.l\tFPSCR,@-Rn",
      "abstract": "Rn-4 -> Rn, FPSCR -> (Rn)",
      "code": "0100nnnn01100010",
      "T": "-",
      "description": "Stores FPU system register FPSCR in the destination.<br /><br /><br />",
      "operation": "void STSMFPSCR (int n)\n{\n  R[n] -= 4;\n\n  #if SH2E || SH3E\n  Write_32 (R[n], FPSCR);\n\n  #elif SH4 || SH4A || SH2A\n  Write_32 (R[n], FPSCR &amp; 0x003FFFFF);\n\n  #endif\n\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "lds\tRm,FPUL",
      "abstract": "Rm -> FPUL",
      "code": "0100mmmm01011010",
      "T": "-",
      "description": "Loads the source operand into FPU system register FPUL.<br /><br /><br />",
      "operation": "void LDSFPUL (int m)\n{\n  FPUL = R[m];\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 3,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sts\tFPUL,Rn",
      "abstract": "FPUL -> Rn",
      "code": "0000nnnn01011010",
      "T": "-",
      "description": "Stores FPU system register FPUL in the destination.<br /><br /><br /><br />NoteThe original SH4 has a pipeline exception.  If the FTRC instruction is followed<br />by an STS FPUL, Rn instruction, the latency of the FTRC instruction is reduced<br />to 1 cycle.<br /><br /><br />",
      "operation": "void STSFPUL (int n)\n{\n  R[n] = FPUL;\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "lds.l\t@Rm+,FPUL",
      "abstract": "(Rm) -> FPUL, Rm+4 -> Rm",
      "code": "0100mmmm01010110",
      "T": "-",
      "description": "Operationvo",
      "operation": "void LDSMFPUL (int m)\n{\n  FPUL = Read_32 (R[m]);\n  R[m] += 4;\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": true,
      "SH2E.issue": 1,
      "SH2E.latency": 1,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": true,
      "SH3E.issue": 1,
      "SH3E.latency": 1,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 2,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "sts.l\tFPUL,@-Rn",
      "abstract": "Rn-4 -> Rn, FPUL -> (Rn)",
      "code": "0100nnnn01010010",
      "T": "-",
      "description": "Stores FPU system register FPUL in the destination.<br /><br /><br />",
      "operation": "void STSMFPUL (int n)\n{\n  R[n] -= 4;\n  Write_32 (R[n], FPUL);\n  PC += 2;\n}\n"
    },
    {
      "group": "Floating-Point Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "frchg",
      "abstract": "If FPSCR.PR = 0: ~FPSCR.FR -> FPSCR.FR\nElse: Undefined Operation",
      "code": "1111101111111101",
      "T": "-",
      "description": "Inverts the FR bit in floating-point register FPSCR. When the FR bit in FPSCR is<br />changed, FR0 to FR15 in FPR0_BANK0 to FPR15_BANK0 and FPR0_BANK1 to FPR15_BANK1<br />become XR0 to XR15, and XR0 to XR15 become FR0 to FR15. When FPSCR.FR = 0,<br />FPR0_BANK0 to FPR15_BANK0 correspond to FR0 to FR15, and FPR0_BANK1 to<br />FPR15_BANK1 correspond to XR0 to XR15. When FPSCR.FR = 1, FPR0_BANK1 to<br />FPR15_BANK1 correspond to FR0 to FR15, and FPR0_BANK0 to FPR15_BANK0 correspond<br />to XR0 to XR15.<br /><br /><br />",
      "operation": "void FRCHG (void)\n{\n  if (FPSCR_PR == 0)\n  {\n    FPSCR ^= 0x00200000;  // toggle bit 21\n    PC += 2;\n  }\n  else\n    undefined_operation ();\n}\n"
    },
    {
      "group": "Floating-Point Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": true,
      "SH4.issue": 1,
      "SH4.latency": 1,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": true,
      "SH2A.issue": 1,
      "SH2A.latency": 1,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fschg",
      "abstract": "If FPSCR.PR = 0: ~FPSCR.SZ -> FPSCR.SZ\nElse: Undefined Operation",
      "code": "1111001111111101",
      "T": "-",
      "description": "Inverts the SZ bit of the floating-point status register FPSCR. Changing the<br />value of the SZ bit in FPSCR switches the amount of data for transfer by the<br />FMOV instruction between one single-precision data and a pair of<br />single-precision data. When FPSCR.SZ = 0, an FMOV instruction transfers a<br />single-precision number. When FPSCR.SZ = 1, the FMOV instruction transfers a<br />pair of single-precision numbers.<br /><br /><br />",
      "operation": "void FSCHG (void)\n{\n  if (FPSCR_PR == 0)\n  {\n    FPSCR ^= 0x00100000;  // toggle bit 20\n    PC += 2;\n  }\n  else\n    undefined_operation ();\n}\n"
    },
    {
      "group": "Floating-Point Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": true,
      "SH4A.issue": 1,
      "SH4A.latency": 1,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": false,
      "DSP.issue": 0,
      "DSP.latency": 0,
      "format": "fpchg",
      "abstract": "~FPSCR.PR -> FPSCR.PR",
      "code": "1111011111111101",
      "T": "-",
      "description": "Inverts the PR bit of the floating-point status register FPSCR. The value of<br />this bit selects single-precision or double-precision operation.<br /><br /><br />",
      "operation": "void FPCHG (void)\n{\n  FPSCR ^= 0x00080000;  // toggle bit 19\n  PC += 2;\n}\n"
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "nopx",
      "abstract": "No operation",
      "code": "1111000*0*0*00**",
      "T": "-",
      "description": "\nDescriptionNo access operation for X memory.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movx.w\t@Ax,Dx",
      "abstract": "(Ax) -> MSW of Dx, 0 -> LSW of Dx",
      "code": "111100A*D*0*01**",
      "T": "-",
      "description": "\nDescriptionTransfers the memory source operand data to the destination register operand.\nThe transferred data can only be word length for X memory. The word data is\nloaded to the top word of the register and the bottom word is cleared with\nzeros.\n\n\nNote\"*\" of the instruction code is MOVY instruction designation area.\n\nMSW = High-order word of operand.\n\nLSW = Low-order word of operand.\n\n\nExampleMOVX.W  @R4,X0   ! Before execution: R4 = 0x08010000, @R4 = 0x5555, X0 = 0x12345678\n                 ! After execution:  R4 = 0x08010000, X0 = 0x55550000\n\n\n",
      "operation": "MOVX.W  @R4,X0   ! Before execution: R4 = 0x08010000, @R4 = 0x5555, X0 = 0x12345678\n                 ! After execution:  R4 = 0x08010000, X0 = 0x55550000\n"
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movx.w\t@Ax+,Dx",
      "abstract": "(Ax) -> MSW of Dx, 0 -> LSW of Dx, Ax+2 -> Ax",
      "code": "111100A*D*0*10**",
      "T": "-",
      "description": "\nDescriptionTransfers the memory source operand data to the destination register operand.\nThe transferred data can only be word length for X memory. The word data is\nloaded to the top word of the register and the bottom word is cleared with\nzeros.\n\n\nNote\"*\" of the instruction code is MOVY instruction designation area.\n\nMSW = High-order word of operand.\n\nLSW = Low-order word of operand.\n\n\nExampleMOVX.W  @R4+,X0  ! Before execution: R4 = 0x08010000, @R4 = 0x5555, X0 = 0x12345678\n                 ! After execution:  R4 = 0x08010002, X0 = 0x55550000\n\n\n",
      "operation": "MOVX.W  @R4+,X0  ! Before execution: R4 = 0x08010000, @R4 = 0x5555, X0 = 0x12345678\n                 ! After execution:  R4 = 0x08010002, X0 = 0x55550000\n"
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movx.w\t@Ax+Ix,Dx",
      "abstract": "(Ax) -> MSW of Dx, 0 -> LSW of Dx, Ax+Ix -> Ax",
      "code": "111100A*D*0*11**",
      "T": "-",
      "description": "\nDescriptionTransfers the memory source operand data to the destination register operand.\nThe transferred data can only be word length for X memory. The word data is\nloaded to the top word of the register and the bottom word is cleared with\nzeros.\n\n\nNote\"*\" of the instruction code is MOVY instruction designation area.\n\nMSW = High-order word of operand.\n\nLSW = Low-order word of operand.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movx.w\tDa,@Ax",
      "abstract": "MSW of Da -> (Ax)",
      "code": "111100A*D*1*01**",
      "T": "-",
      "description": "\nDescriptionTransfers the register source operand data to the destination memory operand.\nThe transferred data can only be word length for X memory. The source word data\nis the top word of the register.\n\n\nNote\"*\" of the instruction code is MOVY instruction designation area.\n\nMSW = High-order word of operand.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movx.w\tDa,@Ax+",
      "abstract": "MSW of Da -> (Ax), Ax+2 -> Ax",
      "code": "111100A*D*1*10**",
      "T": "-",
      "description": "\nDescriptionTransfers the register source operand data to the destination memory operand.\nThe transferred data can only be word length for X memory. The source word data\nis the top word of the register.\n\n\nNote\"*\" of the instruction code is MOVY instruction designation area.\n\nMSW = High-order word of operand.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movx.w\tDa,@Ax+Ix",
      "abstract": "MSW of Da -> (Ax), Ax+Ix -> Ax",
      "code": "111100A*D*1*11**",
      "T": "-",
      "description": "\nDescriptionTransfers the register source operand data to the destination memory operand.\nThe transferred data can only be word length for X memory. The source word data\nis the top word of the register.\n\n\nNote\"*\" of the instruction code is MOVY instruction designation area.\n\nMSW = High-order word of operand.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "nopy",
      "abstract": "No Operation",
      "code": "111100*0*0*0**00",
      "T": "-",
      "description": "\nDescriptionNo access operation for Y memory.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movy.w\t@Ay,Dy",
      "abstract": "(Ay) -> MSW of Dy, 0 -> LSW of Dy",
      "code": "111100*A*D*0**01",
      "T": "-",
      "description": "\nDescriptionTransfers the memory source operand data to the destination register operand.\nThe transferred data can only be word length for Y memory. The word data is\nloaded to the top word of the register and the bottom word is cleared with\nzeros.\n\n\nNote\"*\" of the instruction code is MOVX instruction designation area.\n\nMSW = High-order word of operand.\n\nLSW = Low-order word of operand.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movy.w\t@Ay+,Dy",
      "abstract": "(Ay) -> MSW of Dy, 0 -> LSW of Dy, Ay+2 -> Ay",
      "code": "111100*A*D*0**10",
      "T": "-",
      "description": "\nDescriptionTransfers the memory source operand data to the destination register operand.\nThe transferred data can only be word length for Y memory. The word data is\nloaded to the top word of the register and the bottom word is cleared with\nzeros.\n\n\nNote\"*\" of the instruction code is MOVX instruction designation area.\n\nMSW = High-order word of operand.\n\nLSW = Low-order word of operand.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movy.w\t@Ay+Iy,Dy",
      "abstract": "(Ay) -> MSW of Dy, 0 -> LSW of Dy, Ay+Iy -> Ay",
      "code": "111100*A*D*0**11",
      "T": "-",
      "description": "\nDescriptionTransfers the memory source operand data to the destination register operand.\nThe transferred data can only be word length for Y memory. The word data is\nloaded to the top word of the register and the bottom word is cleared with\nzeros.\n\n\nNote\"*\" of the instruction code is MOVX instruction designation area.\n\nMSW = High-order word of operand.\n\nLSW = Low-order word of operand.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movy.w\tDa,@Ay",
      "abstract": "MSW of Da -> (Ay)",
      "code": "111100*A*D*1**01",
      "T": "-",
      "description": "\nDescriptionTransfers the register source operand data to the destination memory operand.\nThe transferred data can only be word length for Y memory. The source word data\nis the top word of the register.\n\n\nNote\"*\" of the instruction code is MOVX instruction designation area.\n\nMSW = High-order word of operand.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movy.w\tDa,@Ay+",
      "abstract": "MSW of Da -> (Ay), Ay+2 -> Ay",
      "code": "111100*A*D*1**10",
      "T": "-",
      "description": "\nDescriptionTransfers the register source operand data to the destination memory operand.\nThe transferred data can only be word length for Y memory. The source word data\nis the top word of the register.\n\n\nNote\"*\" of the instruction code is MOVX instruction designation area.\n\nMSW = High-order word of operand.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movy.w\tDa,@Ay+Iy",
      "abstract": "MSW of Da -> (Ay), Ay+Iy -> Ay",
      "code": "111100*A*D*1**11",
      "T": "-",
      "description": "\nDescriptionTransfers the register source operand data to the destination memory operand.\nThe transferred data can only be word length for Y memory. The source word data\nis the top word of the register.\n\n\nNote\"*\" of the instruction code is MOVX instruction designation area.\n\nMSW = High-order word of operand.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.w\t@-As,Ds",
      "abstract": "As-2 -> As, (As) -> MSW of Ds, 0 -> LSW of Ds",
      "code": "111101AADDDD0000",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nword, the word data is loaded to the top word of the register and the bottom\nword is cleared with zeros.  When the destination operand is a register with\nguard bits, the sign is extended and stored in the guard bits.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.w\t@As,Ds",
      "abstract": "(As) -> MSW of Ds, 0 -> LSW of Ds",
      "code": "111101AADDDD0100",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nword, the word data is loaded to the top word of the register and the bottom\nword is cleared with zeros.  When the destination operand is a register with\nguard bits, the sign is extended and stored in the guard bits.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.w\t@As+,Ds",
      "abstract": "(As) -> MSW of Ds, 0 -> LSW of Ds, As+2 -> As",
      "code": "111101AADDDD1000",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nword, the word data is loaded to the top word of the register and the bottom\nword is cleared with zeros.  When the destination operand is a register with\nguard bits, the sign is extended and stored in the guard bits.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.w\t@As+Ix,Ds",
      "abstract": "(As) -> MSW of Ds, 0 -> LSW of DS, As+Ix -> As",
      "code": "111101AADDDD1100",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nword, the word data is loaded to the top word of the register and the bottom\nword is cleared with zeros.  When the destination operand is a register with\nguard bits, the sign is extended and stored in the guard bits.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.w\tDs,@-As",
      "abstract": "As-2 -> As, MSW of Ds -> (As)",
      "code": "111101AADDDD0001",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nword, the top word of the register is stored as the word data.\n\n\nNoteWhen one of the guard bit registers A0G and A1G is the source operand it is\nsign extended and stored as a word.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.w\tDs,@As",
      "abstract": "MSW of Ds -> (As)",
      "code": "111101AADDDD0101",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nword, the top word of the register is stored as the word data.\n\n\nNoteWhen one of the guard bit registers A0G and A1G is the source operand it is\nsign extended and stored as a word.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.w\tDs,@As+",
      "abstract": "MSW of Ds -> (As), As+2 -> As",
      "code": "111101AADDDD1001",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nword, the top word of the register is stored as the word data.\n\n\nNoteWhen one of the guard bit registers A0G and A1G is the source operand it is\nsign extended and stored as a word.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.w\tDs,@As+Is",
      "abstract": "MSW of DS -> (As), As+Is -> As",
      "code": "111101AADDDD1101",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nword, the top word of the register is stored as the word data.\n\n\nNoteWhen one of the guard bit registers A0G and A1G is the source operand it is\nsign extended and stored as a word.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.l\t@-As,Ds",
      "abstract": "As-4 -> As, (As) -> Ds",
      "code": "111101AADDDD0010",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nlongword.  When the destination operand is a register with guard bits, the sign\nis extended and stored in the guard bits.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.l\t@As,Ds",
      "abstract": "(As) -> Ds",
      "code": "111101AADDDD0110",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nlongword.  When the destination operand is a register with guard bits, the sign\nis extended and stored in the guard bits.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.l\t@As+,Ds",
      "abstract": "(As) -> Ds, As+4 -> As",
      "code": "111101AADDDD1010",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nlongword.  When the destination operand is a register with guard bits, the sign\nis extended and stored in the guard bits.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.l\t@As+Is,Ds",
      "abstract": "(As) -> Ds, As+Is -> As",
      "code": "111101AADDDD1110",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nlongword.  When the destination operand is a register with guard bits, the sign\nis extended and stored in the guard bits.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.l\tDs,@-As",
      "abstract": "As-4 -> As, Ds -> (As)",
      "code": "111101AADDDD0011",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nlongword.\n\n\nNoteWhen one of the guard bit registers A0G and A1G is the source operand it is\nsign extended and stored as a word.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.l\tDs,@As",
      "abstract": "Ds -> (As)",
      "code": "111101AADDDD0111",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nlongword.\n\n\nNoteWhen one of the guard bit registers A0G and A1G is the source operand it is\nsign extended and stored as a word.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.l\tDs,@As+",
      "abstract": "Ds -> (As), As+4 -> As",
      "code": "111101AADDDD1011",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nlongword.\n\n\nNoteWhen one of the guard bit registers A0G and A1G is the source operand it is\nsign extended and stored as a word.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP Data Transfer Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "movs.l\tDs,@As+Is",
      "abstract": "Ds -> (As), As+Is -> As",
      "code": "111101AADDDD1111",
      "T": "-",
      "description": "\nDescriptionTransfers the source operand data to the destination. The transferred data is a\nlongword.\n\n\nNoteWhen one of the guard bit registers A0G and A1G is the source operand it is\nsign extended and stored as a word.\n\n\n",
      "operation": null
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pabs\t\tSx,Dz",
      "abstract": "If Sx >= 0: Sx -> Dz\nIf Sx < 0: 0 - Sx -> Dz",
      "code": "111110********** 10001000xx00zzzz",
      "T": "-",
      "description": "Finds absolute values. When the Sx operand is positive, the contents of the<br />operand are transferred to the Dz operand. If the value is negative, the value<br />of the Sx operand is subtracted from 0 and stored in the Dz operand.<br /><br />The DC bit of the DSR register are updated according to the specifications of<br />the CS bits. The N, Z, V, and GT bits of the DSR register are updated.<br /><br /><br />",
      "operation": "void pabs_sx (void)\n{\n  DSP_ALU_SRC1 = 0;\n  DSP_ALU_SRC1G = 0;\n\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = X0;\n    if (DSP_ALU_SRC2_MSB)\n      DSP_ALU_SRC2G = 0xFF;\n    else\n      DSP_ALU_SRC2G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = X1;\n    if (DSP_ALU_SRC2_MSB)\n      DSP_ALU_SRC2G = 0xFF;\n    else\n      DSP_ALU_SRC2G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = A0;\n    DSP_ALU_SRC2G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = A1;\n    DSP_ALU_SRC2G = A1G;\n    break;\n  }\n\n  if (DSP_ALU_SRC2G_BIT7 == 0)\n  {\n    // positive value\n    DSP_ALU_DST = 0x0 + DSP_ALU_SRC2;\n    carry_bit = 0;\n    DSP_ALU_DSTG_LSB8 = 0x0 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  }\n  else\n  {\n    // negative value\n    DSP_ALU_DST = 0x0 - DSP_ALU_SRC2;\n    borrow_bit = 1;\n    DSP_ALU_DSTG_LSB8 = 0x0 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  }\n\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n  #include &quot;fixed_pt_unconditional_update.c&quot;\n\n  if (DSP_ALU_SRC2G_BIT7 == 0)\n  {\n    #include &quot;fixed_pt_plus_dc_bit.c&quot;\n  }\n  else\n  {\n    overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n    #include &quot;fixed_pt_minus_dc_bit.c&quot;\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pabs\t\tSy,Dz",
      "abstract": "If Sy >= 0: Sy -> Dz\nIf Sy < 0: 0 - Sy -> Dz",
      "code": "111110********** 1010100000yyzzzz",
      "T": "-",
      "description": "Finds absolute values. When the Sy operand is positive, the contents of the<br />operand are transferred to the Dz operand. If the value is negative, the value<br />of the Sy operand is subtracted from 0 and stored in the Dz operand.<br /><br />The DC bit of the DSR register are updated according to the specifications of<br />the CS bits. The N, Z, V, and GT bits of the DSR register are updated.<br /><br /><br />",
      "operation": "void pabs_sy (void)\n{\n  DSP_ALU_SRC1 = 0;\n  DSP_ALU_SRC1G = 0;\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  if (DSP_ALU_SRC2G_BIT7 == 0)\n  {\n    // positive value\n    DSP_ALU_DST = 0x0 + DSP_ALU_SRC2;\n    carry_bit = 0;\n    DSP_ALU_DSTG_LSB8 = 0x0 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  }\n  else\n  {\n    // negative value\n    DSP_ALU_DST = 0x0 - DSP_ALU_SRC2;\n    borrow_bit = 1;\n    DSP_ALU_DSTG_LSB8 = 0x0 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  }\n\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n  #include &quot;fixed_pt_unconditional_update.c&quot;\n\n  if (DSP_ALU_SRC2G_BIT7 == 0)\n  {\n    #include &quot;fixed_pt_plus_dc_bit.c&quot;\n  }\n  else\n  {\n    overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n    #include &quot;fixed_pt_minus_dc_bit.c&quot;\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "padd\t\tSx,Sy,Dz",
      "abstract": "Sx + Sy -> Dz",
      "code": "111110********** 10110001xxyyzzzz",
      "T": "-",
      "description": "Adds the contents of the Sx and Sy operands and stores the result in the Dz<br />operand.  The DC bit of the DSR register is updated according to the<br />specifications for the CS bits. The N, Z, V, and GT bits of the DSR register<br />are also updated.<br /><br /><br />NoteThe DC bit is updated depending on the state of the CS [2:0] bit immediately<br />before the operation.<br /><br /><br />",
      "operation": "void padd (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n  break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1: DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2: DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3: DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;\n\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  #include &quot;fixed_pt_unconditional_update.c&quot;\n  #include &quot;fixed_pt_plus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct padd\tSx,Sy,Dz",
      "abstract": "If DC = 1: Sx + Sy -> Dz\nElse: nop",
      "code": "111110********** 10110010xxyyzzzz",
      "T": "-",
      "description": "Conditionally adds the contents of the Sx and Sy operands and stores the result<br />in the Dz operand.  The instruction is executed of the DC bit is set to 1.<br />Otherwise no operation is performed.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void padd_dct (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n  break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1: DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2: DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3: DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;\n\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  if (DC == 1)\n  {\n    DSP_REG [ex2_dz_no] = DSP_ALU_DST;\n    if(ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7) A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no==1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf padd\tSx,Sy,Dz",
      "abstract": "If DC = 0: Sx + Sy -> Dz\nElse: nop",
      "code": "111110********** 10110011xxyyzzzz",
      "T": "-",
      "description": "Conditionally adds the contents of the Sx and Sy operands and stores the result<br />in the Dz operand.  The instruction is executed of the DC bit is set to 0.<br />Otherwise no operation is performed.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void padd_dct (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n  break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1: DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2: DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3: DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;\n\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  if (DC == 0)\n  {\n    DSP_REG [ex2_dz_no] = DSP_ALU_DST;\n    if(ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7) A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no==1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "padd\t\tSx,Sy,Du\npmuls\t\tSe,Sf,Dg",
      "abstract": "Sx + Sy -> Du\nMSW of Se * MSW of Sf -> Dg",
      "code": "111110********** 0111eeffxxyygguu",
      "T": "-",
      "description": "Adds the contents of the Sx and Sy operands and stores the result in the Du<br />operand. The contents of the top word of the Se and Sf operands are multiplied<br />as signed and the result stored in the Dg operand. These two processes are<br />executed simultaneously in parallel.<br /><br />The DC bit of the DSR register is updated according to the results of the ALU<br />operation and the specifications for the CS bits. The N, Z, V, and GT bits of<br />the DSR register are also updated according to the results of the ALU operation.<br /><br /><br />NoteSince the PMULS is fixed decimal point multiplication, the operation result is<br />different from that of MULS even though the source data is the same.<br /><br /><br />",
      "operation": "void padd_pmuls (void)\n{\n  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  switch (EX2_DU)\n  {\n  case 0x0:\n    X0 = DSP_ALU_DST;\n    negative_bit = DSP_ALU_DSTG_BIT7;\n    zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);\n    break;\n\n  case 0x1:\n    Y0 = DSP_ALU_DST;\n    negative_bit = DSP_ALU_DSTG_BIT7;\n    zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);\n    break;\n\n  case 0x2:\n    A0 = DSP_ALU_DST;\n    A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n    if (DSP_ALU_DSTG_BIT7)\n      A0G = A0G | MASKFFFFFF00;\n    negative_bit = DSP_ALU_DSTG_BIT7;\n    zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);\n    break;\n\n  case 0x3:\n    A1 = DSP_ALU_DST;\n    A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n    if (DSP_ALU_DSTG_BIT7)\n      A1G = A1G | MASKFFFFFF00;\n    negative_bit = DSP_ALU_DSTG_BIT7;\n    zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);\n    break;\n  }\n\n  #include &quot;fixed_pt_plus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "paddc\t\tSx,Sy,Dz",
      "abstract": "Sx + Sy + DC -> Dz",
      "code": "111110********** 10110000xxyyzzzz",
      "T": "-",
      "description": "Adds the contents of the Sx and Sy operands to the DC bit and stores the result<br />in the Dz operand. The DC bit of the DSR register is updated as the carry flag.<br />The N, Z, V, and GT bits of the DSR register are also updated.<br /><br /><br /><br />NoteThe DC bit is updated as the carry flag after execution of the PADDC instruction<br />regardless of the CS bits.<br /><br />CS[2:0] = ***: Always operate as Carry or Borrow mode, regardless of the status<br />of the DC bit.<br /><br /><br />",
      "operation": "void paddc (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2 + DSPDCBIT;\n\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n  #include &quot;fixed_pt_unconditional_update.c&quot;\n  #include &quot;fixed_pt_dc_always_carry.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pclr\t\tDz",
      "abstract": "0x00000000 -> Dz",
      "code": "111110********** 100011010000zzzz",
      "T": "-",
      "description": "Clears the Dz operand.  The DC bit of the DSR register is updated according to<br />the specifications for the CS bits. The Z bit of the DSR register is set to 1.<br />The N, V, and GT bits are cleared to 0.<br /><br /><br />",
      "operation": "void pclr (void)\n{\n  DSP_REG[ex2_dz_no] = 0x0;\n\n  if (ex2_dz_no == 0)\n    A0G = 0x0;\n  else if (ex2_dz_no == 1)\n    A1G = 0x0;\n\n  carry_bit = 0;\n  negative_bit = 0;\n  zero_bit = 1;\n  overflow_bit = 0;\n\n  #include &quot;fixed_pt_plus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pclr\tDz",
      "abstract": "If DC = 1: 0x00000000 -> Dz\nElse: nop",
      "code": "111110********** 100011100000zzzz",
      "T": "-",
      "description": "Conditionally clears the Dz operand.  The instruction is executed when the DC<br />bit is set to 1.  The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pclr_dct (void)\n{\n  if (DC == 1)\n    DSP_REG[ex2_dz_no] = 0x0;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pclr\tDz",
      "abstract": "If DC = 0: 0x00000000 -> Dz\nElse: nop",
      "code": "111110********** 100011110000zzzz",
      "T": "-",
      "description": "Conditionally clears the Dz operand.  The instruction is executed when the DC<br />bit is set to 0.  The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pclr_dcf (void)\n{\n  if (DC == 0)\n    DSP_REG[ex2_dz_no] = 0x0;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pcmp\t\tSx,Sy",
      "abstract": "Sx - Sy",
      "code": "111110********** 10000100xxyy0000",
      "T": "-",
      "description": "Subtracts the contents of the Sy operand from the Sx operand. The DC bit of the<br />DSR register is updated according to the specifications for the CS bits.<br />The N, Z, V, and GT bits of the DSR register are also updated.<br /><br /><br />",
      "operation": "void pcmp (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;\n\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n\n  borrow_bit = ! carry_bit;\n\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  \n  negative_bit = DSP_ALU_DSTG_BIT7;\n  zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);\n  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n  #include &quot;fixed_pt_minus_dc_bit.c&quot;\n\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pcopy\t\tSx,Dz",
      "abstract": "Sx -> Dz",
      "code": "111110********** 11011001xx00zzzz",
      "T": "-",
      "description": "Stores the Sx operand in the Dz operand.  The DC bit of the DSR register<br />is updated according to the specifications for the CS bits. The N, Z, V, and GT<br />bits are also updated.<br /><br /><br />",
      "operation": "void pcopy_sx (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  DSP_ALU_SRC2 = 0;\n  DSP_ALU_SRC2G = 0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n  #include &quot;fixed_pt_unconditional_update.c&quot;\n  #include &quot;fixed_pt_plus_dc_bit.c&quot;\n}\n\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pcopy\t\tSy,Dz",
      "abstract": "Sy -> Dz",
      "code": "111110********** 1111100100yyzzzz",
      "T": "-",
      "description": "Stores the Sy operand in the Dz operand.  The DC bit of the DSR register<br />is updated according to the specifications for the CS bits. The N, Z, V, and GT<br />bits are also updated.<br /><br /><br />",
      "operation": "void pcopy_sy (void)\n{\n  DSP_ALU_SRC1 = 0;\n  DSP_ALU_SRC1G = 0;\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n  #include &quot;fixed_pt_unconditional_update.c&quot;\n  #include &quot;fixed_pt_plus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pcopy\tSx,Dz",
      "abstract": "If DC = 1: Sx -> Dz\nElse: nop",
      "code": "111110********** 11011010xx00zzzz",
      "T": "-",
      "description": "Conditionally stores the Sx operand in the Dz operand.  The instruction<br />is executed if the DC bit is set to 1.  The DC, N, Z, V, and GT bits are not<br />updated.<br /><br /><br />",
      "operation": "void pcopy_sx_dct (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  DSP_ALU_SRC2 = 0;\n  DSP_ALU_SRC2G = 0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  if (DC == 1)\n  {\n    DSP_REG[ex2_dz_no] = DSP_ALU_DST;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pcopy\tSy,Dz",
      "abstract": "If DC = 1: Sy -> Dz\nElse: nop",
      "code": "111110********** 1111101000yyzzzz",
      "T": "-",
      "description": "Conditionally stores the Sy operand in the Dz operand.  The instruction<br />is executed if the DC bit is set to 1.  The DC, N, Z, V, and GT bits are not<br />updated.<br /><br /><br />",
      "operation": "void pcopy_sy_dct (void)\n{\n  DSP_ALU_SRC1 = 0;\n  DSP_ALU_SRC1G = 0;\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  if (DC == 1)\n  {\n    DSP_REG[ex2_dz_no] = DSP_ALU_DST;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pcopy\tSx,Dz",
      "abstract": "If DC = 0: Sx -> Dz\nElse: nop",
      "code": "111110********** 11011011xx00zzzz",
      "T": "-",
      "description": "Conditionally stores the Sx operand in the Dz operand.  The instruction<br />is executed if the DC bit is set to 0.  The DC, N, Z, V, and GT bits are not<br />updated.<br /><br /><br />",
      "operation": "void pcopy_sx_dcf (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  DSP_ALU_SRC2 = 0;\n  DSP_ALU_SRC2G = 0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  if (DC == 0)\n  {\n    DSP_REG[ex2_dz_no] = DSP_ALU_DST;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pcopy\tSy,Dz",
      "abstract": "If DC = 0: Sy -> Dz\nElse: nop",
      "code": "111110********** 1111101100yyzzzz",
      "T": "-",
      "description": "Conditionally stores the Sy operand in the Dz operand.  The instruction<br />is executed if the DC bit is set to 0.  The DC, N, Z, V, and GT bits are not<br />updated.<br /><br /><br />",
      "operation": "void pcopy_sy_dcf (void)\n{\n  DSP_ALU_SRC1 = 0;\n  DSP_ALU_SRC1G = 0;\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 + DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  if (DC == 0)\n  {\n    DSP_REG[ex2_dz_no] = DSP_ALU_DST;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pneg\t\tSx,Dz",
      "abstract": "0 - Sx -> Dz",
      "code": "111110********** 11001001xx00zzzz",
      "T": "-",
      "description": "Reverses the sign. Subtracts the Sx operand from 0 and stores the result in<br />the Dz operand.  The DC bit of the DSR register is updated according to the<br />specifications for the CS bits. The N, Z, V, and GT bits of the DSR register<br />are also updated.<br /><br /><br />",
      "operation": "void pneg_sx (void)\n{\n  DSP_ALU_SRC1 = 0;\n  DSP_ALU_SRC1G = 0;\n\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = X0;\n    if (DSP_ALU_SRC2_MSB)\n      DSP_ALU_SRC2G = 0xFF;\n    else\n      DSP_ALU_SRC2G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = X1;\n    if (DSP_ALU_SRC2_MSB)\n      DSP_ALU_SRC2G = 0xFF;\n    else\n      DSP_ALU_SRC2G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = A0;\n    DSP_ALU_SRC2G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = A1;\n    DSP_ALU_SRC2G = A1G;\n    break;\n  }\n\n  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n  #include &quot;fixed_pt_unconditional_update.c&quot;\n  #include &quot;fixed_pt_minus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pneg\t\tSy,Dz",
      "abstract": "0 - Sy -> Dz",
      "code": "111110********** 1110100100yyzzzz",
      "T": "-",
      "description": "Reverses the sign. Subtracts the Sy operand from 0 and stores the result in<br />the Dz operand.  The DC bit of the DSR register is updated according to the<br />specifications for the CS bits. The N, Z, V, and GT bits of the DSR register<br />are also updated.<br /><br /><br />",
      "operation": "void pneg_sy (void)\n{\n  DSP_ALU_SRC1 = 0;\n  DSP_ALU_SRC1G = 0;\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n  #include &quot;fixed_pt_unconditional_update.c&quot;\n  #include &quot;fixed_pt_minus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pneg\tSx,Dz",
      "abstract": "If DC = 1: 0 - Sx -> Dz\nElse: nop",
      "code": "111110********** 11001010xx00zzzz",
      "T": "-",
      "description": "Conditionally reverses the sign.  The instruction is executed if the DC bit is<br />set to 1.  Subtracts the Sx operand from 0 and stores the result in the Dz<br />operand.  The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pneg_sx_dct (void)\n{\n  DSP_ALU_SRC1 = 0;\n  DSP_ALU_SRC1G = 0;\n\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = X0;\n    if (DSP_ALU_SRC2_MSB)\n      DSP_ALU_SRC2G = 0xFF;\n    else\n      DSP_ALU_SRC2G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = X1;\n    if (DSP_ALU_SRC2_MSB)\n      DSP_ALU_SRC2G = 0xFF;\n    else\n      DSP_ALU_SRC2G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = A0;\n    DSP_ALU_SRC2G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = A1;\n    DSP_ALU_SRC2G = A1G;\n    break;\n  }\n\n  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  if (DC == 1)\n  {\n    DSP_REG[ex2_dz_no] = DSP_ALU_DST;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pneg\tSy,Dz",
      "abstract": "If DC = 1: 0 - Sy -> Dz\nElse: nop",
      "code": "111110********** 1110101000yyzzzz",
      "T": "-",
      "description": "Conditionally reverses the sign.  The instruction is executed if the DC bit is<br />set to 1.  Subtracts the Sy operand from 0 and stores the result in the Dz<br />operand.  The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pneg_sy_dct (void)\n{\n  DSP_ALU_SRC1 = 0;\n  DSP_ALU_SRC1G = 0;\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  if (DC == 1)\n  {\n    DSP_REG[ex2_dz_no] = DSP_ALU_DST;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pneg\tSx,Dz",
      "abstract": "If DC = 0: 0 - Sx -> Dz\nElse: nop",
      "code": "111110********** 11001011xx00zzzz",
      "T": "-",
      "description": "Conditionally reverses the sign.  The instruction is executed if the DC bit is<br />set to 0.  Subtracts the Sx operand from 0 and stores the result in the Dz<br />operand.  The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pneg_sx_dcf (void)\n{\n  DSP_ALU_SRC1 = 0;\n  DSP_ALU_SRC1G = 0;\n\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = X0;\n    if (DSP_ALU_SRC2_MSB)\n      DSP_ALU_SRC2G = 0xFF;\n    else\n      DSP_ALU_SRC2G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = X1;\n    if (DSP_ALU_SRC2_MSB)\n      DSP_ALU_SRC2G = 0xFF;\n    else\n      DSP_ALU_SRC2G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = A0;\n    DSP_ALU_SRC2G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = A1;\n    DSP_ALU_SRC2G = A1G;\n    break;\n  }\n\n  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  if (DC == 0)\n  {\n    DSP_REG[ex2_dz_no] = DSP_ALU_DST;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pneg\tSy,Dz",
      "abstract": "If DC = 0: 0 - Sy -> Dz\nElse: nop",
      "code": "111110********** 1110101100yyzzzz",
      "T": "-",
      "description": "Conditionally reverses the sign.  The instruction is executed if the DC bit is<br />set to 0.  Subtracts the Sy operand from 0 and stores the result in the Dz<br />operand.  The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pneg_sy_dcf (void)\n{\n  DSP_ALU_SRC1 = 0;\n  DSP_ALU_SRC1G = 0;\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  if (DC == 0)\n  {\n    DSP_REG[ex2_dz_no] = DSP_ALU_DST;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "psub\t\tSx,Sy,Dz",
      "abstract": "Sx - Sy -> Dz",
      "code": "111110********** 10100001xxyyzzzz",
      "T": "-",
      "description": "Subtracts the contents of the Sy operand from the Sx operand and stores the<br />result in the Dz operand.  The DC bit of the DSR register is updated according<br />to the specifications for the CS bits. The N, Z, V, and GT bits of the DSR<br />register are updated.<br /><br /><br />",
      "operation": "void psub (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n  #include &quot;fixed_pt_unconditional_update.c&quot;\n  #include &quot;fixed_pt_minus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct psub\tSx,Sy,Dz",
      "abstract": "If DC = 1: Sx - Sy -> Dz\nElse: nop",
      "code": "111110********** 10100010xxyyzzzz",
      "T": "-",
      "description": "Conditionally subtracts the contents of the Sy operand from the Sx operand and<br />stores the result in the Dz operand.  The instruction is executed if the DC bit<br />is set to 1.  The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void psub_dct (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  if (DC == 1)\n  {\n    DSP_REG[ex2_dz_no] = DSP_ALU_DST;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf psub \tSx,Sy,Dz",
      "abstract": "If DC = 0: Sx - Sy -> Dz\nElse: nop",
      "code": "111110********** 10100011xxyyzzzz",
      "T": "-",
      "description": "Conditionally subtracts the contents of the Sy operand from the Sx operand and<br />stores the result in the Dz operand.  The instruction is executed if the DC bit<br />is set to 0.  The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void psub_dct (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  if (DC == 0)\n  {\n    DSP_REG[ex2_dz_no] = DSP_ALU_DST;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "psub\t\tSx,Sy,Du\npmuls\t\tSe,Sf,Dg",
      "abstract": "Sx - Sy -> Du\nMSW of Se * MSW of Sf -> Dg",
      "code": "111110********** 0110eeffxxyygguu",
      "T": "-",
      "description": "Subtracts the contents of the Sy operand from the Sx operand and stores the<br />result in the Du operand. The contents of the top word of the Se and Sf operands<br />are multiplied as signed and the result stored in the Dg operand. These two<br />processes are executed simultaneously in parallel.<br /><br />The DC bit of the DSR register is updated according to the results of the ALU<br />operation and the specifications for the CS bits. The N, Z, V, and GT bits of<br />the DSR register are also updated according to the results of the ALU operation.<br /><br /><br />",
      "operation": "void psub_pmuls (void)\n{\n  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n\n  switch (EX2_DU)\n  {\n  case 0x0:\n    X0 = DSP_ALU_DST;\n    negative_bit = DSP_ALU_DST_MSB;\n    zero_bit = (DSP_ALU_DST == 0);\n    break;\n\n  case 0x1:\n    Y0  = DSP_ALU_DST;\n    negative_bit = DSP_ALU_DST_MSB;\n    zero_bit = (DSP_ALU_DST == 0);\n    break;\n\n  case 0x2:\n    A0 = DSP_ALU_DST;\n    A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n    if (DSP_ALU_DSTG_BIT7)\n      A0G = A0G | MASKFFFFFF00;\n    negative_bit = DSP_ALU_DSTG_BIT7;\n    zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);\n    break;\n\n  case 0x3:\n    A1 = DSP_ALU_DST;\n    A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n    if (DSP_ALU_DSTG_BIT7)\n      A1G = A1G | MASKFFFFFF00;\n    negative_bit = DSP_ALU_DSTG_BIT7;\n    zero_bit = (DSP_ALU_DST == 0) &amp; (DSP_ALU_DSTG_LSB8 == 0);\n    break;\n  }\n\n  #include &quot;fixed_pt_minus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "psubc\t\tSx,Sy,Dz",
      "abstract": "Sx - Sy - DC -> Dz",
      "code": "111110********** 10100000xxyyzzzz",
      "T": "-",
      "description": "Subtracts the contents of the Sy operand and the DC bit from the Sx operand and<br />stores the result in the Dz operand. The DC bit of the DSR register is updated<br />as the borrow flag. The N, Z, V, and GT bits of the DSR register are also<br />updated.<br /><br /><br />",
      "operation": "void psubc (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  DSP_ALU_DST = DSP_ALU_SRC1 - DSP_ALU_SRC2 - DSPDCBIT;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = MINUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n  #include &quot;fixed_pt_unconditional_update.c&quot;\n  #include &quot;fixed_pt_dc_always_borrow.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pdec\t\tSx,Dz",
      "abstract": "MSW of Sx - 1 -> MSW of Dz, clear LSW of Dz",
      "code": "111110********** 10001001xx00zzzz",
      "T": "-",
      "description": "Subtracts 1 from the top word of the Sx operand, stores the result in the upper<br />word of the Dz operand, and clears the bottom word of the Dz operand with zeros.<br />The DC bit of the DSR register is updated according to the specifications for<br />the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.<br /><br /><br />NoteThe bottom word of the destination register is ignored when the DC bit is<br />updated.<br /><br /><br />",
      "operation": "void pdec_sx (void)\n{\n  DSP_ALU_SRC2 = 0x1;\n  DSP_ALU_SRC2G = 0x0;\n\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;integer_overflow_protection.c&quot;\n  #include &quot;integer_unconditional_update.c&quot;\n  #include &quot;integer_minus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pdec\t\tSy,Dz",
      "abstract": "MSW of Sy - 1 -> MSW of Dz, clear LSW of Dz",
      "code": "111110********** 1010100100yyzzzz",
      "T": "-",
      "description": "Subtracts 1 from the top word of the Sy operand, stores the result in the upper<br />word of the Dz operand, and clears the bottom word of the Dz operand with zeros.<br />The DC bit of the DSR register is updated according to the specifications for<br />the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.<br /><br /><br />NoteThe bottom word of the destination register is ignored when the DC bit is<br />updated.<br /><br /><br />",
      "operation": "void pdec_sy (void)\n{\n  DSP_ALU_SRC2 = 0x1;\n  DSP_ALU_SRC2G = 0x0;\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC1_MSB)\n    DSP_ALU_SRC1G = 0xFF;\n  else\n    DSP_ALU_SRC1G = 0x0;\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;integer_overflow_protection.c&quot;\n  #include &quot;integer_unconditional_update.c&quot;\n  #include &quot;integer_minus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pdec\tSx,Dz",
      "abstract": "If DC = 1: MSW of Sx - 1 -> MSW of DZ, clear LSW of Dz\nElse: nop",
      "code": "111110********** 10001010xx00zzzz",
      "T": "-",
      "description": "Conditionally subtracts 1 from the top word of the Sx operand, stores the result<br />in the upper word of the Dz operand, and clears the bottom word of the Dz<br />operand with zeros.  The instruction is executed if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pdec_sx_dct (void)\n{\n  DSP_ALU_SRC2 = 0x1;\n  DSP_ALU_SRC2G = 0x0;\n\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;integer_overflow_protection.c&quot;\n\n  if (DC == 1)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pdec\tSy,Dz",
      "abstract": "If DC = 1: MSW of Sy - 1 -> MSW of DZ, clear LSW of Dz\nElse: nop",
      "code": "111110********** 1010101000yyzzzz",
      "T": "-",
      "description": "Conditionally subtracts 1 from the top word of the Sy operand, stores the result<br />in the upper word of the Dz operand, and clears the bottom word of the Dz<br />operand with zeros.  The instruction is executed if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pdec_sy_dct (void)\n{\n  DSP_ALU_SRC2 = 0x1;\n  DSP_ALU_SRC2G = 0x0;\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC1_MSB)\n    DSP_ALU_SRC1G = 0xFF;\n  else\n    DSP_ALU_SRC1G = 0x0;\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;integer_overflow_protection.c&quot;\n\n  if (DC == 1)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pdec\tSx,Dz",
      "abstract": "If DC = 0: MSW of Sx - 1 -> MSW of DZ, clear LSW of Dz\nElse: nop",
      "code": "111110********** 10001011xx00zzzz",
      "T": "-",
      "description": "Conditionally subtracts 1 from the top word of the Sx operand, stores the result<br />in the upper word of the Dz operand, and clears the bottom word of the Dz<br />operand with zeros.  The instruction is executed if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pdec_sx_dcf (void)\n{\n  DSP_ALU_SRC2 = 0x1;\n  DSP_ALU_SRC2G = 0x0;\n\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;integer_overflow_protection.c&quot;\n\n  if (DC == 0)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pdec\tSy,Dz",
      "abstract": "If DC = 0: MSW of Sy - 1 -> MSW of DZ, clear LSW of Dz\nElse: nop",
      "code": "111110********** 1010101100yyzzzz",
      "T": "-",
      "description": "Conditionally subtracts 1 from the top word of the Sy operand, stores the result<br />in the upper word of the Dz operand, and clears the bottom word of the Dz<br />operand with zeros.  The instruction is executed if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pdec_sy_dcf (void)\n{\n  DSP_ALU_SRC2 = 0x1;\n  DSP_ALU_SRC2G = 0x0;\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC1_MSB)\n    DSP_ALU_SRC1G = 0xFF;\n  else\n    DSP_ALU_SRC1G = 0x0;\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW - 1;\n  carry_bit = ((DSP_ALU_SRC1_MSB | ! DSP_ALU_SRC2_MSB) &amp;&amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; ! DSP_ALU_SRC2_MSB);\n  borrow_bit = ! carry_bit;\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 - DSP_ALU_SRC2G_LSB8 - borrow_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;integer_overflow_protection.c&quot;\n\n  if (DC == 0)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pinc\t\tSx,Dz",
      "abstract": "MSW of Sy + 1 -> MSW of Dz, clear LSW of Dz",
      "code": "111110********** 10011001xx00zzzz",
      "T": "-",
      "description": "Adds 1 to the top word of the Sx operand, stores the result in the upper word<br />of the Dz operand, and clears the bottom word of the Dz operand with zeros.<br />The DC bit of the DSR register is updated according to the specifications for<br />the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.<br /><br /><br />",
      "operation": "void pinc_sx (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;integer_overflow_protection.c&quot;\n  #include &quot;integer_unconditional_update.c&quot;\n  #include &quot;integer_plus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pinc\t\tSy,Dz",
      "abstract": "MSW of Sy + 1 -> MSW of Dz, clear LSW of Dz",
      "code": "111110********** 1011100100yyzzzz",
      "T": "-",
      "description": "Adds 1 to the top word of the Sy operand, stores the result in the upper word<br />of the Dz operand, and clears the bottom word of the Dz operand with zeros.<br />The DC bit of the DSR register is updated according to the specifications for<br />the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.<br /><br /><br />",
      "operation": "void pinc_sy (void)\n{\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC1_MSB)\n    DSP_ALU_SRC1G = 0xFF;\n  else\n    DSP_ALU_SRC1G = 0x0;\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;integer_overflow_protection.c&quot;\n  #include &quot;integer_unconditional_update.c&quot;\n  #include &quot;integer_plus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pinc\tSx,Dz",
      "abstract": "If DC = 1: MSW of Sx + 1 -> MSW of Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 10011010xx00zzzz",
      "T": "-",
      "description": "Conditionally adds 1 to the top word of the Sx operand, stores the result in the<br />upper word of the Dz operand, and clears the bottom word of the Dz operand with<br />zeros. The instruction is executed if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pinc_sx_dct (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;integer_overflow_protection.c&quot;\n\n  if (DC == 1)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pinc\tSy,Dz",
      "abstract": "If DC = 1: MSW of Sy + 1 -> MSW of Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 1011101000yyzzzz",
      "T": "-",
      "description": "Conditionally adds 1 to the top word of the Sy operand, stores the result in the<br />upper word of the Dz operand, and clears the bottom word of the Dz operand with<br />zeros. The instruction is executed if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pinc_sy_dct (void)\n{\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC1_MSB)\n    DSP_ALU_SRC1G = 0xFF;\n  else\n    DSP_ALU_SRC1G = 0x0;\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;integer_overflow_protection.c&quot;\n\n  if (DC == 1)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pinc\tSx,Dz",
      "abstract": "If DC = 0: MSW of Sx + 1 -> MSW of Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 10011011xx00zzzz",
      "T": "-",
      "description": "Conditionally adds 1 to the top word of the Sx operand, stores the result in the<br />upper word of the Dz operand, and clears the bottom word of the Dz operand with<br />zeros. The instruction is executed if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pinc_sx_dcf (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;integer_overflow_protection.c&quot;\n\n  if (DC == 0)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pinc\tSy,Dz",
      "abstract": "If DC = 0: MSW of Sy + 1 -> MSW of Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 1011101100yyzzzz",
      "T": "-",
      "description": "Conditionally adds 1 to the top word of the Sy operand, stores the result in the<br />upper word of the Dz operand, and clears the bottom word of the Dz operand with<br />zeros. The instruction is executed if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pinc_sy_dcf (void)\n{\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC1_MSB)\n    DSP_ALU_SRC1G = 0xFF;\n  else\n    DSP_ALU_SRC1G = 0x0;\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW + 1;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;integer_overflow_protection.c&quot;\n\n  if (DC == 0)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pdmsb\t\tSx,Dz",
      "abstract": "Sx data MSB position -> MSW of Dz, clear LSW of Dz",
      "code": "111110********** 10011101xx00zzzz",
      "T": "-",
      "description": "Finds the first position to change in the lineup of Sx operand bits and stores<br />the bit position in the Dz operand.  The DC bit of the DSR register is updated<br />according to the specifications for the CS bits. The N, Z, V, and GT bits of the<br />DSR register are also updated. <br /><br /><br />",
      "operation": "void pdmsb_sx (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  short int i;\n  unsigned char msb, src1g;\n  unsigned long src1 = DSP_ALU_SRC1;\n  msb = DSP_ALU_SRC1G_BIT7;\n  src1g = (DSP_ALU_SRC1G_LSB8 << 1);\n  for (i = 38; ((msb == (src1g >> 7)) && (i >= 32)); i--)\n    src1g <<= 1;\n\n  if (i == 31)\n    for(i; ((msb == (src1 >> 31)) && (i >= 0)); i--)\n      src1 <<= 1;\n\n  DSP_ALU_DST = 0x0;\n  DSP_ALU_DST_HW = (short int)(30 - i);\n  if (DSP_ALU_DST_MSB)\n    DSP_ALU_DSTG_LSB8 = 0xFF;\n  else\n    DSP_ALU_DSTG_LSB8 = 0x0;\n\n  carry_bit = 0;\n  overflow_bit = 0;\n\n  #include \"integer_unconditional_update.c\"\n  #include \"integer_plus_dc_bit.c\"\n}"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pdmsb\t\tSy,Dz",
      "abstract": "Sy data MSB position -> MSW of Dz, clear LSW of Dz",
      "code": "111110********** 1011110100yyzzzz",
      "T": "-",
      "description": "Finds the first position to change in the lineup of Sy operand bits and stores<br />the bit position in the Dz operand.  The DC bit of the DSR register is updated<br />according to the specifications for the CS bits. The N, Z, V, and GT bits of the<br />DSR register are also updated. <br /><br /><br />",
      "operation": "void pdmsb_sy (void)\n{\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC1_MSB)\n    DSP_ALU_SRC1G = 0xFF;\n  else\n    DSP_ALU_SRC1G = 0x0;\n\n  short int i;\n  unsigned char msb, src1g;\n  unsigned long src1 = DSP_ALU_SRC1;\n  msb = DSP_ALU_SRC1G_BIT7;\n  src1g = (DSP_ALU_SRC1G_LSB8 << 1);\n  for (i = 38; ((msb == (src1g >> 7)) && (i >= 32)); i--)\n    src1g <<= 1;\n\n  if (i == 31)\n    for(i; ((msb == (src1 >> 31)) && (i >= 0)); i--)\n      src1 <<= 1;\n\n  DSP_ALU_DST = 0x0;\n  DSP_ALU_DST_HW = (short int)(30 - i);\n  if (DSP_ALU_DST_MSB)\n    DSP_ALU_DSTG_LSB8 = 0xFF;\n  else\n    DSP_ALU_DSTG_LSB8 = 0x0;\n\n  carry_bit = 0;\n  overflow_bit = 0;\n\n  #include \"integer_unconditional_update.c\"\n  #include \"integer_plus_dc_bit.c\"\n}"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pdmsb\tSx,Dz",
      "abstract": "If DC = 1: Sx data MSB position -> MSW of Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 10011110xx00zzzz",
      "T": "-",
      "description": "Conditionally finds the first position to change in the lineup of Sx operand<br />bits and stores the bit position in the Dz operand. The instruction is executed<br />if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pdmsb_sx_dct (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  short int i;\n  unsigned char msb, src1g;\n  unsigned long src1 = DSP_ALU_SRC1;\n  msb = DSP_ALU_SRC1G_BIT7;\n  src1g = (DSP_ALU_SRC1G_LSB8 << 1);\n  for (i = 38; ((msb == (src1g >> 7)) && (i >= 32)); i--)\n    src1g <<= 1;\n\n  if (i == 31)\n    for(i; ((msb == (src1 >> 31)) && (i >= 0)); i--)\n      src1 <<= 1;\n\n  DSP_ALU_DST = 0x0;\n  DSP_ALU_DST_HW = (short int)(30 - i);\n  if (DSP_ALU_DST_MSB)\n    DSP_ALU_DSTG_LSB8 = 0xFF;\n  else\n    DSP_ALU_DSTG_LSB8 = 0x0;\n\n  carry_bit = 0;\n\n  if (DC == 1)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG & MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG & MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pdmsb\tSy,Dz",
      "abstract": "If DC = 1: Sy data MSB position -> MSW of Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 1011111000yyzzzz",
      "T": "-",
      "description": "Conditionally finds the first position to change in the lineup of Sy operand<br />bits and stores the bit position in the Dz operand. The instruction is executed<br />if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pdmsb_sy_dct (void)\n{\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC1_MSB)\n    DSP_ALU_SRC1G = 0xFF;\n  else\n    DSP_ALU_SRC1G = 0x0;\n\n  short int i;\n  unsigned char msb, src1g;\n  unsigned long src1 = DSP_ALU_SRC1;\n  msb = DSP_ALU_SRC1G_BIT7;\n  src1g = (DSP_ALU_SRC1G_LSB8 << 1);\n  for (i = 38; ((msb == (src1g >> 7)) && (i >= 32)); i--)\n    src1g <<= 1;\n\n  if (i == 31)\n    for(i; ((msb == (src1 >> 31)) && (i >= 0)); i--)\n      src1 <<= 1;\n\n  DSP_ALU_DST = 0x0;\n  DSP_ALU_DST_HW = (short int)(30 - i);\n  if (DSP_ALU_DST_MSB)\n    DSP_ALU_DSTG_LSB8 = 0xFF;\n  else\n    DSP_ALU_DSTG_LSB8 = 0x0;\n\n  carry_bit = 0;\n\n  if (DC == 1)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG & MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG & MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pdmsb\tSx,Dz",
      "abstract": "If DC = 0: Sx data MSB position -> MSW of Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 10011111xx00zzzz",
      "T": "-",
      "description": "Conditionally finds the first position to change in the lineup of Sx operand<br />bits and stores the bit position in the Dz operand. The instruction is executed<br />if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pdmsb_sx_dcf (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  short int i;\n  unsigned char msb, src1g;\n  unsigned long src1 = DSP_ALU_SRC1;\n  msb = DSP_ALU_SRC1G_BIT7;\n  src1g = (DSP_ALU_SRC1G_LSB8 << 1);\n  for (i = 38; ((msb == (src1g >> 7)) && (i >= 32)); i--)\n    src1g <<= 1;\n\n  if (i == 31)\n    for(i; ((msb == (src1 >> 31)) && (i >= 0)); i--)\n      src1 <<= 1;\n\n  DSP_ALU_DST = 0x0;\n  DSP_ALU_DST_HW = (short int)(30 - i);\n  if (DSP_ALU_DST_MSB)\n    DSP_ALU_DSTG_LSB8 = 0xFF;\n  else\n    DSP_ALU_DSTG_LSB8 = 0x0;\n\n  carry_bit = 0;\n\n  if (DC == 0)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG & MASK000000FF;\n\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG & MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pdmsb\tSy,Dz",
      "abstract": "If DC = 0: Sy data MSB position -> MSW of Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 1011111100yyzzzz",
      "T": "-",
      "description": "Conditionally finds the first position to change in the lineup of Sy operand<br />bits and stores the bit position in the Dz operand. The instruction is executed<br />if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pdmsb_sy_dcf (void)\\n{\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC1_MSB)\n    DSP_ALU_SRC1G = 0xFF;\n  else\n    DSP_ALU_SRC1G = 0x0;\n\n  short int i;\n  unsigned char msb, src1g;\n  unsigned long src1 = DSP_ALU_SRC1;\n  msb = DSP_ALU_SRC1G_BIT7;\n  src1g = (DSP_ALU_SRC1G_LSB8 << 1);\n  for (i = 38; ((msb == (src1g >> 7)) && (i >= 32)); i--)\n    src1g <<= 1;\n\n  if (i == 31)\n    for(i; ((msb == (src1 >> 31)) && (i >= 0)); i--)\n      src1 <<= 1;\n\n  DSP_ALU_DST = 0x0;\n  DSP_ALU_DST_HW = (short int)(30 - i);\n  if (DSP_ALU_DST_MSB)\n    DSP_ALU_DSTG_LSB8 = 0xFF;\n  else\n    DSP_ALU_DSTG_LSB8 = 0x0;\n\n  carry_bit = 0;\n\n  if (DC == 0)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG & MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG & MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "prnd\t\tSx,Dz",
      "abstract": "Sx + 0x00008000 -> Dz, clear LSW of Dz",
      "code": "111110********** 10011000xx00zzzz",
      "T": "-",
      "description": "Does rounding. Adds the immediate data 0x00008000 to the contents of the Sx<br />operand, stores the result in the upper word of the Dz operand, and clears the<br />bottom word of Dz with zeros.<br /><br />The DC bit of the DSR register is updated according to the specifications for<br />the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.<br /><br /><br />",
      "operation": "void prnd_sx (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  DSP_ALU_DST = (DSP_ALU_SRC1 + DSP_ALU_SRC2) &amp; MASKFFFF0000;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n  #include &quot;fixed_pt_unconditional_update.c&quot;\n  #include &quot;fixed_pt_plus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Arithmetic Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "prnd\t\tSy,Dz",
      "abstract": "Sy + 0x00008000 -> Dz, clear LSW of Dz",
      "code": "111110********** 1011100000yyzzzz",
      "T": "-",
      "description": "Does rounding. Adds the immediate data 0x00008000 to the contents of the Sy<br />operand, stores the result in the upper word of the Dz operand, and clears the<br />bottom word of Dz with zeros.<br /><br />The DC bit of the DSR register is updated according to the specifications for<br />the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.<br /><br /><br />",
      "operation": "void prnd_sy (void)\n{\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = M1;\n    break;\n  }\n\n  if (DSP_ALU_SRC1_MSB)\n    DSP_ALU_SRC1G = 0xFF;\n  else\n    DSP_ALU_SRC1G = 0x0;\n\n  DSP_ALU_DST = (DSP_ALU_SRC1 + DSP_ALU_SRC2) &amp; MASKFFFF0000;\n  carry_bit = ((DSP_ALU_SRC1_MSB | DSP_ALU_SRC2_MSB) &amp; ! DSP_ALU_DST_MSB)\n              | (DSP_ALU_SRC1_MSB &amp; DSP_ALU_SRC2_MSB);\n  DSP_ALU_DSTG_LSB8 = DSP_ALU_SRC1G_LSB8 + DSP_ALU_SRC2G_LSB8 + carry_bit;\n  overflow_bit = PLUS_OP_G_OV || ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include &quot;fixed_pt_overflow_protection.c&quot;\n  #include &quot;fixed_pt_unconditional_update.c&quot;\n  #include &quot;fixed_pt_plus_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Logical Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pand\t\tSx,Sy,Dz",
      "abstract": "Sx & Sy -> Dz, clear LSW of Dz",
      "code": "111110********** 10010101xxyyzzzz",
      "T": "-",
      "description": "Does an AND of the upper word of the Sx operand and the upper word of the Sy<br />operand, stores the result in the upper word of the Dz operand, and clears the<br />bottom word of the Dz operand with zeros. When Dz is a register that has guard<br />bits, the guard bits are also zeroed. The DC bit of the DSR register is updated<br />according to the specifications for the CS bits. The N, Z, V, and GT bits of<br />the DSR register are also updated. <br /><br /><br />NoteThe bottom word of the destination register and the guard bits are ignored when<br />the DC bit is updated.<br /><br /><br />",
      "operation": "void pand (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &amp; DSP_ALU_SRC2_HW;\n\n  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n  if (ex2_dz_no == 0)\n    A0G = 0x0;  // clear Guard bits\n  else if (ex2_dz_no == 1)\n    A1G = 0x0;\n\n  carry_bit = 0x0;\n  negative_bit = DSP_ALU_DST_MSB;\n  zero_bit = (DSP_ALU_DST_HW == 0);\n  overflow_bit = 0x0;\n\n  #include &quot;logical_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Logical Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pand\tSx,Sy,Dz",
      "abstract": "If DC = 1: Sx & Sy -> Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 10010110xxyyzzzz",
      "T": "-",
      "description": "Conditionally does an AND of the upper word of the Sx operand and the upper word<br />of the Sy operand, stores the result in the upper word of the Dz operand, and<br />clears the bottom word of the Dz operand with zeros. When Dz is a register that<br />has guard bits, the guard bits are also zeroed.<br />The instruction is executed if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pand_dct (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &amp; DSP_ALU_SRC2_HW;\n\n  if (DC == 1)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n      A0G = 0x0;  // clear Guard bits\n    else if (ex2_dz_no==1)\n      A1G = 0x0;\n  }\n}\n"
    },
    {
      "group": "DSP ALU Logical Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pand\tSx,Sy,Dz",
      "abstract": "If DC = 0: Sx & Sy -> Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 10010111xxyyzzzz",
      "T": "-",
      "description": "Conditionally does an AND of the upper word of the Sx operand and the upper word<br />of the Sy operand, stores the result in the upper word of the Dz operand, and<br />clears the bottom word of the Dz operand with zeros. When Dz is a register that<br />has guard bits, the guard bits are also zeroed.<br />The instruction is executed if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pand_dcf (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW &amp; DSP_ALU_SRC2_HW;\n\n  if (DC == 0)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n      A0G = 0x0;  // clear Guard bits\n    else if (ex2_dz_no==1)\n      A1G = 0x0;\n  }\n}\n"
    },
    {
      "group": "DSP ALU Logical Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "por\t\tSx,Sy,Dz",
      "abstract": "Sx | Sy -> Dz, clear LSW of Dz",
      "code": "111110********** 10110101xxyyzzzz",
      "T": "-",
      "description": "Takes the OR of the top word of the Sx operand and the top word of the Sy<br />operand, stores the result in the top word of the Dz operand, and clears the<br />bottom word of Dz with zeros. When Dz is a register that has guard bits, the<br />guard bits are also zeroed.   The DC bit of the DSR register is updated<br />according to the specifications for the CS bits. The N, Z, V, and GT bits of<br />the DSR register are also updated.<br /><br /><br />NoteThe bottom word of the destination register and the guard bits are ignored when<br />the DC bit is updated.<br /><br /><br />",
      "operation": "void por (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW | DSP_ALU_SRC2_HW;\n\n  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n  if (ex2_dz_no == 0)\n    A0G = 0x0;  // clear Guard bits\n  else if (ex2_dz_no == 1)\n    A1G = 0x0;\n\n  carry_bit = 0x0;\n  negative_bit = DSP_ALU_DST_MSB;\n  zero_bit = (DSP_ALU_DST_HW == 0);\n  overflow_bit = 0x0;\n\n  #include &quot;logical_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Logical Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct por\t\tSx,Sy,Dz",
      "abstract": "If DC = 1: Sx | Sy -> Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 10110110xxyyzzzz",
      "T": "-",
      "description": "Conditionally takes the OR of the top word of the Sx operand and the top word<br />of the Sy operand, stores the result in the top word of the Dz operand, and<br />clears the bottom word of Dz with zeros. When Dz is a register that has guard<br />bits, the guard bits are also zeroed.  The instruction is executed if the DC bit<br />is set to 1.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void por_dct (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW | DSP_ALU_SRC2_HW;\n\n  if (DC == 1)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n      A0G = 0x0;  // /*  */\n    else if (ex2_dz_no == 1)\n      A1G = 0x0;\n  }\n}\n"
    },
    {
      "group": "DSP ALU Logical Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf por\t\tSx,Sy,Dz",
      "abstract": "If DC = 0: Sx | Sy -> Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 10110111xxyyzzzz",
      "T": "-",
      "description": "Conditionally takes the OR of the top word of the Sx operand and the top word<br />of the Sy operand, stores the result in the top word of the Dz operand, and<br />clears the bottom word of Dz with zeros. When Dz is a register that has guard<br />bits, the guard bits are also zeroed.  The instruction is executed if the DC bit<br />is set to 0.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void por_dcf (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW | DSP_ALU_SRC2_HW;\n\n  if (DC == 0)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n      A0G = 0x0;  // /*  */\n    else if (ex2_dz_no == 1)\n      A1G = 0x0;\n  }\n}\n"
    },
    {
      "group": "DSP ALU Logical Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pxor\t\tSx,Sy,Dz",
      "abstract": "Sx ^ Sy -> Dz, clear LSW of Dz",
      "code": "111110********** 10100101xxyyzzzz",
      "T": "-",
      "description": "Takes the exclusive OR of the top word of the Sx operand and the top word of the<br />Sy operand, stores the result in the top word of the Dz operand, and clears the<br />bottom word of Dz with zeros. When Dz is a register that has guard bits, the<br />guard bits are also zeroed.  The DC bit of the DSR register is updated according<br />to the specifications for the CS bits. The N, Z, V, and GT bits of the DSR<br />register are also updated. <br /><br /><br />NoteThe bottom word of the destination register and the guard bits are ignored when<br />the DC bit is updated.<br /><br /><br />",
      "operation": "void pxor (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW ^ DSP_ALU_SRC2_HW;\n\n  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n  if (ex2_dz_no == 0)\n    A0G = 0x0;  // clear Guard bits\n  else if (ex2_dz_no == 1)\n    A1G = 0x0;\n\n  carry_bit = 0x0;\n  negative_bit = DSP_ALU_DST_MSB;\n  zero_bit = (DSP_ALU_DST_HW == 0);\n  overflow_bit = 0x0;\n\n  #include &quot;logical_dc_bit.c&quot;\n}\n"
    },
    {
      "group": "DSP ALU Logical Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pxor\tSx,Sy,Dz",
      "abstract": "If DC = 1: Sx ^ Sy -> Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 10100110xxyyzzzz",
      "T": "-",
      "description": "Conditionally takes the exclusive OR of the top word of the Sx operand and the<br />top word of the Sy operand, stores the result in the top word of the Dz operand,<br />and clears the bottom word of Dz with zeros. When Dz is a register that has<br />guard bits, the guard bits are also zeroed.<br />The instruction is executed if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pxor_dct (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW ^ DSP_ALU_SRC2_HW;\n\n  if (DC == 1)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n      A0G = 0x0;  // clear Guard bits\n    else if (ex2_dz_no == 1)\n      A1G = 0x0;\n  }\n}\n"
    },
    {
      "group": "DSP ALU Logical Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pxor\tSx,Sy,Dz",
      "abstract": "If DC = 0: Sx ^ Sy -> Dz, clear LSW of Dz\nElse: nop",
      "code": "111110********** 10100111xxyyzzzz",
      "T": "-",
      "description": "Conditionally takes the exclusive OR of the top word of the Sx operand and the<br />top word of the Sy operand, stores the result in the top word of the Dz operand,<br />and clears the bottom word of Dz with zeros. When Dz is a register that has<br />guard bits, the guard bits are also zeroed.<br />The instruction is executed if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pxor_dcf (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1;\n    break;\n  }\n\n  DSP_ALU_DST_HW = DSP_ALU_SRC1_HW ^ DSP_ALU_SRC2_HW;\n\n  if (DC == 0)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n      A0G = 0x0;  // clear Guard bits\n    else if (ex2_dz_no == 1)\n      A1G = 0x0;\n  }\n}\n"
    },
    {
      "group": "DSP Fixed Decimal Point Multiplication Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pmuls\tSe,Sf,Dg",
      "abstract": "MSW of Se * MSW of Sf -> Dg",
      "code": "111110********** 0100eeff0000gg00",
      "T": "-",
      "description": "The contents of the top word of the Se and Sf operands are multiplied as signed<br />and the result stored in the Dg operand. The DC, N, Z, V, and GT bits of the<br />DSR register are not updated.<br /><br /><br />NoteSince PMULS is fixed decimal point multiplication, the operation result is<br />different from that of MULS even though the source data is the same.<br /><br /><br />",
      "operation": "void pmuls (void)\n{\n  switch (ee)  // Se Operand selection bit (ee)\n  {\n  case 0x0:\n    DSP_M_SRC1 = X0;\n    break;\n  \n  case 0x1:\n    DSP_M_SRC1 = X1;\n    break;\n\n  case 0x2:\n    DSP_M_SRC1 = Y0;\n    break;\n\n  case 0x3:\n    DSP_M_SRC1 = A1;\n    break;\n  }\n\n  switch (ff)  // Sf Operand selection bit (ff)\n  {\n  case 0x0:\n    DSP_M_SRC2 = Y0;\n    break;\n\n  case 0x1:\n    DSP_M_SRC2 = Y1;\n    break;\n\n  case 0x2:\n    DSP_M_SRC2 = X0;\n    break;\n\n  case 0x3:\n    DSP_M_SRC2 = A1;\n    break;\n  }\n\n  if ((SBIT == 1) &amp;&amp; (DSP_M_SRC1 == 0x8000) &amp;&amp; (DSP_M_SRC2 == 0x8000))\n    DSP_M_DST = 0x7FFFFFFF;  // overflow protection\n  else\n    DSP_M_DST= ((long)(short)DSP_M_SRC1 * (long)(short)DSP_M_SRC2) &lt;&lt; 1;\n\n  if (DSP_M_DST_MSB)\n    DSP_M_DSTG_LSB8 = 0xFF;\n  else\n    DSP_M_DSTG_LSB8 = 0x0;\n\n  switch (gg)  // Dg Operand selection bit (gg)\n  {\n  case 0x0:\n    M0 = DSP_M_DST;\n    break;\n\n  case 0x1:\n    M1 = DSP_M_DST;\n    break;\n\n  case 0x2:\n    A0 = DSP_M_DST;\n    if (DSP_M_DSTG_LSB8 == 0x0)\n      A0G=0x0;\n    else\n      A0G = 0xFFFFFFFF;\n    break;\n\n  case 0x3:\n    A1 = DSP_M_DST;\n    if (DSP_M_DSTG_LSB8 == 0x0)\n      A1G = 0x0;\n    else\n      A1G = 0xFFFFFFFF;\n    break;\n  }\n}\n"
    },
    {
      "group": "DSP Shift Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "psha\t\tSx,Sy,Dz",
      "abstract": "If Sy >= 0: Sx << Sy -> Dz\nIf Sy < 0: Sx >> Sy -> Dz",
      "code": "111110********** 10010001xxyyzzzz",
      "T": "-",
      "description": "Arithmetically shifts the contents of the Sx or Dz operand and stores the result<br />in the Dz operand. The amount of the shift is specified by the Sy operand. <br />When the shift amount is positive, it shifts left. When the shift amount is<br />negative, it shifts right.<br />The DC bit of the DSR register is updated according to the specifications for<br />the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.<br /><br /><br />",
      "operation": "void psha (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0 & MASK007F0000;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1 & MASK007F0000;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0 & MASK007F0000;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1 & MASK007F0000;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  if ((DSP_ALU_SRC2_HW & MASK0040) == 0)\n  {\n    // Left Shift 0 <= cnt <= 32\n    char cnt = DSP_ALU_SRC2_HW & MASK003F;\n    if (cnt > 32)\n    {\n      printf (\"\\nPSHA Sz,Sy,Dz Error! Shift %2X exceed range.\\n\", cnt);\n      exit ();\n    }\n\n    DSP_ALU_DST = DSP_ALU_SRC1 << cnt;\n    DSP_ALU_DSTG = ((DSP_ALU_SRC1G << cnt)\n                   | (DSP_ALU_SRC1 >> (32 - cnt))) & MASK000000FF;\n    carry_bit = ((DSP_ALU_DSTG & MASK00000001) == 0x1);\n  }\n  else\n  {\n    // Right Shift 0 < cnt <= 32\n    char cnt = (~DSP_ALU_SRC2_HW & MASK003F) + 1;\n    if (cnt > 32)\n    {\n      printf (\"\\nPSHA Sz,Sy,Dz Error! shift -%2X exceed range.\\n\", cnt);\n      exit ();\n    }\n\n    if ((cnt > 8) && DSP_ALU_SRC1G_BIT7)\n    {\n      // MSB copy\n      DSP_ALU_DST = (DSP_ALU_SRC1 >> 8) | (DSP_ALU_SRC1G << (32 - 8));\n      DSP_ALU_DST = (long)DSP_ALU_DST >> (cnt - 8);\n    }\n    else\n      DSP_ALU_DST = (DSP_ALU_SRC1 >> cnt) | (DSP_ALU_SRC1G << (32 - cnt));\n\n    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 >> cnt--;\n    carry_bit = ((DSP_ALU_SRC1 >> cnt) & MASK00000001) == 0x1;\n  }\n\n  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include \"fixed_pt_overflow_protection.c\"\n  #include \"fixed_pt_unconditional_update.c\"  #include \"shift_dc_bit.c\"}"
    },
    {
      "group": "DSP Shift Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct psha\tSx,Sy,Dz",
      "abstract": "If DC = 1 & Sy >= 0: Sx << Sy -> Dz\nIf DC = 1 & Sy < 0: Sx >> Sy -> Dz\nIf DC = 0: nop",
      "code": "111110********** 10010010xxyyzzzz",
      "T": "-",
      "description": "Conditionally arithmetically shifts the contents of the Sx operand and<br />stores the result in the Dz operand. The amount of the shift is specified by<br />the Sy operand.  When the shift amount is positive, it shifts left. When the<br />shift amount is negative, it shifts right.<br />The instruction is executed if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void psha_dct (void)\n\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0 & MASK007F0000;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1 & MASK007F0000;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0 & MASK007F0000;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1 & MASK007F0000;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  if ((DSP_ALU_SRC2_HW & MASK0040) == 0)\n  {\n    // Left Shift 0 <= cnt <= 32\n    char cnt = DSP_ALU_SRC2_HW & MASK003F;\n    if (cnt > 32)\n    {\n      printf (\"\\nPSHA Sz,Sy,Dz Error! Shift %2X exceed range.\\n\", cnt);\n      exit ();\n    }\n\n    DSP_ALU_DST = DSP_ALU_SRC1 << cnt;\n    DSP_ALU_DSTG = ((DSP_ALU_SRC1G << cnt)\n                   | (DSP_ALU_SRC1 >> (32 - cnt))) & MASK000000FF;\n    carry_bit = ((DSP_ALU_DSTG & MASK00000001) == 0x1);\n  }\n  else\n  {\n    // Right Shift 0 < cnt <= 32\n    char cnt = (~DSP_ALU_SRC2_HW & MASK003F) + 1;\n    if (cnt > 32)\n    {\n      printf (\"\\nPSHA Sz,Sy,Dz Error! shift -%2X exceed range.\\n\", cnt);\n      exit ();\n    }\n\n    if ((cnt > 8) && DSP_ALU_SRC1G_BIT7)\n    {\n      // MSB copy\n      DSP_ALU_DST = (DSP_ALU_SRC1 >> 8) | (DSP_ALU_SRC1G << (32 - 8));\n      DSP_ALU_DST = (long)DSP_ALU_DST >> (cnt - 8);\n    }\n    else\n      DSP_ALU_DST = (DSP_ALU_SRC1 >> cnt) | (DSP_ALU_SRC1G << (32 - cnt));\n\n    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 >> cnt--;\n    carry_bit = ((DSP_ALU_SRC1 >> cnt) & MASK00000001) == 0x1;\n  }\n\n  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include \"fixed_pt_overflow_protection.c\"\n\n  if (DC == 1)\n  {\n    DSP_REG[ex2_dz_no] = DSP_ALU_DST;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG & MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG & MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}"
    },
    {
      "group": "DSP Shift Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf psha\tSx,Sy,Dz",
      "abstract": "If DC = 0 & Sy >= 0: Sx << Sy -> Dz\nIf DC = 0 & Sy < 0: Sx >> Sy -> Dz\nIf DC = 1: nop",
      "code": "111110********** 10010011xxyyzzzz",
      "T": "-",
      "description": "Conditionally arithmetically shifts the contents of the Sx operand and<br />stores the result in the Dz operand. The amount of the shift is specified by<br />the Sy operand.  When the shift amount is positive, it shifts left. When the<br />shift amount is negative, it shifts right.<br />The instruction is executed if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void psha_dcf (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    DSP_ALU_SRC1G = A1G;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0 & MASK007F0000;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1 & MASK007F0000;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0 & MASK007F0000;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2 = M1 & MASK007F0000;\n    break;\n  }\n\n  if (DSP_ALU_SRC2_MSB)\n    DSP_ALU_SRC2G = 0xFF;\n  else\n    DSP_ALU_SRC2G = 0x0;\n\n  if ((DSP_ALU_SRC2_HW & MASK0040) == 0)\n  {\n    // Left Shift 0 <= cnt <= 32\n    char cnt = DSP_ALU_SRC2_HW & MASK003F;\n    if (cnt > 32)\n    {\n      printf (\"\\nPSHA Sz,Sy,Dz Error! Shift %2X exceed range.\\n\", cnt);\n      exit ();\n    }\n\n    DSP_ALU_DST = DSP_ALU_SRC1 << cnt;\n    DSP_ALU_DSTG = ((DSP_ALU_SRC1G << cnt)\n                   | (DSP_ALU_SRC1 >> (32 - cnt))) & MASK000000FF;\n    carry_bit = ((DSP_ALU_DSTG & MASK00000001) == 0x1);\n  }\n  else\n  {\n    // Right Shift 0 < cnt <= 32\n    char cnt = (~DSP_ALU_SRC2_HW & MASK003F) + 1;\n    if (cnt > 32)\n    {\n      printf (\"\\nPSHA Sz,Sy,Dz Error! shift -%2X exceed range.\\n\", cnt);\n      exit ();\n    }\n\n    if ((cnt > 8) && DSP_ALU_SRC1G_BIT7)\n    {\n      // MSB copy\n      DSP_ALU_DST = (DSP_ALU_SRC1 >> 8) | (DSP_ALU_SRC1G << (32 - 8));\n      DSP_ALU_DST = (long)DSP_ALU_DST >> (cnt - 8);\n    }\n    else\n      DSP_ALU_DST = (DSP_ALU_SRC1 >> cnt) | (DSP_ALU_SRC1G << (32 - cnt));\n\n    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 >> cnt--;\n    carry_bit = ((DSP_ALU_SRC1 >> cnt) & MASK00000001) == 0x1;\n  }\n\n  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include \"fixed_pt_overflow_protection.c\"\n\n  if (DC == 0)\n  {\n    DSP_REG[ex2_dz_no] = DSP_ALU_DST;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG & MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G = A0G | MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG & MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G = A1G | MASKFFFFFF00;\n    }\n  }\n}"
    },
    {
      "group": "DSP Shift Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "psha\t\t#imm,Dz",
      "abstract": "If imm >= 0: Dz << imm -> Dz\nIf imm < 0: Dz >> imm -> Dz",
      "code": "111110********** 00000iiiiiiizzzz",
      "T": "-",
      "description": "Arithmetically shifts the contents of the Dz operand and stores the result in<br />the Dz operand. The amount of the shift is specified by the immediate value.<br />When the shift amount is positive, it shifts left. When the shift amount is<br />negative, it shifts right.<br />The DC bit of the DSR register is updated according to the specifications for<br />the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.<br /><br /><br />",
      "operation": "void psha_imm (void)\n{\n  unsigned short tmp_imm;\n  DSP_ALU_SRC1 = DSP_REG[ex2_dz_no];\n\n  switch (ex2_dz_no)\n  {\n    case 0x0:\n      DSP_ALU_SRC1G = A0G;\n      break;\n\n    case 0x1:\n      DSP_ALU_SRC1G = A1G;\n      break;\n\n    default:\n      if (DSP_ALU_SRC1_MSB)\n        DSP_ALU_SRC1G = 0xFF;\n      else\n        DSP_ALU_SRC1G = 0x0;\n  }\n\n  tmp_imm = ((EX2_LW >> 4) & MASK0000007F); // bit[10:4]\n\n  if ((tmp_imm & MASK0040) == 0)\n  {\n    // Left Shift 0 <= cnt <= 32\n    char cnt = tmp_imm & MASK003F;\n    if (cnt > 32)\n    {\n      printf (\"\\nPSHA Dz,#Imm,Dz Error! #Imm=%7X exceed range.\\n\", tmp_imm);\n      exit ();\n    }\n\n    DSP_ALU_DST = DSP_ALU_SRC1 << cnt;\n    DSP_ALU_DSTG = ((DSP_ALU_SRC1G << cnt)\n                   | (DSP_ALU_SRC1 >> (32 - cnt))) & MASK000000FF;\n    carry_bit = (DSP_ALU_DSTG & MASK00000001) == 0x1;\n  }\n  else\n  {\n    // Right Shift 0 < cnt <= 32\n    char cnt = (~tmp_imm & MASK003F) + 1;\n    if (cnt > 32)\n    {\n      printf (\"\\nPSHA Dz,#Imm,Dz Error! #Imm=%7X exceed range.\\n\", tmp_imm);\n      exit ();\n    }\n\n    if ((cnt > 8) && DSP_ALU_SRC1G_BIT7)\n    {\n      // MSB copy\n      DSP_ALU_DST = (DSP_ALU_SRC1 >> 8) | (DSP_ALU_SRC1G << (32 - 8));\n      DSP_ALU_DST = (long)DSP_ALU_DST >> (cnt - 8);\n    }\n    else\n      DSP_ALU_DST = (DSP_ALU_SRC1 >> cnt) | (DSP_ALU_SRC1G << (32 - cnt));\n\n    DSP_ALU_DSTG_LSB8 = (char)DSP_ALU_SRC1G_LSB8 >> cnt--;\n    carry_bit = ((DSP_ALU_SRC1 >> cnt) & MASK00000001) == 0x1;\n  }\n\n  overflow_bit = ! (POS_NOT_OV || NEG_NOT_OV);\n\n  #include \"fixed_pt_overflow_protection.c\"\n  #include \"fixed_pt_unconditional_update.c\"\n  #include \"shift_dc_bit.c\"\n}"
    },
    {
      "group": "DSP Shift Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pshl\t\tSx,Sy,Dz",
      "abstract": "If Sy >= 0: Sx << Sy -> Dz, clear LSW of Dz\nIf Sy < 0: Sx >> Sy -> Dz, clear LSW of Dz",
      "code": "111110********** 10000001xxyyzzzz",
      "T": "-",
      "description": "Logically shifts the top word contents of the Sx operand, stores the result in<br />the top word of the Dz operand, and clears the bottom word of the Dz operand<br />with zeros. When Dz is a register that has guard bits, the guard bits are also<br />zeroed. The amount of the shift is specified by the Sy operand. When the shift<br />amount is positive, it shifts left. When the shift amount is negative, it<br />shifts right.<br />The DC bit of the DSR register is updated according to the specifications for<br />the CS bits. The N, Z, V, and GT bits of the DSR register are also updated. <br /><br /><br />",
      "operation": "void pshl (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0 & MASK003F0000;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1 & MASK003F0000;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0 & MASK003F0000;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2  = M1 & MASK003F0000;\n    break;\n  }\n\n  if ((DSP_ALU_SRC2_HW & MASK0020) == 0)\n  {\n    // Left Shift 0 <= cnt <= 16\n    char cnt = DSP_ALU_SRC2_HW & MASK001F;\n    if (cnt > 16)\n    {\n      printf (\"\\nPSHL Sx,Sy,Dz Error! Shift %2X exceed range.\\n\", cnt);\n      exit ();\n    }\n    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW << cnt--;\n    carry_bit = ((DSP_ALU_SRC1_HW << cnt) & MASK8000) == 0x8000;\n  }\n  else\n  {\n    // Right Shift 0 < cnt <= 16\n    char cnt = (~DSP_ALU_SRC2_HW & MASK000F) + 1;\n    if (cnt > 16)\n    {\n      printf (\"\\nPSHL Sx,Sy,Dz Error! Shift -%2X exceed range.\\n\", cnt);\n      exit ();\n    }\n\n    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW >> cnt--;\n    carry_bit = ((DSP_ALU_SRC1_HW >> cnt) & MASK0001) == 0x1;\n  }\n\n  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n  if (ex2_dz_no == 0)\n    A0G = 0x0;  // clear Guard bits\n  else if (ex2_dz_no == 1)\n    A1G = 0x0;\n\n  negative_bit = DSP_ALU_DST_MSB;\n  zero_bit = DSP_ALU_DST_HW == 0;\n  overflow_bit = 0x0;\n\n  #include \"shift_dc_bit.c\"\n}"
    },
    {
      "group": "DSP Shift Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct pshl\tSx,Sy,Dz",
      "abstract": "If DC = 1 & Sy >= 0: Sx << Sy -> Dz, clear LSW of Dz\nIf DC = 1 & Sy < 0: Sx >> Sy -> Dz, clear LSW of Dz\nIf DC = 0: nop",
      "code": "111110********** 10000010xxyyzzzz",
      "T": "-",
      "description": "Conditionally logically shifts the top word contents of the Sx operand, stores<br />the result in the top word of the Dz operand, and clears the bottom word of the<br />Dz operand with zeros. When Dz is a register that has guard bits, the guard bits<br />are also zeroed. The amount of the shift is specified by the Sy operand. When<br />the shift amount is positive, it shifts left. When the shift amount is negative,<br />it shifts right.<br />The instruction is executed if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br />",
      "operation": "void pshl_dct(void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0 & MASK003F0000;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1 & MASK003F0000;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0 & MASK003F0000;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2  = M1 & MASK003F0000;\n    break;\n  }\n\n  if ((DSP_ALU_SRC2_HW & MASK0020) == 0)\n  {\n    // Left Shift 0 <= cnt <= 16\n    char cnt = DSP_ALU_SRC2_HW & MASK001F;\n    if (cnt > 16)\n    {\n      printf (\"\\nPSHL Sx,Sy,Dz Error! Shift %2X exceed range.\\n\", cnt);\n      exit ();\n    }\n    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW << cnt--;\n    carry_bit = ((DSP_ALU_SRC1_HW << cnt) & MASK8000) == 0x8000;\n  }\n  else\n  {\n    // Right Shift 0 < cnt <= 16\n    char cnt = (~DSP_ALU_SRC2_HW & MASK000F) + 1;\n    if (cnt > 16)\n    {\n      printf (\"\\nPSHL Sx,Sy,Dz Error! Shift -%2X exceed range.\\n\", cnt);\n      exit ();\n    }\n\n    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW >> cnt--;\n    carry_bit = ((DSP_ALU_SRC1_HW >> cnt) & MASK0001) == 0x1;\n  }\n\n  if (DC == 1)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n      A0G = 0x0;  // clear Guard bits\n    else if (ex2_dz_no == 1)\n      A1G = 0x0;\n  }\n}"
    },
    {
      "group": "DSP Shift Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf pshl\tSx,Sy,Dz",
      "abstract": "If DC = 0 & Sy >= 0: Sx << Sy -> Dz, clear LSW of Dz\nIf DC = 0 & Sy < 0: Sx >> Sy -> Dz, clear LSW of Dz\nIf DC = 1: nop",
      "code": "111110********** 10000011xxyyzzzz",
      "T": "-",
      "description": "Conditionally logically shifts the top word contents of the Sx operand, stores<br />the result in the top word of the Dz operand, and clears the bottom word of the<br />Dz operand with zeros. When Dz is a register that has guard bits, the guard bits<br />are also zeroed. The amount of the shift is specified by the Sy operand. When<br />the shift amount is positive, it shifts left. When the shift amount is negative,<br />it shifts right.<br />The instruction is executed if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits are not updated.<br /><br /><br /><br />",
      "operation": "void pshl_dcf (void)\n{\n  switch (EX2_SX)\n  {\n  case 0x0:\n    DSP_ALU_SRC1 = X0;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1 = X1;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC1 = A0;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC1 = A1;\n    break;\n  }\n\n  switch (EX2_SY)\n  {\n  case 0x0:\n    DSP_ALU_SRC2 = Y0 & MASK003F0000;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC2 = Y1 & MASK003F0000;\n    break;\n\n  case 0x2:\n    DSP_ALU_SRC2 = M0 & MASK003F0000;\n    break;\n\n  case 0x3:\n    DSP_ALU_SRC2  = M1 & MASK003F0000;\n    break;\n  }\n\n  if ((DSP_ALU_SRC2_HW & MASK0020) == 0)\n  {\n    // Left Shift 0 <= cnt <= 16\n    char cnt = DSP_ALU_SRC2_HW & MASK001F;\n    if (cnt > 16)\n    {\n      printf (\"\\nPSHL Sx,Sy,Dz Error! Shift %2X exceed range.\\n\", cnt);\n      exit ();\n    }\n    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW << cnt--;\n    carry_bit = ((DSP_ALU_SRC1_HW << cnt) & MASK8000) == 0x8000;\n  }\n  else\n  {\n    // Right Shift 0 < cnt <= 16\n    char cnt = (~DSP_ALU_SRC2_HW & MASK000F) + 1;\n    if (cnt > 16)\n    {\n      printf (\"\\nPSHL Sx,Sy,Dz Error! Shift -%2X exceed range.\\n\", cnt);\n      exit ();\n    }\n\n    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW >> cnt--;\n    carry_bit = ((DSP_ALU_SRC1_HW >> cnt) & MASK0001) == 0x1;\n  }\n\n  if (DC == 0)\n  {\n    DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n    DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n    if (ex2_dz_no == 0)\n      A0G = 0x0;  // clear Guard bits\n    else if (ex2_dz_no == 1)\n      A1G = 0x0;\n  }\n}"
    },
    {
      "group": "DSP Shift Operation Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "pshl\t\t#imm,Dz",
      "abstract": "If imm >= 0: Dz << imm -> Dz, clear LSW of Dz\nIf imm < 0: Dz >> imm, clear LSW of Dz",
      "code": "111110********** 00010iiiiiiizzzz",
      "T": "-",
      "description": "Logically shifts the top word contents of the Dz operand, stores the result in<br />the top word of the Dz operand, and clears the bottom word of the Dz operand<br />with zeros. When Dz is a register that has guard bits, the guard bits<br />are also zeroed. The amount of the shift is specified by the immediate value.<br />When the shift amount is positive, it shifts left. When the shift amount is<br />negative, it shifts right.<br />The DC bit of the DSR register is updated according to the specifications for<br />the CS bits. The N, Z, V, and GT bits of the DSR register are also updated.<br /><br /><br />",
      "operation": "void pshl_imm (void)\n{\n  unsigned short tmp_imm;\n  DSP_ALU_SRC1 = DSP_REG[ex2_dz_no];\n  switch (ex2_dz_no)\n  {\n  case 0x0:\n    DSP_ALU_SRC1G = A0G;\n    break;\n\n  case 0x1:\n    DSP_ALU_SRC1G = A1G;\n    break;\n\n  default:\n    if (DSP_ALU_SRC1_MSB)\n      DSP_ALU_SRC1G = 0xFF;\n    else\n      DSP_ALU_SRC1G = 0x0;\n  }\n\n  tmp_imm = ((EX2_LW >> 4) & MASK0000003F); // bit[9:4]\n  if ((tmp_imm & MASK0020) == 0)\n  {\n    // Left Shift 0 <= cnt < 16\n    char cnt = tmp_imm & MASK001F;\n    if (cnt > 16)\n    {\n      printf (\"\\nPSHL Dz,#Imm,Dz Error! #Imm=%6X exceed range.\\n\", tmp_imm);\n      exit ();\n    }\n    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW << cnt--;\n    carry_bit = ((DSP_ALU_SRC1_HW << cnt) & MASK8000) == 0x8000;\n  }\n  else\n  {\n    // Right Shift 0 < cnt <= 16\n    char cnt = (~tmp_imm & MASK001F) + 1;\n    if (cnt > 16)\n    {\n      printf (\"\\nPSHL Dz,#Imm,Dz Error! #Imm=%6X exceed range.\\n\", tmp_imm);\n      exit ();\n    }\n    DSP_ALU_DST_HW = DSP_ALU_SRC1_HW >> cnt--;\n    carry_bit = ((DSP_ALU_SRC1_HW >> cnt) & MASK0001) == 0x1;\n  }\n\n  DSP_REG_WD[ex2_dz_no*2] = DSP_ALU_DST_HW;\n  DSP_REG_WD[ex2_dz_no*2+1] = 0x0;  // clear LSW\n  if (ex2_dz_no == 0)\n    A0G = 0x0;  // clear Guard bits\n  else if (ex2_dz_no == 1)\n    A1G = 0x0;\n\n  negative_bit = DSP_ALU_DST_MSB;\n  zero_bit = DSP_ALU_DST_HW == 0;\n  overflow_bit = 0x0;\n\n  #include \"shift_dc_bit.c\"\n}"
    },
    {
      "group": "DSP System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "plds\t\tDz,MACH",
      "abstract": "Dz -> MACH",
      "code": "111110********** 111011010000zzzz",
      "T": "-",
      "description": "Stores the Dz operand in the MACH register.<br />The DC, N, Z, V, and GT bits of the DSR register are not updated.<br /><br /><br />NoteThough PSTS, MOVX, and MOVY can be designated in parallel, their execution may<br />take two cycles.<br /><br /><br />",
      "operation": "void plds_mach (void)\n{\n  MACH = DSP_REG[ex2_dz_no];\n}\n"
    },
    {
      "group": "DSP System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "plds\t\tDz,MACL",
      "abstract": "Dz -> MACL",
      "code": "111110********** 111111010000zzzz",
      "T": "-",
      "description": "Stores the Dz operand in the MACL register.<br />The DC, N, Z, V, and GT bits of the DSR register are not updated.<br /><br /><br />NoteThough PSTS, MOVX, and MOVY can be designated in parallel, their execution may<br />take two cycles.<br /><br /><br />",
      "operation": "void plds_macl (void)\n{\n  MACL = DSP_REG[ex2_dz_no];\n}\n"
    },
    {
      "group": "DSP System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct plds\tDz,MACH",
      "abstract": "If DC = 1: Dz -> MACH\nElse: nop",
      "code": "111110********** 111011100000zzzz",
      "T": "-",
      "description": "Conditionally stores the Dz operand in the MACH register.<br />The instruction is executed if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits of the DSR register are not updated.<br /><br /><br />NoteThough PSTS, MOVX, and MOVY can be designated in parallel, their execution may<br />take two cycles.<br /><br /><br />",
      "operation": "void plds_mach_dct (void)\n{\n  if (DC == 1)\n    MACH = DSP_REG[ex2_dz_no];\n}\n"
    },
    {
      "group": "DSP System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct plds\tDz,MACL",
      "abstract": "If DC = 1: Dz -> MACL\nElse: nop",
      "code": "111110********** 111111100000zzzz",
      "T": "-",
      "description": "Conditionally stores the Dz operand in the MACL register.<br />The instruction is executed if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits of the DSR register are not updated.<br /><br /><br />NoteThough PSTS, MOVX, and MOVY can be designated in parallel, their execution may<br />take two cycles.<br /><br /><br />",
      "operation": "void plds_macl_dct (void)\n{\n  if (DC == 1)\n    MACL = DSP_REG[ex2_dz_no];\n}\n"
    },
    {
      "group": "DSP System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf plds\tDz,MACH",
      "abstract": "If DC = 0: Dz -> MACH\nElse: nop",
      "code": "111110********** 111011110000zzzz",
      "T": "-",
      "description": "Conditionally stores the Dz operand in the MACH register.<br />The instruction is executed if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits of the DSR register are not updated.<br /><br /><br />NoteThough PSTS, MOVX, and MOVY can be designated in parallel, their execution may<br />take two cycles.<br /><br /><br />",
      "operation": "void plds_mach_dcf (void)\n{\n  if (DC == 0)\n    MACH = DSP_REG[ex2_dz_no];\n}\n"
    },
    {
      "group": "DSP System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf plds\tDz,MACL",
      "abstract": "If DC = 0: Dz -> MACL\nElse: nop",
      "code": "111110********** 111111110000zzzz",
      "T": "-",
      "description": "Conditionally stores the Dz operand in the MACL register.<br />The instruction is executed if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits of the DSR register are not updated.<br /><br /><br />NoteThough PSTS, MOVX, and MOVY can be designated in parallel, their execution may<br />take two cycles.<br /><br /><br />",
      "operation": "void plds_macl_dcf (void)\n{\n  if (DC == 0)\n    MACL = DSP_REG[ex2_dz_no];\n}\n"
    },
    {
      "group": "DSP System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "psts\t\tMACH,Dz",
      "abstract": "MACH -> Dz",
      "code": "111110********** 110011010000zzzz",
      "T": "-",
      "description": "Stores the contents of the MACH register in the Dz operand. <br />The DC, N, Z, V, and GT bits of the DSR register are not updated.<br /><br /><br />NoteThough PSTS, MOVX and MOVY can be designated in parallel, their execution may<br />take 2 cycles.<br /><br /><br />",
      "operation": "void psts_mach (void)\n{\n  DSP_REG[ex2_dz_no] = MACH;\n  if (ex2_dz_no == 0)\n  {\n    A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n    if (DSP_ALU_DSTG_BIT7)\n      A0G |= MASKFFFFFF00;\n  }\n  else if (ex2_dz_no == 1)\n  {\n    A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n    if (DSP_ALU_DSTG_BIT7)\n      A1G |= MASKFFFFFF00;\n  }\n}\n"
    },
    {
      "group": "DSP System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "psts\t\tMACL,Dz",
      "abstract": "MACL -> Dz",
      "code": "111110********** 110111010000zzzz",
      "T": "-",
      "description": "Stores the contents of the MACL register in the Dz operand. <br />The DC, N, Z, V, and GT bits of the DSR register are not updated.<br /><br /><br />NoteThough PSTS, MOVX and MOVY can be designated in parallel, their execution may<br />take 2 cycles.<br /><br /><br />",
      "operation": "void psts_macl (void)\n{\n  DSP_REG[ex2_dz_no] = MACL;\n  if (ex2_dz_no == 0)\n  {\n    A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n    if (DSP_ALU_DSTG_BIT7)\n      A0G |= MASKFFFFFF00;\n  }\n  else if (ex2_dz_no == 1)\n  {\n    A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n    if (DSP_ALU_DSTG_BIT7)\n      A1G |= MASKFFFFFF00;\n  }\n}\n"
    },
    {
      "group": "DSP System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct psts\tMACH,Dz",
      "abstract": "If DC = 1: MACH -> Dz\nElse: nop",
      "code": "111110********** 110011100000zzzz",
      "T": "-",
      "description": "Conditionally stores the contents of the MACH register in the Dz operand.<br />The instruction is executed if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits of the DSR register are not updated.<br /><br /><br />NoteThough PSTS, MOVX and MOVY can be designated in parallel, their execution may<br />take 2 cycles.<br /><br /><br />",
      "operation": "void psts_mach_dct (void)\n{\n  if (DC == 1)\n  {\n    DSP_REG[ex2_dz_no] = MACH;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G |= MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G |= MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dct psts\tMACL,Dz",
      "abstract": "If DC = 1: MACL -> Dz\nElse: nop",
      "code": "111110********** 110111100000zzzz",
      "T": "-",
      "description": "Conditionally stores the contents of the MACL register in the Dz operand.<br />The instruction is executed if the DC bit is set to 1.<br />The DC, N, Z, V, and GT bits of the DSR register are not updated.<br /><br /><br />NoteThough PSTS, MOVX and MOVY can be designated in parallel, their execution may<br />take 2 cycles.<br /><br /><br />",
      "operation": "void psts_macl_dct (void)\n{\n  if (DC == 1)\n  {\n    DSP_REG[ex2_dz_no] = MACL;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G |= MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G |= MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf psts\tMACH,Dz",
      "abstract": "If DC = 0: MACH -> Dz\nElse: nop",
      "code": "111110********** 110011110000zzzz",
      "T": "-",
      "description": "Conditionally stores the contents of the MACH register in the Dz operand.<br />The instruction is executed if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits of the DSR register are not updated.<br /><br /><br />NoteThough PSTS, MOVX and MOVY can be designated in parallel, their execution may<br />take 2 cycles.<br /><br /><br />",
      "operation": "void psts_mach_dcf (void)\n{\n  if (DC == 0)\n  {\n    DSP_REG[ex2_dz_no] = MACH;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G |= MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G |= MASKFFFFFF00;\n    }\n  }\n}\n"
    },
    {
      "group": "DSP System Control Instructions",
      "SH1": false,
      "SH1.issue": 0,
      "SH1.latency": 0,
      "SH2": false,
      "SH2.issue": 0,
      "SH2.latency": 0,
      "SH2E": false,
      "SH2E.issue": 0,
      "SH2E.latency": 0,
      "SH3": false,
      "SH3.issue": 0,
      "SH3.latency": 0,
      "SH3E": false,
      "SH3E.issue": 0,
      "SH3E.latency": 0,
      "SH4": false,
      "SH4.issue": 0,
      "SH4.latency": 0,
      "SH4A": false,
      "SH4A.issue": 0,
      "SH4A.latency": 0,
      "SH2A": false,
      "SH2A.issue": 0,
      "SH2A.latency": 0,
      "DSP": true,
      "DSP.issue": 1,
      "DSP.latency": 1,
      "format": "dcf psts\tMACL,Dz",
      "abstract": "If DC = 0: MACL -> Dz\nElse: nop",
      "code": "111110********** 110111110000zzzz",
      "T": "-",
      "description": "Conditionally stores the contents of the MACL register in the Dz operand.<br />The instruction is executed if the DC bit is set to 0.<br />The DC, N, Z, V, and GT bits of the DSR register are not updated.<br /><br /><br />NoteThough PSTS, MOVX and MOVY can be designated in parallel, their execution may<br />take 2 cycles.<br /><br /><br />",
      "operation": "void psts_macl_dcf (void)\n{\n  if (DC == 0)\n  {\n    DSP_REG[ex2_dz_no] = MACL;\n    if (ex2_dz_no == 0)\n    {\n      A0G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A0G |= MASKFFFFFF00;\n    }\n    else if (ex2_dz_no == 1)\n    {\n      A1G = DSP_ALU_DSTG &amp; MASK000000FF;\n      if (DSP_ALU_DSTG_BIT7)\n        A1G |= MASKFFFFFF00;\n    }\n  }\n}\n"
    }
  ]
}
